<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />

    

    

    <title>Category: 架构 | Donjote 博客</title>
    <meta name="author" content="Donjote" />
    <meta name="version" content="1.0.0" />
    <meta name="keywords" content="undefined" />
    <meta name="description" content="null" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
    <meta name="baidu-site-verification" content="F0CXvmUgA9" />

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Tags</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Electron/">Electron</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang/">Golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NoSQL/">NoSQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nodejs/">Nodejs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RPC/">RPC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React-Native/">React Native</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Restful/">Restful</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TensorFlow/">TensorFlow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Weex/">Weex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Yarn/">Yarn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/etcd/">etcd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gRPC/">gRPC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm镜像/">npm镜像</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-boot/">spring boot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/事务/">事务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式架构/">分布式架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/区块链/">区块链</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微服务/">微服务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/敏捷开发/">敏捷开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务发现/">服务发现</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/深度学习/">深度学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/神经网络/">神经网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/跨平台/">跨平台</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">归档</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/about">关于</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://donjote.github.io"></form>

        
        

        
        <div class="author-meta">
            
            <div class="author-avatar">
                <a href="/">
                    <img src="/images/avatar.jpg" title="Sanonz">
                </a>
            </div>
            
            <div class="author-name">Donjote</div>
            <div class="author-work"></div>
            <div class="author-location">
                <i class="icon-location vm"></i>
                <span class="vm">Shenzhen, China</span>
            </div>
            
            <div class="author-thread-wrap">
                <div class="author-threads clearfix">
                    
                    <a class="thread-item" href="https://github.com/donjote" target="_blank" rel="noopener"><i class="icon-github"></i></a>
                    
                    
                    
                </div>
            </div>
            
        </div>
        
    </div>
</aside>

</header>

        <div id="content" class="content">
    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/09/01/restful/">RESTful API 设计指南[引用]</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/09/01/restful/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-08-31T16:00:00.000Z" itemprop="datePublished">2017-09-01</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Restful/">Restful</a>, <a class="article-tag-link" href="/tags/架构/">架构</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><blockquote>
<p>API与用户的通信协议，总是使用HTTPs协议。</p>
</blockquote>
<h2 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h2><blockquote>
<p>应该尽量将API部署在专用域名之下。</p>
<blockquote>
<p><a href="https://api.example.com" target="_blank" rel="external">https://api.example.com</a></p>
</blockquote>
<p>如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。</p>
<blockquote>
<p><a href="https://example.com/api/" target="_blank" rel="external">https://example.com/api/</a></p>
</blockquote>
</blockquote>
<h2 id="版本（Versioning）"><a href="#版本（Versioning）" class="headerlink" title="版本（Versioning）"></a>版本（Versioning）</h2><blockquote>
<p>应该将API的版本号放入URL。</p>
<blockquote>
<p><a href="https://api.example.com/v1/" target="_blank" rel="external">https://api.example.com/v1/</a></p>
</blockquote>
<p>另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。<a href="https://developer.github.com/v3/media/#request-specific-version" target="_blank" rel="external">Github</a>采用这种做法。</p>
</blockquote>
<h2 id="路径（Endpoint）"><a href="#路径（Endpoint）" class="headerlink" title="路径（Endpoint）"></a>路径（Endpoint）</h2><blockquote>
<p>路径又称”终结点”（endpoint），表示API的具体网址。<br>在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。<br>举例来说，有一个API提供用户（user）的信息，则它的路径应该设计成下面这样。</p>
<blockquote>
<p><a href="https://api.example.com/v1/users" target="_blank" rel="external">https://api.example.com/v1/users</a></p>
</blockquote>
</blockquote>
<h2 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h2><blockquote>
<p>对于资源的具体操作类型，由HTTP方法表示。<br>常用的HTTP方法有下面五个（括号里是对应的SQL命令）。</p>
<blockquote>
<ul>
<li>GET（SELECT）：从服务器取出资源（一项或多项）。</li>
<li>POST（CREATE）：在服务器新建一个资源。</li>
<li>PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。</li>
<li>PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。</li>
<li>DELETE（DELETE）：从服务器删除资源。</li>
</ul>
<hr>
<p>还有两个不常用的HTTP方法。</p>
<ul>
<li>HEAD：获取资源的元数据。</li>
<li>OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。</li>
</ul>
</blockquote>
<p>下面是一些例子。</p>
<blockquote>
<ul>
<li>GET /users：列出所有用户</li>
<li>POST /users：新建一个用户</li>
<li>GET /users/ID：获取某个指定用户的信息</li>
<li>PUT /users/ID：更新某个指定用户的信息（提供该用户的全部信息）</li>
<li>PATCH /users/ID：更新某个指定用户的信息（提供该用户的部分信息）</li>
<li>DELETE /users/ID：删除某个用户</li>
<li>GET /users/ID/address：列出某个指定用户的所有地址</li>
<li>DELETE /users/ID/address/ID：删除某个指定用户的指定地址</li>
</ul>
</blockquote>
</blockquote>
<h2 id="过滤信息（Filtering）"><a href="#过滤信息（Filtering）" class="headerlink" title="过滤信息（Filtering）"></a>过滤信息（Filtering）</h2><blockquote>
<p>如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。<br>下面是一些常见的参数。</p>
<blockquote>
<ul>
<li>?limit=10：指定返回记录的数量</li>
<li>?offset=10：指定返回记录的开始位置。</li>
<li>?page=2&amp;per_page=100：指定第几页，以及每页的记录数。</li>
<li>?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</li>
<li>?animal_type_id=1：指定筛选条件</li>
</ul>
</blockquote>
<p>参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /users/ID/address 与 GET /address?user_id=ID 的含义是相同的。</p>
</blockquote>
<h2 id="状态码（Status-Codes）"><a href="#状态码（Status-Codes）" class="headerlink" title="状态码（Status Codes）"></a>状态码（Status Codes）</h2><blockquote>
<p>服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。</p>
<blockquote>
<ul>
<li>200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</li>
<li>201 CREATED - [POST/PUT]：用户新建或修改数据成功。</li>
<li>202 Accepted - [* ]：表示一个请求已经进入后台排队（异步任务）</li>
<li>204 NO CONTENT - [DELETE/PATCH]：服务器成功处理了请求,但不需要返回任何实体内容。</li>
<li>400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。</li>
<li>401 Unauthorized - [* ]：表示用户没有权限（令牌、用户名、密码错误）。</li>
<li>403 Forbidden - [* ] 表示用户得到授权（与401错误相对），但是访问是被禁止的。</li>
<li>404 NOT FOUND - [* ]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</li>
<li>406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。</li>
<li>410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。</li>
<li>422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。</li>
<li>500 INTERNAL SERVER ERROR - [* ]：服务器发生错误，用户将无法判断发出的请求是否成功。</li>
</ul>
</blockquote>
<p>状态码的完全列表参见<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html" target="_blank" rel="external">这里</a>。</p>
</blockquote>
<h2 id="错误处理（Error-handling）"><a href="#错误处理（Error-handling）" class="headerlink" title="错误处理（Error handling）"></a>错误处理（Error handling）</h2><blockquote>
<p>如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。</p>
<pre><code>{
  error: &quot;Invalid API key&quot;
}
</code></pre></blockquote>
<h2 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h2><blockquote>
<p>针对不同操作，服务器向用户返回的结果应该符合以下规范。</p>
<blockquote>
<ul>
<li>GET /collection：返回资源对象的列表（数组）</li>
<li>GET /collection/resource：返回单个资源对象</li>
<li>POST /collection：返回新生成的资源对象</li>
<li>PUT /collection/resource：返回完整的资源对象</li>
<li>PATCH /collection/resource：返回一个空文档</li>
<li>DELETE /collection/resource：返回一个空文档</li>
</ul>
</blockquote>
</blockquote>
<h2 id="Hypermedia-API"><a href="#Hypermedia-API" class="headerlink" title="Hypermedia API"></a>Hypermedia API</h2><blockquote>
<p>RESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。<br>比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。</p>
<pre><code>{
  &quot;link&quot;: {
    &quot;rel&quot;:   &quot;collection https://www.example.com/users&quot;,
    &quot;href&quot;:  &quot;https://api.example.com/users&quot;,
    &quot;title&quot;: &quot;List of users&quot;,
    &quot;type&quot;:  &quot;application/vnd.yourformat+json&quot;
  }
}
</code></pre><p>上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。<br>Hypermedia API的设计被称为<a href="https://en.wikipedia.org/wiki/HATEOAS" target="_blank" rel="external">HATEOAS</a>。Github的API就是这种设计，访问api.github.com会得到一个所有可用API的网址列表。</p>
<pre><code>{
  &quot;current_user_url&quot;: &quot;https://api.github.com/user&quot;,
  &quot;authorizations_url&quot;: &quot;https://api.github.com/authorizations&quot;,
  // ...
}
</code></pre><p>从上面可以看到，如果想获取当前用户的信息，应该去访问api.github.com/user，然后就得到了下面结果。</p>
<pre><code>{
  &quot;message&quot;: &quot;Requires authentication&quot;,
  &quot;documentation_url&quot;: &quot;https://developer.github.com/v3&quot;
}
</code></pre><p>上面代码表示，服务器给出了提示信息，以及文档的网址。</p>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/08/31/git/">Git使用简介</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/08/31/git/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-08-30T16:00:00.000Z" itemprop="datePublished">2017-08-31</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Git/">Git</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>Git是一款免费、开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理</p>
</blockquote>
<h2 id="git和svn的差异"><a href="#git和svn的差异" class="headerlink" title="git和svn的差异"></a>git和svn的差异</h2><blockquote>
<p>git和svn最大的差异在于git是分布式的管理方式而svn是集中式的管理方式。</p>
</blockquote>
<h3 id="集中式管理"><a href="#集中式管理" class="headerlink" title="集中式管理"></a>集中式管理</h3><blockquote>
<ul>
<li>集中式管理的工作流程图：<blockquote>
<p><img src="/donjote-blog/2017/08/31/git/1.png" alt="集中式管理的工作流程图"></p>
</blockquote>
</li>
</ul>
<p>&emsp;&emsp;集中式代码管理的核心是服务器，所有开发者在开始新一天的工作之前必须从服务器获取代码，然后开发，最后解决冲突，提交。所有的版本信息都放在服务器上。如果脱离了服务器，开发者基本上是不可以工作。下面举例说明：</p>
<p><font color="red"> <strong>开始新一天的工作：</strong></font></p>
<ol>
<li>从服务器下载项目组最新代码。</li>
<li>进入自己的分支，进行工作，每隔1个小时向服务器自己的分支提交一次代码（很多人都有这个习惯。因为有时候自己对代码改来改去，最后又想还原到前一个小时的版本，或者看看前一个小时自己修改了哪些代码，就需要这样做了）。</li>
<li>下班时间快到了，把自己的分支合并到服务器主分支上，一天的工作完成，并反映给服务器。<br>这就是经典的svn工作流程，从流程上看，有不少缺点，但也有优点。</li>
</ol>
<ul>
<li><strong>缺点：</strong></li>
</ul>
<ol>
<li>服务器压力太大，数据库容量暴增。</li>
<li>如果不能连接到服务器上，基本上不可以工作，看上面第二步，如果服务器不能连接上，就不能提交，还原，对比等等。</li>
<li>不适合开源开发（开发人数非常非常多，但是Google app engine就是用svn的）。但是一般集中式管理的有非常明确的权限管理机制（例如分支访问限制），可以实现分层管理，从而很好的解决开发人数众多的问题。</li>
</ol>
<ul>
<li><strong>优点：</strong></li>
</ul>
<ol>
<li>管理方便，逻辑明确，符合一般人思维习惯。</li>
<li>易于管理，集中式服务器更能保证安全性。</li>
<li>代码一致性非常高。</li>
<li>适合开发人数不多的项目开发。</li>
<li>大部分软件配置管理的大学教材都是使用svn 和vss。</li>
</ol>
</blockquote>
<h3 id="分布式管理"><a href="#分布式管理" class="headerlink" title="分布式管理"></a>分布式管理</h3><blockquote>
<ul>
<li>分布式管理的工作流程图：<blockquote>
<p><img src="/donjote-blog/2017/08/31/git/2.png" alt="分布式管理的工作流程图"></p>
</blockquote>
</li>
</ul>
<p>&emsp;&emsp;分布式和集中式的最大区别在于开发者可以在本地提交。每个开发者机器上都有一个服务器的数据库。<br>&emsp;&emsp;上图就是经典的git开发过程。步骤如下：</p>
<ul>
<li><strong>一般开发者的角度：</strong></li>
</ul>
<ol>
<li>从服务器上克隆数据库（包括代码和版本信息）到单机上。</li>
<li>在自己的机器上创建分支，修改代码。</li>
<li>在单机上自己创建的分支上提交代码。</li>
<li>在单机上合并分支。</li>
<li>新建一个分支，把服务器上最新版的代码fetch下来，然后跟自己的主分支合并。</li>
<li>生成补丁（patch），把补丁发送给主开发者。</li>
<li>看主开发者的反馈，如果主开发者发现两个一般开发者之间有冲突（他们之间可以合作解决的冲突），就会要求他们先解决冲突，然后再由其中一个人提交。如果主开发者可以自己解决，或者没有冲突，就通过。</li>
<li>一般开发者之间解决冲突的方法，开发者之间可以使用pull命令解决冲突，解决完冲突之后再向主开发者提交补丁。</li>
</ol>
<ul>
<li><strong>主开发者的角度（假设主开发者不用开发代码）：</strong></li>
</ul>
<ol>
<li>查看邮件或者通过其它方式查看一般开发者的提交状态。</li>
<li>打上补丁，解决冲突（可以自己解决，也可以要求开发者之间解决以后再重新提交，如果是开源项目，还要决定哪些补丁可用，哪些不用）。</li>
<li>向公共服务器提交结果，然后通知所有开发人员。</li>
</ol>
<ul>
<li><strong>优点：</strong></li>
</ul>
<ol>
<li>适合分布式开发，强调个体。</li>
<li>公共服务器压力和数据量都不会太大。</li>
<li>速度快、灵活。</li>
<li>任意两个开发者之间可以很容易的解决冲突。</li>
</ol>
<ul>
<li><strong>缺点：</strong></li>
</ul>
<ol>
<li>资料少（起码中文资料很少）。</li>
<li>学习周期相对而言比较长。</li>
<li>不符合常规思维。</li>
<li>代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有代码和版本信息。</li>
</ol>
</blockquote>
<h2 id="git常用命令介绍"><a href="#git常用命令介绍" class="headerlink" title="git常用命令介绍"></a>git常用命令介绍</h2><blockquote>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>git init　</td>
<td>创建一个数据库</td>
</tr>
<tr>
<td>git clone</td>
<td>复制一个数据到制定文件夹</td>
</tr>
<tr>
<td>git add 和git commit</td>
<td>把想提交的文件add上，然后commit这些文件到本地数据库。</td>
</tr>
<tr>
<td>git pull</td>
<td>从服务器下载数据库，并跟自己的数据库合并。</td>
</tr>
<tr>
<td>git fetch</td>
<td>从服务器下载数据库，并放到新分支，不跟自己的数据库合并。</td>
</tr>
<tr>
<td>git whatchanged</td>
<td>查看两个分支的变化</td>
</tr>
<tr>
<td>git branch</td>
<td>创建分支，查看分支，删除分支</td>
</tr>
<tr>
<td>git checkout</td>
<td>切换分支</td>
</tr>
<tr>
<td>git merge</td>
<td>合并分支，把目标分支合并到当前分支</td>
</tr>
<tr>
<td>git config</td>
<td>配置相关信息，例如email和name</td>
</tr>
<tr>
<td>git log</td>
<td>查看版本历史</td>
</tr>
<tr>
<td>git show</td>
<td>查看版本号对于版本的历史，如果参数是HEAD查看最新版本。</td>
</tr>
<tr>
<td>git tag</td>
<td>标定版本号</td>
</tr>
<tr>
<td>git reset</td>
<td>恢复到之前的版本 <br>–mixed是git-reset的默认选项，它的作用是重置索引内容，将其定位到指定的项目版本，而不改变你的工作树中的所有内容，只是提示你有哪些文件还未更新。<br>–soft选项既不触动索引的位置，也不改变工作树中的任何内容。该选项会保留你在工作树中的所有更新并使之处于待提交状态。相当于在<br>–mixed基础上加上git add。 –hard 把整个目录还原到一个版本，包括所有文件。</td>
</tr>
<tr>
<td>git push</td>
<td>向其他数据库推送自己的数据库</td>
</tr>
<tr>
<td>git status</td>
<td>显示当前的状态</td>
</tr>
<tr>
<td>git mv</td>
<td>重命名文件或者文件夹</td>
</tr>
<tr>
<td>git rm</td>
<td>删除文件或者文件夹</td>
</tr>
<tr>
<td>git help</td>
<td>查看帮助，还有几个无关紧要的命令，请自己查看帮助。</td>
</tr>
</tbody>
</table>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/08/30/transaction_tcc/">TCC柔性事务</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/08/30/transaction_tcc/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-08-29T16:00:00.000Z" itemprop="datePublished">2017-08-30</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/事务/">事务</a>, <a class="article-tag-link" href="/tags/架构/">架构</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <blockquote>
<p>&emsp;&emsp;分布式事务是一个绕不过去的挑战！微服务架构本质上就是分布式服务化架构，微服务架构的流行，让分布式事务问题日益突出！尤其是在订单业务、资金业务等系统核心业务流程中，一定要有可靠的分布式事务解决方案来保证业务数据的可靠性和准确性。</p>
<h2 id="TCC事务机制简介"><a href="#TCC事务机制简介" class="headerlink" title="TCC事务机制简介"></a>TCC事务机制简介</h2><p>&emsp;&emsp;关于TCC（Try-Confirm-Cancel）的概念，最早是由Pat Helland于2007年发表的一篇名为《Life beyond Distributed Transactions:an Apostate’s Opinion》的论文提出。在该论文中，TCC还是以Tentative-Confirmation-Cancellation作为名称；正式以Try-Confirm-Cancel作为名称的，可能是Atomikos（Gregor Hohpe所著书籍《Enterprise Integration Patterns》中收录了关于TCC的介绍，提到了Atomikos的Try-Confirm-Cancel，并认为二者是相似的概念）。</p>
<p>&emsp;&emsp;国内最早关于TCC的报道，应该是InfoQ上对阿里程立博士的一篇采访。经过程博士的这一次传道之后，TCC在国内逐渐被大家广为了解并接受。相应的实现方案和开源框架也先后被发布出来。</p>
<p>&emsp;&emsp;TCC事务机制相对于传统事务机制（X/Open XA），其特征在于它不依赖资源管理器(RM)对XA的支持，而是通过对（由业务系统提供的）业务逻辑的调度来实现分布式事务。对于业务系统中一个特定的业务逻辑S，其对外提供服务时，必须接受一些不确定性，即对业务逻辑执行的一次调用仅是一个临时性操作，调用它的消费方服务M保留了后续的取消权。如果M认为全局事务应该rollback，它会要求取消之前的临时性操作，这就对应S的一个取消操作。而当M认为全局事务应该commit时，它会放弃之前临时性操作的取消权，这对应S的一个确认操作。 每一个初步操作，最终都会被确认或取消。因此，针对一个具体的业务服务，TCC事务机制需要业务系统提供三段业务逻辑：初步操作Try、确认操作Confirm、取消操作Cancel。</p>
<hr>
<p><font color="red">1. 初步操作（Try）</font><br>&emsp;&emsp;TCC事务机制中的业务逻辑（Try），从执行阶段来看，与传统事务机制中业务逻辑相同。但从业务角度来看，是不一样的。TCC机制中的Try仅是一个初步操作，它和后续的次确认一起才能真正构成一个完整的业务逻辑。因此，可以认为[传统事务机制]的业务逻辑 = [TCC事务机制]的初步操作（Try） + [TCC事务机制]的确认逻辑（Confirm）。TCC机制将传统事务机制中的业务逻辑一分为二，拆分后保留的部分即为初步操作（Try）；而分离出的部分即为确认操作（Confirm），被延迟到事务提交阶段执行。<br>TCC事务机制以初步操作（Try）为中心，确认操作（Confirm）和取消操作（Cancel）都是围绕初步操作（Try）而展开。因此，Try阶段中的操作，其保障性是最好的，即使失败，仍然有取消操作（Cancel）可以将其不良影响进行回撤。</p>
<p><font color="red">2. 确认操作（Confirm）</font><br>&emsp;&emsp;确认操作（Confirm）是对初步操作（Try）的一个补充。当TCC事务管理器认为全局事务可以正确提交时，就会逐个执行初步操作（Try）指定的确认操作（Confirm），将初步操作（Try）未完成的事项最终完成。</p>
<p><font color="red">3. 取消操作（Cancel）</font><br>&emsp;&emsp;取消操作（Cancel）是对初步操作（Try）的一个回撤。当TCC事务管理器认为全局事务不能正确提交时，就会逐个执行初步操作（Try）指定的取消操作（Cancel），将初步操作（Try）已完成的事项全部撤回。</p>
</blockquote>
<h2 id="支付宝运营架构中柔性事务"><a href="#支付宝运营架构中柔性事务" class="headerlink" title="支付宝运营架构中柔性事务"></a>支付宝运营架构中柔性事务</h2><blockquote>
<ul>
<li><font color="red">柔性事务：业务活动</font><blockquote>
<p><img src="/donjote-blog/2017/08/30/transaction_tcc/1.jpg" alt="柔性事务：业务活动"></p>
</blockquote>
</li>
<li><font color="red">柔性事务：业务活动举例</font><br><img src="/donjote-blog/2017/08/30/transaction_tcc/2.jpg" alt="柔性事务：业务活动举例"></li>
<li><font color="red">柔性事务：TCC型业务服务</font><blockquote>
<p><img src="/donjote-blog/2017/08/30/transaction_tcc/3.jpg" alt="柔性事务：TCC型业务服务"></p>
</blockquote>
</li>
<li><font color="red">柔性事务：TCC服务事务协调模式</font><blockquote>
<p><img src="/donjote-blog/2017/08/30/transaction_tcc/4.jpg" alt="柔性事务：TCC服务事务协调模式"><br>&emsp;&emsp;可以看出，柔性事务（<a href="http://localhost:4000/2017/08/25/cap/#BASE" target="_blank" rel="external">遵循BASE理论</a>）是指相对于<a href="http://localhost:4000/2017/07/08/transaction/#事务的-ACID" target="_blank" rel="external">ACID刚性事务</a>而言的。</p>
</blockquote>
</li>
</ul>
<p>&emsp;&emsp;支付宝所说的柔性事务分为：两阶段型、补偿型、异步确保型、最大努力通知型几种。由于支付宝整个架构是SOA架构，因此传统单机环境下数据库的ACID事务满足了分布式环境下的业务需要，以上几种事务类似就是针对分布式环境下业务需要设定的。其中：<br>1、两阶段型：就是分布式事务两阶段提交，对应技术上的XA、JTA/JTS。这是分布式环境下事务处理的典型模式。<br>2、补偿型：TCC型事务（Try/Confirm/Cancel）可以归为补偿型。补偿型的例子，在一个长事务（long-running）中，一个由两台服务器一起参与的事务，服务器A发起事务，服务器B参与事务，B的事务需要人工参与，所以处理时间可能很长。如果按照ACID的原则，要保持事务的隔离性、一致性，服务器A中发起的事务中使用到的事务资源将会被锁定，不允许其他应用访问到事务过程中的中间结果，直到整个事务被提交或者回滚。这就造成事务A中的资源被长时间锁定，系统的可用性将不可接受。WS-BusinessActivity提供了一种基于补偿的long-running的事务处理模型。还是上面的例子，服务器A的事务如果执行顺利，那么事务A就先行提交，如果事务B也执行顺利，则事务B也提交，整个事务就算完成。但是如果事务B执行失败，事务B本身回滚，这时事务A已经被提交，所以需要执行一个补偿操作，将已经提交的事务A执行的操作作反操作，恢复到未执行前事务A的状态。这样的SAGA事务模型，是牺牲了一定的隔离性和一致性的，但是提高了long-running事务的可用性。例子来源：OASIS的WS-BusinessActivity文档<br>3、异步确保型将一些同步阻塞的事务操作变为异步的操作，避免对数据库事务的争用，典型例子是热点账户异步记账、批量记账的处理。<br>4、最大努力型PPT中提到的例子交易的消息通知（例如商户交易结果通知重试、补单重试）</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p> <a href="https://wenku.baidu.com/view/be946bec0975f46527d3e104.html" target="_blank" rel="external">大规模SOA系统中的分布事务处事</a><br> <a href="https://wenku.baidu.com/view/d1bbd25877232f60ddcca1d9.html" target="_blank" rel="external">支付宝架构与技术</a></p>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/08/24/grpc_service/">gRPC服务方法的定义</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/08/24/grpc_service/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-08-23T16:00:00.000Z" itemprop="datePublished">2017-08-24</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/RPC/">RPC</a>, <a class="article-tag-link" href="/tags/gRPC/">gRPC</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="服务定义"><a href="#服务定义" class="headerlink" title="服务定义"></a>服务定义</h2><blockquote>
<p>向其它的RPC服务一样，GPRC的基础是服务的定义。服务定义远程调用方法的名称、传入参数和返回参数。GRPC默认使用 Protobuf描述服务</p>
<hr>
<p>GRPC一共定义4种服务方法：<br>1、一元RPC(Unary RPCs )：这是最简单的定义，客户端发送一个请求，服务端返回一个结果<br>2、服务器流RPC（Server streaming RPCs）：客户端发送一个请求，服务端返回一个流给客户端，客户从流中读取一系列消息，直到读取所有小心<br>3、客户端流RPC(Client streaming RPCs )：客户端通过流向服务端发送一系列消息，然后等待服务端读取完数据并返回处理结果<br>4、双向流RPC(Bidirectional streaming RPCs)：客户端和服务端都可以独立向对方发送或接受一系列的消息。客户端和服务端读写的顺序是任意。   </p>
<hr>
<p>以上的服务方法定义在proto文件，如下:   </p>
<pre><code>  syntax = &quot;proto3&quot;;

  option java_multiple_files = true;
  option java_package = &quot;io.github.donjote.hello&quot;;
  option java_outer_classname = &quot;HelloProto&quot;;

  service Hello {
  // A Unary RPC.
  rpc simpleRpc(Simple) returns (SimpleFeature) {}

  // A server-to-client streaming RPC.
  rpc server2ClientRpc(SimpleList) returns (stream SimpleFeature) {}

  // A client-to-server streaming RPC.
  rpc client2ServerRpc(stream Simple) returns (SimpleSummary) {}

  // A Bidirectional streaming RPC.
  rpc bindirectionalStreamRpc(stream Simple) returns (stream Simple) {}
}

message Simple {
  int32 num = 1;
  string name = 2;
}

message SimpleList {
  repeated Simple simpleList = 1;
}

message SimpleFeature {
  string name = 1;
  Simple location = 2;
}

message SimpleSummary {
  int32 feature_count = 2;
}

// 测试类
message SimpleFeatureDatabase {
  repeated SimpleFeature feature = 1;
}
</code></pre></blockquote>
<h2 id="同步RPC和异步RPC"><a href="#同步RPC和异步RPC" class="headerlink" title="同步RPC和异步RPC"></a>同步RPC和异步RPC</h2><blockquote>
<p>GRPC 同时支持同步RPC和异步RPC。<br>同步RPC调用服务方法只支持流RPC（Server streaming RPCs）和一元RPC(Unary RPCs )。异步RPC调用服务方法支持4种方法。</p>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/08/23/grpc_introdution/">gRPC入门简介</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/08/23/grpc_introdution/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-08-22T16:00:00.000Z" itemprop="datePublished">2017-08-23</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/RPC/">RPC</a>, <a class="article-tag-link" href="/tags/gRPC/">gRPC</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p><a href="https://grpc.io/" target="_blank" rel="external">gRPC</a>是Go实现的：一个高性能，开源，将移动和HTTP/2放在首位通用的RPC框架， 有关详细信息，请参阅<a href="https://grpc.io/docs/" target="_blank" rel="external">gRPC快速入门指南</a>。</p>
<h3 id="gRPC概念图"><a href="#gRPC概念图" class="headerlink" title="gRPC概念图"></a>gRPC概念图</h3><p><img src="/donjote-blog/2017/08/23/grpc_introdution/1.png" alt="gRPC概念图"></p>
</blockquote>
<h2 id="gRPC特性"><a href="#gRPC特性" class="headerlink" title="gRPC特性"></a>gRPC特性</h2><h3 id="基于HTTP-2协议标准"><a href="#基于HTTP-2协议标准" class="headerlink" title="基于HTTP/2协议标准"></a>基于HTTP/2协议标准</h3><blockquote>
<h4 id="什么是HTTP-2协议"><a href="#什么是HTTP-2协议" class="headerlink" title="什么是HTTP/2协议"></a>什么是HTTP/2协议</h4><p>HTTP 2.0即超文本传输协议 2.0，是下一代HTTP协议（基于二进制的传输协议）。是由互联网工程任务组（IETF）的Bis (httpbis)工作小组进行开发。</p>
<h4 id="HTTP-2的优点"><a href="#HTTP-2的优点" class="headerlink" title="HTTP/2的优点"></a>HTTP/2的优点</h4><ul>
<li>http2减少了网络往返传输的数量，并且用多路复用和快速丢弃不需要的流的办法来完全避免head of line blocking(线头阻塞)的困扰，降低延迟并提高安全性。</li>
<li>支持大量并行流，所以即使网站的数据分发在各处也不是问题。</li>
<li>合理利用流的优先级，可以让客户端尽可能优先收到更重要的数据。</li>
</ul>
</blockquote>
<h3 id="gRPC基于强大的IDL-Interface-description-language"><a href="#gRPC基于强大的IDL-Interface-description-language" class="headerlink" title="gRPC基于强大的IDL(Interface description language)"></a>gRPC基于强大的IDL(Interface description language)</h3><blockquote>
<p>gRPC基于ProtoBuf(Protocol Buffers)定义接口规范。</p>
<h4 id="ProtoBuf是什么？"><a href="#ProtoBuf是什么？" class="headerlink" title="ProtoBuf是什么？"></a>ProtoBuf是什么？</h4><p>Protocol Buffers 是google提供的一种轻便、高效、简单的数据存储语言，可以用于结构化、序列化数据。</p>
<h4 id="为什么要使用ProtoBuf？"><a href="#为什么要使用ProtoBuf？" class="headerlink" title="为什么要使用ProtoBuf？"></a>为什么要使用ProtoBuf？</h4><ul>
<li>适合应用场景：它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化数据结构。</li>
<li>支持语言众多（提供了完善的API）:Proto2提供了 C++、Java、Python 三种语言的 API。目前语言版本Proto3提供了更多的语言支持,包括 C++ 、C# 、GO 、JAVA、PYTHON。</li>
<li>易学易懂：protoBuf语法非常简单，掌握非常容易，便于读写。</li>
</ul>
</blockquote>
<h3 id="gRPC支持众多开发语言"><a href="#gRPC支持众多开发语言" class="headerlink" title="gRPC支持众多开发语言"></a>gRPC支持众多开发语言</h3><blockquote>
<p>GRPC目前支持的开发语言已达到了10种：C, C++, Java, Go, Node.js, Python, Ruby, Objective-C, PHP and C#。并且GRPC框架已在GitHub上开源。<br> GitHub地址：<a href="https://github.com/grpc" target="_blank" rel="external">https://github.com/grpc</a><br> JAVA GitHub地址：<a href="https://github.com/grpc/grpc-java" target="_blank" rel="external">https://github.com/grpc/grpc-java</a></p>
</blockquote>
<h2 id="为什么使用gRPC"><a href="#为什么使用gRPC" class="headerlink" title="为什么使用gRPC"></a>为什么使用gRPC</h2><blockquote>
<ul>
<li>它使用HTTP2协议，可复用链接，更充分的利用底层TCP传输协议，并以数据流的方式传输，比其他基于HTTP1的传输速率更高。</li>
<li>它基于Proto Buffer语言,对传输数据进行压缩、系列化和结构化，易于客户端与服务端数据的读写操作，并使数据量传输变得更小、传输效率更高。</li>
<li>基于以上及其他特性，使得基于GRPC的客户端和服务端更高效的利用流和链接，从而有助于节省宽带流量、降低链接次数、提高CUP使用效率和电池的使用寿命。</li>
</ul>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/07/11/etcd_2/">使用docker-machine搭建etcd集群</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/07/11/etcd_2/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-07-10T16:00:00.000Z" itemprop="datePublished">2017-07-11</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/etcd/">etcd</a>, <a class="article-tag-link" href="/tags/微服务/">微服务</a>, <a class="article-tag-link" href="/tags/服务发现/">服务发现</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="创建Etcd集群"><a href="#创建Etcd集群" class="headerlink" title="创建Etcd集群"></a>创建Etcd集群</h2><blockquote>
<p>  $ curl -sSL <a href="https://raw.githubusercontent.com/donjote/shell-etcd/master/etcd.sh" target="_blank" rel="external">https://raw.githubusercontent.com/donjote/shell-etcd/master/etcd.sh</a> | sh -</p>
</blockquote>
<h3 id="集群验证"><a href="#集群验证" class="headerlink" title="集群验证"></a>集群验证</h3><blockquote>
<ol>
<li>验证集群members。在集群中的每台机器上查看members，得出的结果应该是相同的   </li>
</ol>
<pre><code>$ curl -L http://$(docker-machine ip etcd-node-0):2379/v2/members
$ curl -L http://$(docker-machine ip etcd-node-1):2379/v2/members
$ curl -L http://$(docker-machine ip etcd-node-2):2379/v2/members
{&quot;members&quot;:[{&quot;id&quot;:&quot;305750b374006637&quot;,&quot;name&quot;:&quot;etcd-node-2&quot;,&quot;peerURLs&quot;:[&quot;http://192.168.99.102:2380&quot;],&quot;clientURLs&quot;:[&quot;http://192.168.99.102:2379&quot;]},{&quot;id&quot;:&quot;c7177c3c5ff3b1b4&quot;,&quot;name&quot;:&quot;etcd-node-0&quot;,&quot;peerURLs&quot;:[&quot;http://192.168.99.100:2380&quot;],&quot;clientURLs&quot;:[&quot;http://192.168.99.100:2379&quot;]},{&quot;id&quot;:&quot;d5673e1f00b32e05&quot;,&quot;name&quot;:&quot;etcd-node-1&quot;,&quot;peerURLs&quot;:[&quot;http://192.168.99.101:2380&quot;],&quot;clientURLs&quot;:[&quot;http://192.168.99.101:2379&quot;]}]}
</code></pre><p>2.某台机器上添加数据，其他机器上查看数据，得出的结果应该是相同的</p>
<pre><code>$ curl -L http://$(docker-machine ip etcd-node-0):2379/v2/keys/message -XPUT -d value=&quot;Hello World&quot;
{&quot;action&quot;:&quot;set&quot;,&quot;node&quot;:{&quot;key&quot;:&quot;/message&quot;,&quot;value&quot;:&quot;Hello World&quot;,&quot;modifiedIndex&quot;:9,&quot;createdIndex&quot;:9}}
$ curl -L http://$(docker-machine ip etcd-node-1):2379/v2/keys/message
{&quot;action&quot;:&quot;set&quot;,&quot;node&quot;:{&quot;key&quot;:&quot;/message&quot;,&quot;value&quot;:&quot;Hello World&quot;,&quot;modifiedIndex&quot;:9,&quot;createdIndex&quot;:9}}
$ curl -L http://$(docker-machine ip etcd-node-1):2379/v2/keys/message
{&quot;action&quot;:&quot;set&quot;,&quot;node&quot;:{&quot;key&quot;:&quot;/message&quot;,&quot;value&quot;:&quot;Hello World&quot;,&quot;modifiedIndex&quot;:9,&quot;createdIndex&quot;:9}}
</code></pre></blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/07/11/etcd_1/">etcd概述和使用场景</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/07/11/etcd_1/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-07-10T16:00:00.000Z" itemprop="datePublished">2017-07-11</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/etcd/">etcd</a>, <a class="article-tag-link" href="/tags/微服务/">微服务</a>, <a class="article-tag-link" href="/tags/服务发现/">服务发现</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>etcd是一个高可用的键值存储系统，主要用于共享配置和服务发现。etcd是由CoreOS开发并维护的，灵感来自于 ZooKeeper 和 Doozer，它使用Go语言编写，并通过Raft一致性算法处理日志复制以保证强一致性。Raft是一个新的一致性算法，适用于分布式系统的日志复制，Raft通过选举的方式来实现一致性。Google的容器集群管理系统Kubernetes、开源PaaS平台Cloud Foundry和CoreOS的Fleet都广泛使用了etcd。在分布式系统中，如何管理节点间的状态一直是一个难题，etcd像是专门为集群环境的服务发现和注册而设计，它提供了数据TTL失效、数据改变监视、多值、目录监听、分布式锁原子操作等功能，可以方便的跟踪并管理集群节点的状态。</p>
<hr>
<p>etcd的特性如下：</p>
<ul>
<li>简单: 支持curl方式的用户API（HTTP+JSON）</li>
<li>安全: 可选的SSL客户端证书认证</li>
<li>快速: 单实例每秒 1000 次写操作</li>
<li>可靠: 使用Raft保证一致性</li>
</ul>
</blockquote>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h3 id="场景一：服务发现（Service-Discovery）"><a href="#场景一：服务发现（Service-Discovery）" class="headerlink" title="场景一：服务发现（Service Discovery）"></a>场景一：服务发现（Service Discovery）</h3><blockquote>
<p>服务发现要解决的也是分布式系统中最常见的问题之一，即在同一个分布式集群中的进程或服务，要如何才能找到对方并建立连接。本质上来说，服务发现就是想要了解集群中是否有进程在监听udp或tcp端口，并且通过名字就可以查找和连接。要解决服务发现的问题，需要有下面三大支柱，缺一不可。</p>
<hr>
<p>一个强一致性、高可用的服务存储目录。基于Raft算法的etcd天生就是这样一个强一致性高可用的服务存储目录。</p>
<hr>
<p>一种注册服务和监控服务健康状态的机制。用户可以在etcd中注册服务，并且对注册的服务设置key TTL，定时保持服务的心跳以达到监控健康状态的效果。</p>
<hr>
<p>一种查找和连接服务的机制。通过在etcd指定的主题下注册的服务也能在对应的主题下查找到。为了确保连接，我们可以在每个服务机器上都部署一个Proxy模式的etcd，这样就可以确保能访问etcd集群的服务都能互相连接。<br><img src="/donjote-blog/2017/07/11/etcd_1/1.jpg" alt="服务发现示意图"><br>图一 服务发现示意图</p>
<hr>
<p>下面我们来看服务发现对应的具体场景。</p>
<hr>
<p>微服务协同工作架构中，服务动态添加。随着Docker容器的流行，多种微服务共同协作，构成一个相对功能强大的架构的案例越来越多。透明化的动态添加这些服务的需求也日益强烈。通过服务发现机制，在etcd中注册某个服务名字的目录，在该目录下存储可用的服务节点的IP。在使用服务的过程中，只要从服务目录下查找可用的服务节点去使用即可。<br><img src="/donjote-blog/2017/07/11/etcd_1/2.jpg" alt="服务协同工作"><br>图二 微服务协同工作</p>
<hr>
<p>PaaS平台中应用多实例与实例故障重启透明化。PaaS平台中的应用一般都有多个实例，通过域名，不仅可以透明的对这多个实例进行访问，而且还可以做到负载均衡。但是应用的某个实例随时都有可能故障重启，这时就需要动态的配置域名解析（路由）中的信息。通过etcd的服务发现功能就可以轻松解决这个动态配置的问题。<br><img src="/donjote-blog/2017/07/11/etcd_1/3.jpg" alt="多平台多实例透明化"><br>图三 多平台多实例透明化</p>
</blockquote>
<h3 id="场景二：消息发布与订阅"><a href="#场景二：消息发布与订阅" class="headerlink" title="场景二：消息发布与订阅"></a>场景二：消息发布与订阅</h3><blockquote>
<p>在分布式系统中，最适用的一种组件间通信方式就是消息发布与订阅。即构建一个配置共享中心，数据提供者在这个配置中心发布消息，而消息使用者则订阅他们关心的主题，一旦主题有消息发布，就会实时通知订阅者。通过这种方式可以做到分布式系统配置的集中式管理与动态更新。</p>
<hr>
<p>应用中用到的一些配置信息放到etcd上进行集中管理。这类场景的使用方式通常是这样：应用在启动的时候主动从etcd获取一次配置信息，同时，在etcd节点上注册一个Watcher并等待，以后每次配置有更新的时候，etcd都会实时通知订阅者，以此达到获取最新配置信息的目的。</p>
<hr>
<p>分布式搜索服务中，索引的元信息和服务器集群机器的节点状态存放在etcd中，供各个客户端订阅使用。使用etcd的key TTL功能可以确保机器状态是实时更新的。</p>
<hr>
<p>分布式日志收集系统。这个系统的核心工作是收集分布在不同机器的日志。收集器通常是按照应用（或主题）来分配收集任务单元，因此可以在etcd上创建一个以应用（主题）命名的目录P，并将这个应用（主题相关）的所有机器ip，以子目录的形式存储到目录P上，然后设置一个etcd递归的Watcher，递归式的监控应用（主题）目录下所有信息的变动。这样就实现了机器IP（消息）变动的时候，能够实时通知到收集器调整任务分配。</p>
<hr>
<p>系统中信息需要动态自动获取与人工干预修改信息请求内容的情况。通常是暴露出接口，例如JMX接口，来获取一些运行时的信息。引入etcd之后，就不用自己实现一套方案了，只要将这些信息存放到指定的etcd目录中即可，etcd的这些目录就可以通过HTTP的接口在外部访问。<br><img src="/donjote-blog/2017/07/11/etcd_1/4.jpg" alt="消息发布和订阅"><br>图四 消息发布和订阅</p>
</blockquote>
<h3 id="场景三：负载均衡"><a href="#场景三：负载均衡" class="headerlink" title="场景三：负载均衡"></a>场景三：负载均衡</h3><blockquote>
<p>在场景一中也提到了负载均衡，本文所指的负载均衡均为软负载均衡。分布式系统中，为了保证服务的高可用以及数据的一致性，通常都会把数据和服务部署多份，以此达到对等服务，即使其中的某一个服务失效了，也不影响使用。由此带来的坏处是数据写入性能下降，而好处则是数据访问时的负载均衡。因为每个对等服务节点上都存有完整的数据，所以用户的访问流量就可以分流到不同的机器上。</p>
<hr>
<p>etcd本身分布式架构存储的信息访问支持负载均衡。etcd集群化以后，每个etcd的核心节点都可以处理用户的请求。所以，把数据量小但是访问频繁的消息数据直接存储到etcd中也是个不错的选择，如业务系统中常用的二级代码表（在表中存储代码，在etcd中存储代码所代表的具体含义，业务系统调用查表的过程，就需要查找表中代码的含义）。</p>
<hr>
<p>利用etcd维护一个负载均衡节点表。etcd可以监控一个集群中多个节点的状态，当有一个请求发过来后，可以轮询式的把请求转发给存活着的多个状态。类似KafkaMQ，通过ZooKeeper来维护生产者和消费者的负载均衡。同样也可以用etcd来做ZooKeeper的工作。<br><img src="/donjote-blog/2017/07/11/etcd_1/5.jpg" alt="负载均衡"><br>图五 负载均衡</p>
</blockquote>
<h3 id="场景四：分布式通知与协调"><a href="#场景四：分布式通知与协调" class="headerlink" title="场景四：分布式通知与协调"></a>场景四：分布式通知与协调</h3><blockquote>
<p>这里说到的分布式通知与协调，与消息发布和订阅有些相似。都用到了etcd中的Watcher机制，通过注册与异步通知机制，实现分布式环境下不同系统之间的通知与协调，从而对数据变更做到实时处理。实现方式通常是这样：不同系统都在etcd上对同一个目录进行注册，同时设置Watcher观测该目录的变化（如果对子目录的变化也有需要，可以设置递归模式），当某个系统更新了etcd的目录，那么设置了Watcher的系统就会收到通知，并作出相应处理。</p>
<hr>
<p>通过etcd进行低耦合的心跳检测。检测系统和被检测系统通过etcd上某个目录关联而非直接关联起来，这样可以大大减少系统的耦合性。</p>
<hr>
<p>通过etcd完成系统调度。某系统有控制台和推送系统两部分组成，控制台的职责是控制推送系统进行相应的推送工作。管理人员在控制台作的一些操作，实际上是修改了etcd上某些目录节点的状态，而etcd就把这些变化通知给注册了Watcher的推送系统客户端，推送系统再作出相应的推送任务。</p>
<hr>
<p>通过etcd完成工作汇报。大部分类似的任务分发系统，子任务启动后，到etcd来注册一个临时工作目录，并且定时将自己的进度进行汇报（将进度写入到这个临时目录），这样任务管理者就能够实时知道任务进度。<br><img src="/donjote-blog/2017/07/11/etcd_1/6.jpg" alt="分布式协同工作"><br>图六 分布式协同工作</p>
</blockquote>
<h3 id="场景五：分布式锁"><a href="#场景五：分布式锁" class="headerlink" title="场景五：分布式锁"></a>场景五：分布式锁</h3><blockquote>
<p>因为etcd使用Raft算法保持了数据的强一致性，某次操作存储到集群中的值必然是全局一致的，所以很容易实现分布式锁。锁服务有两种使用方式，一是保持独占，二是控制时序。</p>
<hr>
<p>保持独占即所有获取锁的用户最终只有一个可以得到。etcd为此提供了一套实现分布式锁原子操作CAS（CompareAndSwap）的API。通过设置prevExist值，可以保证在多个节点同时去创建某个目录时，只有一个成功。而创建成功的用户就可以认为是获得了锁。</p>
<hr>
<p>控制时序，即所有想要获得锁的用户都会被安排执行，但是获得锁的顺序也是全局唯一的，同时决定了执行顺序。etcd为此也提供了一套API（自动创建有序键），对一个目录建值时指定为POST动作，这样etcd会自动在目录下生成一个当前最大的值为键，存储这个新的值（客户端编号）。同时还可以使用API按顺序列出所有当前目录下的键值。此时这些键的值就是客户端的时序，而这些键中存储的值可以是代表客户端的编号。<br><img src="/donjote-blog/2017/07/11/etcd_1/7.jpg" alt="分布式锁"><br>图七 分布式锁</p>
</blockquote>
<h3 id="场景六：分布式队列"><a href="#场景六：分布式队列" class="headerlink" title="场景六：分布式队列"></a>场景六：分布式队列</h3><blockquote>
<p>分布式队列的常规用法与场景五中所描述的分布式锁的控制时序用法类似，即创建一个先进先出的队列，保证顺序。</p>
<hr>
<p>另一种比较有意思的实现是在保证队列达到某个条件时再统一按顺序执行。这种方法的实现可以在/queue这个目录中另外建立一个/queue/condition节点。</p>
<hr>
<p>condition可以表示队列大小。比如一个大的任务需要很多小任务就绪的情况下才能执行，每次有一个小任务就绪，就给这个condition数字加1，直到达到大任务规定的数字，再开始执行队列里的一系列小任务，最终执行大任务。<br>condition可以表示某个任务在不在队列。这个任务可以是所有排序任务的首个执行程序，也可以是拓扑结构中没有依赖的点。通常，必须执行这些任务后才能执行队列中的其他任务。<br><img src="/donjote-blog/2017/07/11/etcd_1/8.jpg" alt="分布式队列"><br>图八 分布式队列</p>
</blockquote>
<h3 id="场景七：集群监控与Leader竞选"><a href="#场景七：集群监控与Leader竞选" class="headerlink" title="场景七：集群监控与Leader竞选"></a>场景七：集群监控与Leader竞选</h3><blockquote>
<p>通过etcd来进行监控实现起来非常简单并且实时性强。</p>
<hr>
<p>前面几个场景已经提到Watcher机制，当某个节点消失或有变动时，Watcher会第一时间发现并告知用户。<br>节点可以设置TTL key，比如每隔30s发送一次心跳使代表该机器存活的节点继续存在，否则节点消失。<br>这样就可以第一时间检测到各节点的健康状态，以完成集群的监控要求。</p>
<hr>
<p>另外，使用分布式锁，可以完成Leader竞选。这种场景通常是一些长时间CPU计算或者使用IO操作的机器，只需要竞选出的Leader计算或处理一次，就可以把结果复制给其他的Follower。从而避免重复劳动，节省计算资源。</p>
<hr>
<p>这个的经典场景是搜索系统中建立全量索引。如果每个机器都进行一遍索引的建立，不但耗时而且建立索引的一致性不能保证。通过在etcd的CAS机制同时创建一个节点，创建成功的机器作为Leader，进行索引计算，然后把计算结果分发到其它节点。<br><img src="/donjote-blog/2017/07/11/etcd_1/9.jpg" alt="Leader竞选"><br>图九 Leader竞选</p>
</blockquote>
<h2 id="为什么用etcd而不用ZooKeeper？"><a href="#为什么用etcd而不用ZooKeeper？" class="headerlink" title="为什么用etcd而不用ZooKeeper？"></a>为什么用etcd而不用ZooKeeper？</h2><blockquote>
<p>etcd实现的这些功能，ZooKeeper都能实现。那么为什么要用etcd而非直接使用ZooKeeper呢？</p>
<hr>
<p>相较之下，ZooKeeper有如下缺点：</p>
<ol>
<li>复杂。ZooKeeper的部署维护复杂，管理员需要掌握一系列的知识和技能；而Paxos强一致性算法也是素来以复杂难懂而闻名于世；另外，ZooKeeper的使用也比较复杂，需要安装客户端，官方只提供了Java和C两种语言的接口。</li>
<li>Java编写。这里不是对Java有偏见，而是Java本身就偏向于重型应用，它会引入大量的依赖。而运维人员则普遍希望保持强一致、高可用的机器集群尽可能简单，维护起来也不易出错。]</li>
<li>发展缓慢。Apache基金会项目特有的“Apache Way”在开源界饱受争议，其中一大原因就是由于基金会庞大的结构以及松散的管理导致项目发展缓慢。</li>
</ol>
<hr>
<p>而etcd作为一个后起之秀，其优点也很明显。</p>
<ol>
<li>简单。使用Go语言编写部署简单；使用HTTP作为接口使用简单；使用Raft算法保证强一致性让用户易于理解。</li>
<li>数据持久化。etcd默认数据一更新就进行持久化。</li>
<li>安全。etcd支持SSL客户端安全认证。</li>
</ol>
<hr>
<p>最后，etcd作为一个年轻的项目，真正告诉迭代和开发中，这既是一个优点，也是一个缺点。优点是它的未来具有无限的可能性，缺点是无法得到大项目长时间使用的检验。然而，目前CoreOS、Kubernetes和CloudFoundry等知名项目均在生产环境中使用了etcd，所以总的来说，etcd值得你去尝试。</p>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/07/08/transaction/">事务</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/07/08/transaction/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-07-07T16:00:00.000Z" itemprop="datePublished">2017-07-08</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/事务/">事务</a>, <a class="article-tag-link" href="/tags/架构/">架构</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h2><blockquote>
<p>事务(Transaction)是访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。事务通常由高级数据库操纵语言或编程语言（如SQL，C++或Java）书写的用户程序的执行所引起，并用形如begin transaction和end transaction语句（或函数调用）来界定。事务由事务开始(begin transaction)和事务结束(end transaction)之间执行的全体操作组成。<br>事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。<br>事务的结束有两种，当事务中的所以步骤全部成功执行时，事务提交。如果其中一个步骤失败，将发生回滚操作，撤消撤消之前到事务开始时的所以操作。</p>
</blockquote>
<h2 id="事务的-ACID"><a href="#事务的-ACID" class="headerlink" title="事务的 ACID"></a>事务的 ACID</h2><blockquote>
<p>事务具有四个特征：原子性（ Atomicity ）、一致性（ Consistency ）、隔离性（ Isolation ）和持续性（ Durability ）。这四个特性简称为 ACID 特性。</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>事务的原子性指的是，事务中包含的程序作为数据库的逻辑工作单位，它所做的对数据修改操作要么全部执行，要么完全不执行。这种特性称为原子性。<br>事务的原子性要求，如果把一个事务可看作是一个程序，它要么完整的被执行，要么完全不执行。就是说事务的操纵序列或者完全应用到数据库或者完全不影响数据库。这种特性称为原子性。    </p>
<hr>
<p>假如用户在一个事务内完成了对数据库的更新，这时所有的更新对外部世界必须是可见的，或者完全没有更新。前者称事务已提交，后者称事务撤消（或流产）。DBMS必须确保由成功提交的事务完成的所有操纵在数据库内有完全的反映，而失败的事务对数据库完全没有影响。</p>
<h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。这种特性称为事务的一致性。假如数据库的状态满足所有的完整性约束，就说该数据库是一致的。</p>
<hr>
<p>一致性处理数据库中对所有语义约束的保护。假如数据库的状态满足所有的完整性约束，就说该数据库是一致的。例如，当数据库处于一致性状态S1时，对数据库执行一个事务，在事务执行期间假定数据库的状态是不一致的，当事务执行结束时，数据库处在一致性状态S2。</p>
<h3 id="分离性"><a href="#分离性" class="headerlink" title="分离性"></a>分离性</h3><p>分离性指并发的事务是相互隔离的。即一个事务内部的操作及正在操作的数据必须封锁起来，不被其它企图进行修改的事务看到。    分离性是DBMS针对并发事务间的冲突提供的安全保证。DBMS可以通过加锁在并发执行的事务间提供不同级别的分离。假如并发交叉执行的事务没有任何控制，操纵相同的共享对象的多个并发事务的执行可能引起异常情况。</p>
<hr>
<p>DBMS可以在并发执行的事务间提供不同级别的分离。分离的级别和并发事务的吞吐量之间存在反比关系。较多事务的可分离性可能会带来较高的冲突和较多的事务流产。流产的事务要消耗资源，这些资源必须要重新被访问。因此，确保高分离级别的DBMS需要更多的开销。</p>
<h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><p>持久性意味着当系统或介质发生故障时，确保已提交事务的更新不能丢失。即一旦一个事务提交，DBMS保证它对数据库中数据的改变应该是永久性的，耐得住任何系统故障。持久性通过数据库备份和恢复来保证。  </p>
<hr>
<p>持久性意味着当系统或介质发生故障时，确保已提交事务的更新不能丢失。即对已提交事务的更新能恢复。一旦一个事务被提交，DBMS必须保证提供适当的冗余，使其耐得住系统的故障。所以，持久性主要在于DBMS的恢复性能。</p>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/07/07/idempotent/">幂等性</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/07/07/idempotent/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-07-06T16:00:00.000Z" itemprop="datePublished">2017-07-07</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/分布式架构/">分布式架构</a>, <a class="article-tag-link" href="/tags/架构/">架构</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="幂等性定义"><a href="#幂等性定义" class="headerlink" title="幂等性定义"></a>幂等性定义</h2><h3 id="数学定义"><a href="#数学定义" class="headerlink" title="数学定义"></a>数学定义</h3><blockquote>
<p>在数学里，幂等有两种主要的定义：</p>
<ul>
<li>在某二元运算下，幂等元素是指被自己重复运算(或对于函数是为复合)的结果等于它自己的元素。例如，乘法下唯一两个幂等实数为0和1。 即 s * s = s</li>
<li>某一元运算为幂等的时，其作用在任一元素两次后会和其作用一次的结果相同。例如，高斯符号便是幂等的，即f(f(x)) = f(x)。</li>
</ul>
</blockquote>
<h3 id="HTTP规范的定义"><a href="#HTTP规范的定义" class="headerlink" title="HTTP规范的定义"></a>HTTP规范的定义</h3><blockquote>
<p>在HTTP/1.1规范中幂等性的定义是：</p>
<hr>
<p>Methods can also have the property of “idempotence” in that (aside from error or expiration issues) the side-effects of N &gt; 0 identical requests is the same as for a single request.</p>
<hr>
<p>从定义上看，HTTP方法的幂等性是指一次和多次请求某一个资源应该具有同样的副作用。幂等性属于语义范畴，正如编译器只能帮助检查语法错误一样，HTTP规范也没有办法通过消息格式等语法手段来定义它，这可能是它不太受到重视的原因之一。但实际上，幂等性是分布式系统设计中十分重要的概念，而HTTP的分布式本质也决定了它在HTTP中具有重要地位。</p>
</blockquote>
<h2 id="HTTP的幂等性"><a href="#HTTP的幂等性" class="headerlink" title="HTTP的幂等性"></a>HTTP的幂等性</h2><blockquote>
<p>HTTP协议本身是一种面向资源的应用层协议，但对HTTP协议的使用实际上存在着两种不同的方式：一种是RESTful的，它把HTTP当成应用层协议，比较忠实地遵守了HTTP协议的各种规定；另一种是SOA的，它并没有完全把HTTP当成应用层协议，而是把HTTP协议作为了传输层协议，然后在HTTP之上建立了自己的应用层协议。本文所讨论的HTTP幂等性主要针对RESTful风格的，不过正如上一节所看到的那样，幂等性并不属于特定的协议，它是分布式系统的一种特性；所以，不论是SOA还是RESTful的Web API设计都应该考虑幂等性。下面将介绍HTTP GET、DELETE、PUT、POST四种主要方法的语义和幂等性。</p>
<hr>
<p>HTTP GET方法用于获取资源，不应有副作用，所以是幂等的。</p>
<hr>
<p>HTTP DELETE方法用于删除资源，有副作用，但它应该满足幂等性。</p>
<hr>
<p>比较容易混淆的是HTTP POST和PUT。POST和PUT的区别容易被简单地误认为“POST表示创建资源，PUT表示更新资源”；而实际上，二者均可用于创建资源，更为本质的差别是在幂等性方面。在HTTP规范中对POST和PUT是这样定义的：</p>
<hr>
<p>The POST method is used to request that the origin server accept the entity enclosed in the request as a new subordinate of the resource identified by the Request-URI in the Request-Line …… If a resource has been created on the origin server, the response SHOULD be 201 (Created) and contain an entity which describes the status of the request and refers to the new resource, and a Location header.</p>
<hr>
<p>The PUT method requests that the enclosed entity be stored under the supplied Request-URI. If the Request-URI refers to an already existing resource, the enclosed entity SHOULD be considered as a modified version of the one residing on the origin server. If the Request-URI does not point to an existing resource, and that URI is capable of being defined as a new resource by the requesting user agent, the origin server can create the resource with that URI.</p>
<hr>
<p>POST所对应的URI并非创建的资源本身，而是资源的接收者。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，POST方法不具备幂等性。而PUT所对应的URI是要创建或更新的资源本身。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，PUT方法具有幂等性。</p>
</blockquote>
<h2 id="幂等的实现方案"><a href="#幂等的实现方案" class="headerlink" title="幂等的实现方案"></a>幂等的实现方案</h2><h3 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h3><blockquote>
<p>查询一次和查询多次，在数据不变的情况下，查询结果是一样的。select是天然的幂等操作</p>
</blockquote>
<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><blockquote>
<p>删除操作也是幂等的，删除一次和多次删除都是把数据删除。(注意可能返回结果不一样，删除的数据不存在，返回0，删除的数据多条，返回结果多个)</p>
</blockquote>
<h3 id="唯一索引，防止新增脏数据"><a href="#唯一索引，防止新增脏数据" class="headerlink" title="唯一索引，防止新增脏数据"></a>唯一索引，防止新增脏数据</h3><blockquote>
<p>比如：支付宝的资金账户，支付宝也有用户账户，每个用户只能有一个资金账户，怎么防止给用户创建资金账户多个，那么给资金账户表中的用户ID加唯一索引，所以一个用户新增成功一个资金账户记录</p>
<hr>
<p><strong>要点：<br>唯一索引或唯一组合索引来防止新增数据存在脏数据（当表存在唯一索引，并发时新增报错时，再查询一次就可以了，数据应该已经存在了，返回结果即可）</strong></p>
</blockquote>
<h3 id="token机制，防止页面重复提交"><a href="#token机制，防止页面重复提交" class="headerlink" title="token机制，防止页面重复提交"></a>token机制，防止页面重复提交</h3><blockquote>
<h4 id="业务要求："><a href="#业务要求：" class="headerlink" title="业务要求："></a>业务要求：</h4><p>页面的数据只能被点击提交一次</p>
<h4 id="发生原因："><a href="#发生原因：" class="headerlink" title="发生原因："></a>发生原因：</h4><p>由于重复点击或者网络重发，或者nginx重发等情况会导致数据被重复提交</p>
<h4 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h4><p>集群环境：采用token加redis（redis单线程的，处理需要排队）<br>单JVM环境：采用token加redis或token加jvm内存</p>
<h4 id="处理流程："><a href="#处理流程：" class="headerlink" title="处理流程："></a>处理流程：</h4><ol>
<li>数据提交前要向服务的申请token，token放到redis或jvm内存，token有效时间</li>
<li>提交后后台校验token，同时删除token，生成新的token返回<h4 id="token特点："><a href="#token特点：" class="headerlink" title="token特点："></a>token特点：</h4>要申请，一次有效性，可以限流</li>
</ol>
<hr>
<p><strong>注意：<br>redis要用删除操作来判断token，删除成功代表token校验通过，如果用select+delete来校验token，存在并发问题，不建议使用</strong></p>
</blockquote>
<h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><blockquote>
<p>获取数据的时候加锁获取<br>select * from table_xxx where id=’xxx’ for update;<br>注意：id字段一定是主键或者唯一索引，不然是锁表，会死人的<br>悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，根据实际情况选用</p>
</blockquote>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><blockquote>
<p>乐观锁只是在更新数据那一刻锁表，其他时间不锁表，所以相对于悲观锁，效率更高。<br>乐观锁的实现方式多种多样可以通过version或者其他状态条件：</p>
<ol>
<li>通过版本号实现<br>update table_xxx set name=#name#,version=version+1 where version=#version#<br>如下图(来自网上)：<br><img src="/donjote-blog/2017/07/07/idempotent/1.png" alt="乐观锁"></li>
<li>通过条件限制<br>update table_xxx set avai_amount=avai_amount-#subAmount# where avai_amount-#subAmount# &gt;= 0<br>要求：quality-#subQuality# &gt;= ，这个情景适合不用版本号，只更新是做数据安全校验，适合库存模型，扣份额和回滚份额，性能更高</li>
</ol>
<hr>
<p><strong>注意：乐观锁的更新操作，最好用主键或者唯一索引来更新,这样是行锁，否则更新时会锁表，上面两个sql改成下面的两个更好<br>update table_xxx set name=#name#,version=version+1 where id=#id# and version=#version#<br>update table_xxx set avai_amount=avai_amount-#subAmount# where id=#id# and avai_amount-#subAmount# &gt;= 0</strong></p>
</blockquote>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><blockquote>
<p>还是拿插入数据的例子，如果是分布是系统，构建全局唯一索引比较困难，例如唯一性的字段没法确定，这时候可以引入分布式锁，通过第三方的系统(redis或zookeeper)，在业务系统插入数据或者更新数据，获取分布式锁，然后做操作，之后释放锁，这样其实是把多线程并发的锁的思路，引入多多个系统，也就是分布式系统中得解决思路。</p>
<hr>
<p><strong>要点：某个长流程处理过程要求不能并发执行，可以在流程执行之前根据某个标志(用户ID+后缀等)获取分布式锁，其他流程执行时获取锁就会失败，也就是同一时间该流程只能有一个能执行成功，执行完成后，释放分布式锁(分布式锁要第三方系统提供)</strong></p>
</blockquote>
<h3 id="select-insert"><a href="#select-insert" class="headerlink" title="select + insert"></a>select + insert</h3><blockquote>
<p>并发不高的后台系统，或者一些任务JOB，为了支持幂等，支持重复执行，简单的处理方法是，先查询下一些关键数据，判断是否已经执行过，在进行业务处理，就可以了</p>
<hr>
<p><strong>注意：核心高并发流程不要用这种方法</strong></p>
</blockquote>
<h3 id="状态机幂等"><a href="#状态机幂等" class="headerlink" title="状态机幂等"></a>状态机幂等</h3><blockquote>
<p>在设计单据相关的业务，或者是任务相关的业务，肯定会涉及到状态机(状态变更图)，就是业务单据上面有个状态，状态在不同的情况下会发生变更，一般情况下存在有限状态机，这时候，如果状态机已经处于下一个状态，这时候来了一个上一个状态的变更，理论上是不能够变更的，这样的话，保证了有限状态机的幂等。</p>
</blockquote>
<h3 id="对外提供接口的api如何保证幂等"><a href="#对外提供接口的api如何保证幂等" class="headerlink" title="对外提供接口的api如何保证幂等"></a>对外提供接口的api如何保证幂等</h3><blockquote>
<p>如银联提供的付款接口：需要接入商户提交付款请求时附带：source来源，seq序列号<br>source+seq在数据库里面做唯一索引，防止多次付款，(并发时，只能处理一个请求)</p>
<hr>
<p><strong>重点：<br>对外提供接口为了支持幂等调用，接口有两个字段必须传，一个是来源source，一个是来源方序列号seq，这个两个字段在提供方系统里面做联合唯一索引，这样当第三方调用时，先在本方系统里面查询一下，是否已经处理过，返回相应处理结果；没有处理过，进行相应处理，返回结果。注意，为了幂等友好，一定要先查询一下，是否处理过该笔业务，不查询直接插入业务系统，会报错，但实际已经处理了。</strong></p>
</blockquote>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><blockquote>
<p>幂等性应该是合格程序员的一个基因，在设计系统时，是首要考虑的问题，尤其是在像支付宝，银行，互联网金融公司等涉及的都是钱的系统，既要高效，数据也要准确，所以不能出现多扣款，多打款等问题，这样会很难处理，用户体验也不好</p>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/07/04/micro_services_1/">微服务简介</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/07/04/micro_services_1/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-07-03T16:00:00.000Z" itemprop="datePublished">2017-07-04</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/微服务/">微服务</a>, <a class="article-tag-link" href="/tags/架构/">架构</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="Monolithic架构"><a href="#Monolithic架构" class="headerlink" title="Monolithic架构"></a>Monolithic架构</h2><blockquote>
<p><img src="/donjote-blog/2017/07/04/micro_services_1/1.png" alt="Monolithic架构"><br>Monolithic比较适合小项目</p>
<h3 id="Monolithic架构优点"><a href="#Monolithic架构优点" class="headerlink" title="Monolithic架构优点"></a>Monolithic架构优点</h3><ul>
<li>开发简单直接，集中式管理, 基本不会重复开发</li>
<li>功能都在本地，没有分布式的管理开销和调用开销。<h3 id="Monolithic架构缺点"><a href="#Monolithic架构缺点" class="headerlink" title="Monolithic架构缺点"></a>Monolithic架构缺点</h3>它的缺点也非常明显，特别对于互联网公司来说（不一一列举了）：</li>
<li>开发效率低：所有的开发在一个项目改代码，递交代码相互等待，代码冲突不断</li>
<li>代码维护难：代码功能耦合在一起，新人不知道何从下手</li>
<li>部署不灵活：构建时间长，任何小修改必须重新构建整个项目，这个过程往往很长</li>
<li>稳定性不高：一个微不足道的小问题，可以导致整个应用挂掉</li>
<li>扩展性不够：无法满足高并发情况下的业务需求</li>
</ul>
</blockquote>
<h2 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h2><h3 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h3><blockquote>
<p>相对于单体（Monolithic）应用而言，微服务是采用一组服务的方式来构建一个应用，服务独立部署在不同的进程中，不同服务通过一些轻量级交互机制来通信，例如 RPC、HTTP 等,服务可独立扩展伸缩，每个服务定义了明确的边界，不同的服务甚至可以采用不同的编程语言来实现，由独立的团队来维护。</p>
</blockquote>
<h3 id="微服务的价值"><a href="#微服务的价值" class="headerlink" title="微服务的价值"></a>微服务的价值</h3><blockquote>
<ul>
<li>首先，在功能不变的情况下，应用被分解为多个可管理的服务，每个服务开发、运维变得简单。</li>
<li>其次，每个微服务独立部署，开发者不在需要协调其他服务部署对本服务的影响，这可以加快部署精度。</li>
<li>最后，每个服务可以自行决定自己的容量。</li>
</ul>
<hr>
<p>虽然对于一些简单的、规模有限的应用而言，单体架构仍然是有意义的。微服务是应用开发和部署的一个不同的方法。它非常适合许多现代的云应用对于敏捷性、扩展规模和可靠性的要求。一个微服务应用被分解成独立的部件，被称为“微服务”。“微服务”协同工作，以便提供应用的整体功能。“微服务”这一术语强调一个事实，那就是应用应该是由足够小的服务所组成，以便真正体现独立性，使得每个微服务实现单一的功能。此外，每个微服务都有明确的合同（API合同）——通常是RESTful 的——以便其他微服务能够与之进行交流和分享数据。微服务也必须能够彼此独立地进行版本更新。这种松耦合正是对一个应用实现快速而可靠地演化的支撑。下图显示了一个单体应用是如何被分解为不同的微服务的。<br><img src="/donjote-blog/2017/07/04/micro_services_1/2.png" alt="微服务架构"></p>
<h3 id="微服务的特点"><a href="#微服务的特点" class="headerlink" title="微服务的特点"></a>微服务的特点</h3><ul>
<li>小, 且专注于做⼀件事情</li>
<li>进程独立</li>
<li>轻量级的通信机制</li>
<li>松耦合</li>
<li>独立部署</li>
</ul>
<hr>
<p><strong>领域驱动设计：</strong> 应用程序功能分解可以通过Eric Evans在<a href="http://www.jdon.com/ddd.html" target="_blank" rel="external">《领域驱动设计》</a>中明确定义的规则实现；每个团队负责与一个领域或业务功能相关的全部开发；团队拥有全系列的开发人员，具备用户界面、业务逻辑和持久化存储等方面的开发技能；<br><strong>单一职责原则：</strong> 每个服务应该负责该功能的一个单独的部分，这是<a href="http://www.cnblogs.com/shanyou/archive/2009/09/21/1570716.html" target="_blank" rel="external">面向对象设计的SOLID原则</a>原则之一；<br><strong>明确发布接口：</strong> 每个服务都会发布一个定义明确的接口，而且保持不变；服务消费者只关心接口，而对于被消费的服务没有任何运行依赖；<br><strong>独立部署、升级、扩展和替换：</strong> 每个服务都可以单独部署及重新部署而不影响整个系统。这使得服务很容易升级，每个服务都可以沿着<a href="https://pan.baidu.com/s/1qYpzBPE" target="_blank" rel="external">《架构即未来》</a>一书定义的<a href="http://www.jianshu.com/p/d08d0c14810f" target="_blank" rel="external">AKF扩展立方体</a>的X轴和Z轴进行扩展；<br><strong>可以异构/采用多种语言：</strong>　每个服务的实现细节都与其它服务无关，这使得服务之间能够解耦，团队可以针对每个服务选择最合适的开发语言、持久化存储、工具和方法；<br><strong>轻量级通信：</strong>　服务通信使用轻量级的通信协议，例如，同步的REST，异步的AMQP、STOMP、MQTT等。</p>
<hr>
<p>微服务架构的思想本质跟互联网的思想是一致的。它的组件对外发布的服务视同HTTP协议，采用HTTP Rest API的方式来进行。很多开放平台的API服务，基本都采用了Http API的方式进行服务的发布和管理。</p>
</blockquote>
<h3 id="微服务优点"><a href="#微服务优点" class="headerlink" title="微服务优点"></a>微服务优点</h3><blockquote>
<ul>
<li>每个微服务都很小，这样能聚焦一个指定的业务功能或业务需求。</li>
<li>微服务能够被小团队单独开发，这个小团队是2到5人的开发人员组成。</li>
<li>微服务是松耦合的，是有功能意义的服务，无论是在开发阶段或部署阶段都是独立的。</li>
<li>微服务能使用不同的语言开发。</li>
<li>微服务允许容易且灵活的方式集成自动部署，通过持续集成工具，如Jenkins, bamboo 。</li>
<li>一个团队的新成员能够更快投入生产。</li>
<li>微服务易于被一个开发人员理解，修改和维护，这样小团队能够更关注自己的工作成果。无需通过合作才能体现价值。</li>
<li>微服务允许你利用融合最新技术。</li>
<li>微服务只是业务逻辑的代码，不会和HTML,CSS 或其他界面组件混合。</li>
<li>微服务能够即时被要求扩展。</li>
<li>微服务能部署中低端配置的服务器上。</li>
<li>易于和第三方集成。</li>
<li>每个微服务都有自己的存储能力，可以有自己的数据库。也可以有统一数据库。</li>
</ul>
</blockquote>
<h3 id="微服务架构的缺点"><a href="#微服务架构的缺点" class="headerlink" title="微服务架构的缺点"></a>微服务架构的缺点</h3><blockquote>
<ul>
<li>微服务架构可能带来过多的操作。</li>
<li>需要DevOps技巧 (<a href="http://en.wikipedia.org/wiki/DevOps" target="_blank" rel="external">http://en.wikipedia.org/wiki/DevOps</a>).</li>
<li>可能双倍的努力。</li>
<li>分布式系统可能复杂难以管理。</li>
<li>因为分布部署跟踪问题难。</li>
<li>服务数量增加，管理复杂性增加。</li>
</ul>
</blockquote>
<h3 id="常见的微服务组件"><a href="#常见的微服务组件" class="headerlink" title="常见的微服务组件"></a>常见的微服务组件</h3><blockquote>
<ul>
<li>服务注册:服务提供方将自己调用地址注册到服务注册中心，让服务调用方能够方便地找到自己。</li>
<li>服务发现:服务调用方从服务注册中心找到自己需要调用的服务的地址。</li>
<li>负载均衡:服务提供方一般以多实例的形式提供服务，负载均衡功能能够让服务调用方连接到合适的服务节点。并且，节点选择的工作对服务调用方来说是透明的。</li>
<li>服务网关:服务网关是服务调用的唯一入口，可以在这个组件是实现用户鉴权、动态路由、灰度发布、A/B测试、负载限流等功能。</li>
<li>配置中心:将本地化的配置信息（properties,<br>xml, yaml等）注册到配置中心，实现程序包在开发、测试、生产环境的无差别性，方便程序包的迁移。</li>
<li>API管理:以方便的形式编写及更新API文档，并以方便的形式供调用者查看和测试。</li>
<li>集成框架:微服务组件都以职责单一的程序包对外提供服务，集成框架以配置的形式将所有微服务组件（特别是管理端组件）集成到统一的界面框架下，让用户能够在统一的界面中使用系统。</li>
<li>分布式事务:对于重要的业务，需要通过分布式事务技术（TCC、高可用消息服务、最大努力通知）保证数据的一致性。具有代表性的有spring transaction</li>
<li>调用链:记录完成一个业务逻辑时调用到的微服务，并将这种串行或并行的调用关系展示出来。在系统出错时，可以方便地找到出错点。具有代表性的有pinpoint.</li>
<li>支撑平台:系统微服务化后，系统变得更加碎片化，系统的部署、运维、监控等都比单体架构更加复杂，那么，就需要将大部分的工作自动化。现在，可以通过Docker等工具来中和这些微服务架构带来的弊端。 例如:持续集成、蓝绿发布、健康检查、性能健康等等。严重点，以我们两年的实践经验，可以这么说，如果没有合适的支撑平台或工具，就不要使用微服务架构。</li>
</ul>
</blockquote>

        
    </section>
</article>





</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
        });
    </script>

</body>
</html>
