<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />

    

    

    <title>Donjote 博客</title>
    <meta name="author" content="Donjote" />
    <meta name="version" content="1.0.0" />
    <meta name="keywords" content="undefined" />
    <meta name="description" content="null" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
    <meta name="baidu-site-verification" content="F0CXvmUgA9" />

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item active">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Tags</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Electron/">Electron</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang/">Golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NoSQL/">NoSQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nodejs/">Nodejs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RPC/">RPC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React-Native/">React Native</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Restful/">Restful</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TensorFlow/">TensorFlow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Weex/">Weex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Yarn/">Yarn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/etcd/">etcd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gRPC/">gRPC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm镜像/">npm镜像</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-boot/">spring boot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/事务/">事务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式架构/">分布式架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/区块链/">区块链</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微服务/">微服务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/敏捷开发/">敏捷开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务发现/">服务发现</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/深度学习/">深度学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/神经网络/">神经网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/跨平台/">跨平台</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">归档</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/about">关于</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://donjote.github.io"></form>

        
        

        
        <div class="author-meta">
            
            <div class="author-avatar">
                <a href="/">
                    <img src="/images/avatar.jpg" title="Sanonz">
                </a>
            </div>
            
            <div class="author-name">Donjote</div>
            <div class="author-work"></div>
            <div class="author-location">
                <i class="icon-location vm"></i>
                <span class="vm">Shenzhen, China</span>
            </div>
            
            <div class="author-thread-wrap">
                <div class="author-threads clearfix">
                    
                    <a class="thread-item" href="https://github.com/donjote" target="_blank" rel="noopener"><i class="icon-github"></i></a>
                    
                    
                    
                </div>
            </div>
            
        </div>
        
    </div>
</aside>

</header>

        <div id="content" class="content">
    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2018/08/06/blockchain_1/">什么是区块链</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2018/08/06/blockchain_1/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-08-05T16:00:00.000Z" itemprop="datePublished">2018-08-06</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/区块链/">区块链</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <blockquote>
<p>互联网的贸易，几乎都需要借助可资信赖的<font color="red"><strong>第三方信用机构</strong></font>来处理电子支付信息。这类系统仍然内生性地受制于“基于信用的模式”。<br>区块链技术是构建比特币区块链网络与交易信息和加密传输的基础技术。它基于密码学原理而不基于信用，使得任何达成一致的<font color="red"><strong>双方直接支付</strong></font>，从而不需要第三方中介的参与。</p>
</blockquote>
<h2 id="区块链起源"><a href="#区块链起源" class="headerlink" title="区块链起源"></a>区块链起源</h2><blockquote>
<p>区块链技术起源于2008年中本聪《比特币：一种点对点电子现金系统》，区块链诞生自中本聪的比特币。</p>
</blockquote>
<h2 id="拜占庭将军问题"><a href="#拜占庭将军问题" class="headerlink" title="拜占庭将军问题"></a>拜占庭将军问题</h2><blockquote>
<p>拜占庭帝国派10支军队进攻一敌人，这个敌人可抵御5支军队同时攻击，这10支军队不能集合单点突破，须分开同时攻击。问题是多个将军相互并不信任(存在叛徒)时，这种状态下要保证进攻一致，需要某种分布式协议来进行远程协调。如果每个将军向其他九个将军派出一名信使，总计90次传输，每个将军会收到9条信息，可能每一封都附着不同的进攻时间。此外，部分叛徒会故意答应超过一个的攻击时间，所以他们将重新广播超过一条的信息链。这个系统变成不可靠信息和攻击时间矛盾的混合体。</p>
<ul>
<li>解决思路<br>拜占庭将军故事的最后，数学家设计了一套算法，让将军们在接到上一位将军的信息之后，加上自己的签名再转给自己之外的其他将军，这样的信息模块就形成了<font color="blue"><strong>区块链</strong></font>。</li>
</ul>
</blockquote>
<h2 id="区块链引言"><a href="#区块链引言" class="headerlink" title="区块链引言"></a>区块链引言</h2><blockquote>
<ul>
<li>拜占庭将军问题延伸至互联网生活，即：在互联网大背景下，当需要与不熟悉的对手进行价值交换活动时，人们如何才能防止不会被其中的恶意破坏欺骗、迷惑从而错误决策。</li>
<li>再把该问题抽象化，理解为：在缺少可信任中央节点和可信任通道情况下，分布在网络中的各节点应如何达成共识。</li>
<li>这一对拜占庭将军问题的解决方案，可以推广到任何核心问题是在分布式网络上缺乏信任的领域。</li>
</ul>
</blockquote>
<h2 id="区块链的目的：用于验证其信息的有效性（防伪）"><a href="#区块链的目的：用于验证其信息的有效性（防伪）" class="headerlink" title="区块链的目的：用于验证其信息的有效性（防伪）"></a><font color="red"><strong>区块链的目的：用于验证其信息的有效性（防伪）</strong></font></h2><h2 id="什么是区块链"><a href="#什么是区块链" class="headerlink" title="什么是区块链"></a>什么是区块链</h2><blockquote>
<p>区块链是比特币的底层技术，像一个数据库账本，记载所有的交易记录。</p>
<hr>
<p>在一个40人以上的微信群里组局聚餐，如何统计人数？一种方式是大家纷纷发言，有个人来统计；另一种方式是大家接龙，每个人在上一个人的发言后面累加一个号并加上自己的名字，最后就能记录全部的报名人员和人数–》区块链。</p>
</blockquote>
<table>
<thead>
<tr>
<th>微信组局</th>
<th>在区块链里的概念</th>
</tr>
</thead>
<tbody>
<tr>
<td>接龙发帖</td>
<td>链式数据结构（1）</td>
</tr>
<tr>
<td>规则：每个人发帖 = 上一个帖子内容 + 下一个编号 + 自己的名字</td>
<td>共识机制，根据严格的规则和公开的协议形成</td>
</tr>
<tr>
<td>规则定下来后，大家自发登记</td>
<td>去中心化，没有任何单一用户能够控制它</td>
</tr>
<tr>
<td>在微信群里记录登记情况</td>
<td>点对点对等网络</td>
</tr>
<tr>
<td>只要联网就能得知最新进展</td>
<td>博弈机制（2）</td>
</tr>
<tr>
<td>为了形成40个人的报名记录，至少要有40人发40篇帖子才够，群友手机里都存档</td>
<td>分布式（多点备份）、高冗余</td>
</tr>
<tr>
<td>每篇帖子大家都看得见，更新的记录是否数字错了，人重复了，每个人都可以检查</td>
<td>共享账薄</td>
</tr>
<tr>
<td>群里的人大家都认识，各有各的名字/代号</td>
<td>通过非对称加密技术保证陌生人可信（3）</td>
</tr>
</tbody>
</table>
<p><strong>区块链中的“区块”指的是信息块，这个信息块内包含有一个特殊的信息就是时间戳。含有时间戳的信息块彼此互联，形成的信息块链条被称为“区块链”。</strong></p>
<ul>
<li>一是数据结构，接龙发帖只记录“上一贴加1”这个简单计算，而区块链里记账的信息会复杂的多，每一个区块记录了上一个区块、时间戳、从上一个区块到这个区块之间发生的所有交易记录。</li>
<li>二是博弈机制，用来解决链式结构万一遇到分叉了怎么办？在微信组局的情景里，如果有两人同时发帖、或者有人因为网络延迟导致没有在最新的帖子后面跟帖导致重号怎么办？很自然的办法就是，哪个跟帖跟的多，以哪个为准；出现重复的人乖乖到较多的哪个跟帖后面写上自己的跟帖。区块链里也基本一样，以一定时间为限，哪条分叉较长就以哪个为准进行记录，较短的分叉上记录的交易作废，推迟到下一个时间段里记的账里。</li>
<li>三是非对称加密技术，用来解决陌生人之间的信任问题。这是跟微信组局最大的不同，微信的认证帮助用户做了过滤，群里的都是熟人/可信的人。在区块链里利用哈希、PKI公钥体系为每个人制作了一个唯一密码生成的唯一地址，功能类似于国内网银用的“U盾”，凡是用这个”U盾”接入区块链的，就可以进行交易，别人能识别你的身份，但是无法伪装成你。这样解决了信任体系的问题。<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2>区块链是一个<font color="red">分布式账本</font>，一种通过<font color="red">去中心化、去信任</font>的方式集体维护一个可靠数据库的技术方案。<h3 id="从数据的角度来看"><a href="#从数据的角度来看" class="headerlink" title="从数据的角度来看"></a>从数据的角度来看</h3>区块链是一种几乎不可能被更改的分布式数据库。这里的“分布式”不仅体现为数据的<font color="red">分布式存储</font>，也体现为数据的<font color="red">分布式记录</font>（即由系统参与者共同维护）。<h3 id="从技术的角度来看"><a href="#从技术的角度来看" class="headerlink" title="从技术的角度来看"></a>从技术的角度来看</h3>区块链并不是一种单一的技术，而是<font color="red">多种技术整合</font>的结果。这些技术以新的结构组合在一起，形成了一种新的数据记录、存储和表达的方式。<h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><h3 id="开放，共识"><a href="#开放，共识" class="headerlink" title="开放，共识"></a>开放，共识</h3>任何人都可以参与到区块链网络，每一台设备都能作为一个节点，每个节点都允许后的一份完整的数据库拷贝。节点间基于一同共识机制，通过竞争计算共同维护整个区块链。任一节点失效，其他节点仍能正常工作。<h3 id="去中心，去信任"><a href="#去中心，去信任" class="headerlink" title="去中心，去信任"></a>去中心，去信任</h3>区块链由众多节点共同组成一个端到端的网络，不存在中心化的设备和管理机构。节点之间数据交换通过数字签名技术进行验证，无需互相信任，只要按照系统既定的规则进行，节点之间不能也无法欺骗其它节点。<h3 id="交易透明，双方匿名"><a href="#交易透明，双方匿名" class="headerlink" title="交易透明，双方匿名"></a>交易透明，双方匿名</h3>区块链的运行规则是公开透明的，所有的数据信息也是公开的，因此每一笔交易都对所有节点可见。由于节点与节点之间是去信任的，因此节点之间无需公开身份，每个参与的节点都是匿名的。<h3 id="不可篡改，可追溯"><a href="#不可篡改，可追溯" class="headerlink" title="不可篡改，可追溯"></a>不可篡改，可追溯</h3>单个甚至多个节点对数据库的修改无法影响其他节点的数据库，除非能控制整个网络中超过51%的节点同时修改，这几乎不可能发生。区块链中的每一笔交易都通过密码学方法与相邻两个区块串联，因此可以追溯到任何一笔交易的前世今生。<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="公有链"><a href="#公有链" class="headerlink" title="公有链"></a>公有链</h3>无官方组织及管理机构，无中心服务器，参与的节点按照系统规则自由接入网络、不受控制，节点间基于共识机制开展工作。<h3 id="私有链"><a href="#私有链" class="headerlink" title="私有链"></a>私有链</h3>建立在某个企业内部，系统的运作规则根据企业要求进行设定，修改甚至是读取权限仅限于少数节点，同时仍然保留着区块链的真实性和部分去中心化的特性。<h3 id="联盟链"><a href="#联盟链" class="headerlink" title="联盟链"></a>联盟链</h3>由若干机构联合发起，介于公有链和私有链之间，兼具部分去中心化的特性。</li>
</ul>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/09/01/restful/">RESTful API 设计指南[引用]</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/09/01/restful/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-08-31T16:00:00.000Z" itemprop="datePublished">2017-09-01</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Restful/">Restful</a>, <a class="article-tag-link" href="/tags/架构/">架构</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><blockquote>
<p>API与用户的通信协议，总是使用HTTPs协议。</p>
</blockquote>
<h2 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h2><blockquote>
<p>应该尽量将API部署在专用域名之下。</p>
<blockquote>
<p><a href="https://api.example.com" target="_blank" rel="external">https://api.example.com</a></p>
</blockquote>
<p>如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。</p>
<blockquote>
<p><a href="https://example.com/api/" target="_blank" rel="external">https://example.com/api/</a></p>
</blockquote>
</blockquote>
<h2 id="版本（Versioning）"><a href="#版本（Versioning）" class="headerlink" title="版本（Versioning）"></a>版本（Versioning）</h2><blockquote>
<p>应该将API的版本号放入URL。</p>
<blockquote>
<p><a href="https://api.example.com/v1/" target="_blank" rel="external">https://api.example.com/v1/</a></p>
</blockquote>
<p>另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。<a href="https://developer.github.com/v3/media/#request-specific-version" target="_blank" rel="external">Github</a>采用这种做法。</p>
</blockquote>
<h2 id="路径（Endpoint）"><a href="#路径（Endpoint）" class="headerlink" title="路径（Endpoint）"></a>路径（Endpoint）</h2><blockquote>
<p>路径又称”终结点”（endpoint），表示API的具体网址。<br>在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。<br>举例来说，有一个API提供用户（user）的信息，则它的路径应该设计成下面这样。</p>
<blockquote>
<p><a href="https://api.example.com/v1/users" target="_blank" rel="external">https://api.example.com/v1/users</a></p>
</blockquote>
</blockquote>
<h2 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h2><blockquote>
<p>对于资源的具体操作类型，由HTTP方法表示。<br>常用的HTTP方法有下面五个（括号里是对应的SQL命令）。</p>
<blockquote>
<ul>
<li>GET（SELECT）：从服务器取出资源（一项或多项）。</li>
<li>POST（CREATE）：在服务器新建一个资源。</li>
<li>PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。</li>
<li>PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。</li>
<li>DELETE（DELETE）：从服务器删除资源。</li>
</ul>
<hr>
<p>还有两个不常用的HTTP方法。</p>
<ul>
<li>HEAD：获取资源的元数据。</li>
<li>OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。</li>
</ul>
</blockquote>
<p>下面是一些例子。</p>
<blockquote>
<ul>
<li>GET /users：列出所有用户</li>
<li>POST /users：新建一个用户</li>
<li>GET /users/ID：获取某个指定用户的信息</li>
<li>PUT /users/ID：更新某个指定用户的信息（提供该用户的全部信息）</li>
<li>PATCH /users/ID：更新某个指定用户的信息（提供该用户的部分信息）</li>
<li>DELETE /users/ID：删除某个用户</li>
<li>GET /users/ID/address：列出某个指定用户的所有地址</li>
<li>DELETE /users/ID/address/ID：删除某个指定用户的指定地址</li>
</ul>
</blockquote>
</blockquote>
<h2 id="过滤信息（Filtering）"><a href="#过滤信息（Filtering）" class="headerlink" title="过滤信息（Filtering）"></a>过滤信息（Filtering）</h2><blockquote>
<p>如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。<br>下面是一些常见的参数。</p>
<blockquote>
<ul>
<li>?limit=10：指定返回记录的数量</li>
<li>?offset=10：指定返回记录的开始位置。</li>
<li>?page=2&amp;per_page=100：指定第几页，以及每页的记录数。</li>
<li>?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</li>
<li>?animal_type_id=1：指定筛选条件</li>
</ul>
</blockquote>
<p>参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /users/ID/address 与 GET /address?user_id=ID 的含义是相同的。</p>
</blockquote>
<h2 id="状态码（Status-Codes）"><a href="#状态码（Status-Codes）" class="headerlink" title="状态码（Status Codes）"></a>状态码（Status Codes）</h2><blockquote>
<p>服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。</p>
<blockquote>
<ul>
<li>200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</li>
<li>201 CREATED - [POST/PUT]：用户新建或修改数据成功。</li>
<li>202 Accepted - [* ]：表示一个请求已经进入后台排队（异步任务）</li>
<li>204 NO CONTENT - [DELETE/PATCH]：服务器成功处理了请求,但不需要返回任何实体内容。</li>
<li>400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。</li>
<li>401 Unauthorized - [* ]：表示用户没有权限（令牌、用户名、密码错误）。</li>
<li>403 Forbidden - [* ] 表示用户得到授权（与401错误相对），但是访问是被禁止的。</li>
<li>404 NOT FOUND - [* ]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</li>
<li>406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。</li>
<li>410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。</li>
<li>422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。</li>
<li>500 INTERNAL SERVER ERROR - [* ]：服务器发生错误，用户将无法判断发出的请求是否成功。</li>
</ul>
</blockquote>
<p>状态码的完全列表参见<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html" target="_blank" rel="external">这里</a>。</p>
</blockquote>
<h2 id="错误处理（Error-handling）"><a href="#错误处理（Error-handling）" class="headerlink" title="错误处理（Error handling）"></a>错误处理（Error handling）</h2><blockquote>
<p>如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。</p>
<pre><code>{
  error: &quot;Invalid API key&quot;
}
</code></pre></blockquote>
<h2 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h2><blockquote>
<p>针对不同操作，服务器向用户返回的结果应该符合以下规范。</p>
<blockquote>
<ul>
<li>GET /collection：返回资源对象的列表（数组）</li>
<li>GET /collection/resource：返回单个资源对象</li>
<li>POST /collection：返回新生成的资源对象</li>
<li>PUT /collection/resource：返回完整的资源对象</li>
<li>PATCH /collection/resource：返回一个空文档</li>
<li>DELETE /collection/resource：返回一个空文档</li>
</ul>
</blockquote>
</blockquote>
<h2 id="Hypermedia-API"><a href="#Hypermedia-API" class="headerlink" title="Hypermedia API"></a>Hypermedia API</h2><blockquote>
<p>RESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。<br>比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。</p>
<pre><code>{
  &quot;link&quot;: {
    &quot;rel&quot;:   &quot;collection https://www.example.com/users&quot;,
    &quot;href&quot;:  &quot;https://api.example.com/users&quot;,
    &quot;title&quot;: &quot;List of users&quot;,
    &quot;type&quot;:  &quot;application/vnd.yourformat+json&quot;
  }
}
</code></pre><p>上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。<br>Hypermedia API的设计被称为<a href="https://en.wikipedia.org/wiki/HATEOAS" target="_blank" rel="external">HATEOAS</a>。Github的API就是这种设计，访问api.github.com会得到一个所有可用API的网址列表。</p>
<pre><code>{
  &quot;current_user_url&quot;: &quot;https://api.github.com/user&quot;,
  &quot;authorizations_url&quot;: &quot;https://api.github.com/authorizations&quot;,
  // ...
}
</code></pre><p>从上面可以看到，如果想获取当前用户的信息，应该去访问api.github.com/user，然后就得到了下面结果。</p>
<pre><code>{
  &quot;message&quot;: &quot;Requires authentication&quot;,
  &quot;documentation_url&quot;: &quot;https://developer.github.com/v3&quot;
}
</code></pre><p>上面代码表示，服务器给出了提示信息，以及文档的网址。</p>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/08/31/git/">Git使用简介</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/08/31/git/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-08-30T16:00:00.000Z" itemprop="datePublished">2017-08-31</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Git/">Git</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>Git是一款免费、开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理</p>
</blockquote>
<h2 id="git和svn的差异"><a href="#git和svn的差异" class="headerlink" title="git和svn的差异"></a>git和svn的差异</h2><blockquote>
<p>git和svn最大的差异在于git是分布式的管理方式而svn是集中式的管理方式。</p>
</blockquote>
<h3 id="集中式管理"><a href="#集中式管理" class="headerlink" title="集中式管理"></a>集中式管理</h3><blockquote>
<ul>
<li>集中式管理的工作流程图：<blockquote>
<p><img src="/2017/08/31/git/1.png" alt="集中式管理的工作流程图"></p>
</blockquote>
</li>
</ul>
<p>&emsp;&emsp;集中式代码管理的核心是服务器，所有开发者在开始新一天的工作之前必须从服务器获取代码，然后开发，最后解决冲突，提交。所有的版本信息都放在服务器上。如果脱离了服务器，开发者基本上是不可以工作。下面举例说明：</p>
<p><font color="red"> <strong>开始新一天的工作：</strong></font></p>
<ol>
<li>从服务器下载项目组最新代码。</li>
<li>进入自己的分支，进行工作，每隔1个小时向服务器自己的分支提交一次代码（很多人都有这个习惯。因为有时候自己对代码改来改去，最后又想还原到前一个小时的版本，或者看看前一个小时自己修改了哪些代码，就需要这样做了）。</li>
<li>下班时间快到了，把自己的分支合并到服务器主分支上，一天的工作完成，并反映给服务器。<br>这就是经典的svn工作流程，从流程上看，有不少缺点，但也有优点。</li>
</ol>
<ul>
<li><strong>缺点：</strong></li>
</ul>
<ol>
<li>服务器压力太大，数据库容量暴增。</li>
<li>如果不能连接到服务器上，基本上不可以工作，看上面第二步，如果服务器不能连接上，就不能提交，还原，对比等等。</li>
<li>不适合开源开发（开发人数非常非常多，但是Google app engine就是用svn的）。但是一般集中式管理的有非常明确的权限管理机制（例如分支访问限制），可以实现分层管理，从而很好的解决开发人数众多的问题。</li>
</ol>
<ul>
<li><strong>优点：</strong></li>
</ul>
<ol>
<li>管理方便，逻辑明确，符合一般人思维习惯。</li>
<li>易于管理，集中式服务器更能保证安全性。</li>
<li>代码一致性非常高。</li>
<li>适合开发人数不多的项目开发。</li>
<li>大部分软件配置管理的大学教材都是使用svn 和vss。</li>
</ol>
</blockquote>
<h3 id="分布式管理"><a href="#分布式管理" class="headerlink" title="分布式管理"></a>分布式管理</h3><blockquote>
<ul>
<li>分布式管理的工作流程图：<blockquote>
<p><img src="/2017/08/31/git/2.png" alt="分布式管理的工作流程图"></p>
</blockquote>
</li>
</ul>
<p>&emsp;&emsp;分布式和集中式的最大区别在于开发者可以在本地提交。每个开发者机器上都有一个服务器的数据库。<br>&emsp;&emsp;上图就是经典的git开发过程。步骤如下：</p>
<ul>
<li><strong>一般开发者的角度：</strong></li>
</ul>
<ol>
<li>从服务器上克隆数据库（包括代码和版本信息）到单机上。</li>
<li>在自己的机器上创建分支，修改代码。</li>
<li>在单机上自己创建的分支上提交代码。</li>
<li>在单机上合并分支。</li>
<li>新建一个分支，把服务器上最新版的代码fetch下来，然后跟自己的主分支合并。</li>
<li>生成补丁（patch），把补丁发送给主开发者。</li>
<li>看主开发者的反馈，如果主开发者发现两个一般开发者之间有冲突（他们之间可以合作解决的冲突），就会要求他们先解决冲突，然后再由其中一个人提交。如果主开发者可以自己解决，或者没有冲突，就通过。</li>
<li>一般开发者之间解决冲突的方法，开发者之间可以使用pull命令解决冲突，解决完冲突之后再向主开发者提交补丁。</li>
</ol>
<ul>
<li><strong>主开发者的角度（假设主开发者不用开发代码）：</strong></li>
</ul>
<ol>
<li>查看邮件或者通过其它方式查看一般开发者的提交状态。</li>
<li>打上补丁，解决冲突（可以自己解决，也可以要求开发者之间解决以后再重新提交，如果是开源项目，还要决定哪些补丁可用，哪些不用）。</li>
<li>向公共服务器提交结果，然后通知所有开发人员。</li>
</ol>
<ul>
<li><strong>优点：</strong></li>
</ul>
<ol>
<li>适合分布式开发，强调个体。</li>
<li>公共服务器压力和数据量都不会太大。</li>
<li>速度快、灵活。</li>
<li>任意两个开发者之间可以很容易的解决冲突。</li>
</ol>
<ul>
<li><strong>缺点：</strong></li>
</ul>
<ol>
<li>资料少（起码中文资料很少）。</li>
<li>学习周期相对而言比较长。</li>
<li>不符合常规思维。</li>
<li>代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有代码和版本信息。</li>
</ol>
</blockquote>
<h2 id="git常用命令介绍"><a href="#git常用命令介绍" class="headerlink" title="git常用命令介绍"></a>git常用命令介绍</h2><blockquote>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>git init　</td>
<td>创建一个数据库</td>
</tr>
<tr>
<td>git clone</td>
<td>复制一个数据到制定文件夹</td>
</tr>
<tr>
<td>git add 和git commit</td>
<td>把想提交的文件add上，然后commit这些文件到本地数据库。</td>
</tr>
<tr>
<td>git pull</td>
<td>从服务器下载数据库，并跟自己的数据库合并。</td>
</tr>
<tr>
<td>git fetch</td>
<td>从服务器下载数据库，并放到新分支，不跟自己的数据库合并。</td>
</tr>
<tr>
<td>git whatchanged</td>
<td>查看两个分支的变化</td>
</tr>
<tr>
<td>git branch</td>
<td>创建分支，查看分支，删除分支</td>
</tr>
<tr>
<td>git checkout</td>
<td>切换分支</td>
</tr>
<tr>
<td>git merge</td>
<td>合并分支，把目标分支合并到当前分支</td>
</tr>
<tr>
<td>git config</td>
<td>配置相关信息，例如email和name</td>
</tr>
<tr>
<td>git log</td>
<td>查看版本历史</td>
</tr>
<tr>
<td>git show</td>
<td>查看版本号对于版本的历史，如果参数是HEAD查看最新版本。</td>
</tr>
<tr>
<td>git tag</td>
<td>标定版本号</td>
</tr>
<tr>
<td>git reset</td>
<td>恢复到之前的版本 <br>–mixed是git-reset的默认选项，它的作用是重置索引内容，将其定位到指定的项目版本，而不改变你的工作树中的所有内容，只是提示你有哪些文件还未更新。<br>–soft选项既不触动索引的位置，也不改变工作树中的任何内容。该选项会保留你在工作树中的所有更新并使之处于待提交状态。相当于在<br>–mixed基础上加上git add。 –hard 把整个目录还原到一个版本，包括所有文件。</td>
</tr>
<tr>
<td>git push</td>
<td>向其他数据库推送自己的数据库</td>
</tr>
<tr>
<td>git status</td>
<td>显示当前的状态</td>
</tr>
<tr>
<td>git mv</td>
<td>重命名文件或者文件夹</td>
</tr>
<tr>
<td>git rm</td>
<td>删除文件或者文件夹</td>
</tr>
<tr>
<td>git help</td>
<td>查看帮助，还有几个无关紧要的命令，请自己查看帮助。</td>
</tr>
</tbody>
</table>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/08/30/docker/">docker简介</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/08/30/docker/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-08-29T16:00:00.000Z" itemprop="datePublished">2017-08-30</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/docker/">docker</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker"></a>什么是Docker</h2><blockquote>
<p>&emsp;&emsp;Docker 是一个开源项目，诞生于 2013 年初，最初是 dotCloud 公司内部的一个业余项目。它基于 Google 公司推出的 Go 语言实现。 它基于Linux容器技术（LXC），Namespace(命名空间)，Cgroup(控制组)，UnionFS（联合文件系统）等技术。项目后来加入了 Linux 基金会，遵从了 Apache 2.0 协议，项目代码在 GitHub 上进行维护。   </p>
<p><strong><font color="red"> namespace（命名空间）：</font></strong> 命名空间是 Linux 内核一个强大的特性。每个容器都有自己单独的名字空间，运行在其中的应用都像是在独立的操作系统中运行一样。名字空间保证了容器之间彼此互不影响。docker实际上一个进程容器，它通过namespace实现了进程和进程所使用的资源的隔离。使不同的进程之间彼此不可见。我们可以把Docker容器想像成进程＋操作系统除内核之外的一套软件。</p>
<p><strong><font color="red"> cgroup（控制组）：</font></strong> 是 Linux 内核的一个特性，主要用来对共享资源进行隔离、限制、审计等。只有能控制分配到容器的资源，才能避免当多个容器同时运行时的对系统资源的竞争。控制组技术最早是由 Google 的程序员 2006 年起提出，Linux 内核自 2.6.24 开始支持。控制组可以提供对容器的内存、CPU、磁盘 IO 等资源的限制和审计管理。</p>
<p><strong><font color="red"> UnionFS（联合文件系统）：</font></strong> Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对 文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。另外，不同 Docker 容器就可以共享一些基础的文件系统层，同时再加上自己独有的改动层，大大提高了存储的效率。Docker 中使用的 AUFS（AnotherUnionFS）就是一种 Union FS。 AUFS 支持为每一个成员目录（类似 Git 的分支）设定只读（readonly）、读写（readwrite）和写出（whiteout-able）权限, 同时 AUFS 里有一个类似分层的概念, 对只读权限的分支可以逻辑上进行增量地修改(不影响只读部分的)。</p>
</blockquote>
<h2 id="快速理解Docker"><a href="#快速理解Docker" class="headerlink" title="快速理解Docker"></a>快速理解Docker</h2><blockquote>
<p>&emsp;&emsp;拿现实世界中货物的运输作类比, 为了解决各种型号规格尺寸的货物在各种运输工具上进行运输的问题,我们发明了集装箱<br><img src="/2017/08/30/docker/1.jpg" alt="集装箱"><br>&emsp;&emsp;docker的初衷也就是将各种应用程序和他们所依赖的运行环境打包成标准的Container/image,进而发布到不同的平台上运行<br><img src="/2017/08/30/docker/2.jpg" alt="docker"><br>&emsp;&emsp;从理论上说这一概念并不新鲜, 各种虚拟机Image也起着类似的作用<br>&emsp;&emsp;Docker container和普通的虚拟机Image相比, 最大的区别是它并不包含操作系统内核.<br><img src="/2017/08/30/docker/3.jpg" alt="docker"><br>&emsp;&emsp;普通虚拟机将整个操作系统运行在虚拟的硬件平台上, 进而提供完整的运行环境供应用程序运行, 而Docker则直接在宿主平台上加载运行应用程序. 本质上他在底层使用LXC启动一个Linux Container,通过cgroup等机制对不同的container内运行的应用程序进行隔离,权限管理和quota分配等</p>
<p>&emsp;&emsp;每个container拥有自己独立的各种命名空间(亦即资源)包括:PID 进程, MNT 文件系统, NET 网络, IPC , UTS 主机名 等</p>
</blockquote>
<h2 id="为什么要使用Docker"><a href="#为什么要使用Docker" class="headerlink" title="为什么要使用Docker"></a>为什么要使用Docker</h2><blockquote>
<p>&emsp;&emsp;作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。</p>
<p>&emsp;&emsp;首先，Docker 容器的启动可以在秒级实现，这相比传统的虚拟机方式要快得多。 其次，Docker 对系统资源的利用率很高，一台主机上可以同时运行数千个 Docker 容器。</p>
<p>&emsp;&emsp;容器除了运行其中应用外，基本不消耗额外的系统资源，使得应用的性能很高，同时系统的开销尽量小。传统虚拟机方式运行 10 个不同的应用就要起 10 个虚拟机，而Docker 只需要启动 10 个隔离的应用即可。</p>
<p>&emsp;&emsp;具体说来，Docker 在如下几个方面具有较大的优势。</p>
<ul>
<li>更快速的交付和部署<br>&emsp;&emsp;对开发和运维（devop）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。<br>&emsp;&emsp;开发者可以使用一个标准的镜像来构建一套开发容器，开发完成之后，运维人员可以直接使用这个容器来部署代码。 Docker 可以快速创建容器，快速迭代应用程序，并让整个过程全程可见，使团队中的其他成员更容易理解应用程序是如何创建和工作的。 Docker 容器很轻很快！容器的启动时间是秒级的，大量地节约开发、测试、部署的时间。</li>
<li>更高效的虚拟化<br>&emsp;&emsp;Docker 容器的运行不需要额外的 hypervisor 支持，它是内核级的虚拟化，因此可以实现更高的性能和效率。</li>
<li>更轻松的迁移和扩展<br>&emsp;&emsp;Docker 容器几乎可以在任意的平台上运行，包括物理机、虚拟机、公有云、私有云、个人电脑、服务器等。 这种兼容性可以让用户把一个应用程序从一个平台直接迁移到另外一个。</li>
<li>更简单的管理<br>&emsp;&emsp;使用 Docker，只需要小小的修改，就可以替代以往大量的更新工作。所有的修改都以增量的方式被分发和更新，从而实现自动化并且高效的管理。</li>
</ul>
</blockquote>
<h2 id="Docker基本概念"><a href="#Docker基本概念" class="headerlink" title="Docker基本概念"></a>Docker基本概念</h2><blockquote>
<ul>
<li>镜像（Image）<br>&emsp;&emsp;Docker的镜像概念类似于虚拟机里的镜像，是一个只读的模板，一个独立的文件系统，包括运行容器所需的数据，可以用来创建新的容器。镜像可以基于Dockerfile构建，Dockerfile是一个描述文件，里面包含若干条命令，每条命令都会对基础文件系统创建新的层次结构。用户可以通过编写Dockerfile创建新的镜像，也可以直接从类似github的Docker Hub上下载镜像使用。</li>
<li>容器（Container）<br>&emsp;&emsp;Docker容器是由Docker镜像创建的运行实例。Docker容器类似虚拟机，可以支持的操作包括启动，停止，删除等。每个容器间是相互隔离的，但隔离的效果比不上虚拟机。容器中会运行特定的应用，包含特定应用的代码及所需的依赖文件。</li>
</ul>
<p>&emsp;&emsp;在Docker容器中，每个容器之间的隔离使用Linux的 CGroups 和 Namespaces技术实现的。其中 CGroups 对CPU，内存，磁盘等资源的访问限制，Namespaces 提供了环境的隔离。</p>
<ul>
<li>仓库（Repository）<br>&emsp;&emsp;Docker仓库相当于一个 github 上的代码库。</li>
</ul>
<p>&emsp;&emsp;Docker 仓库是用来包含镜像的位置，Docker提供一个注册服务器（Registry）来保存多个仓库，每个仓库又可以包含多个具备不同tag的镜像。Docker运行中使用的默认仓库是 Docker Hub 公共仓库。</p>
<p>&emsp;&emsp;仓库支持的操作类似 git，创建了新的镜像后，我们可以 push 提交到仓库，也可以从指定仓库 pull 拉取镜像到本地。</p>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/08/30/transaction_tcc/">TCC柔性事务</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/08/30/transaction_tcc/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-08-29T16:00:00.000Z" itemprop="datePublished">2017-08-30</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/事务/">事务</a>, <a class="article-tag-link" href="/tags/架构/">架构</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <blockquote>
<p>&emsp;&emsp;分布式事务是一个绕不过去的挑战！微服务架构本质上就是分布式服务化架构，微服务架构的流行，让分布式事务问题日益突出！尤其是在订单业务、资金业务等系统核心业务流程中，一定要有可靠的分布式事务解决方案来保证业务数据的可靠性和准确性。</p>
<h2 id="TCC事务机制简介"><a href="#TCC事务机制简介" class="headerlink" title="TCC事务机制简介"></a>TCC事务机制简介</h2><p>&emsp;&emsp;关于TCC（Try-Confirm-Cancel）的概念，最早是由Pat Helland于2007年发表的一篇名为《Life beyond Distributed Transactions:an Apostate’s Opinion》的论文提出。在该论文中，TCC还是以Tentative-Confirmation-Cancellation作为名称；正式以Try-Confirm-Cancel作为名称的，可能是Atomikos（Gregor Hohpe所著书籍《Enterprise Integration Patterns》中收录了关于TCC的介绍，提到了Atomikos的Try-Confirm-Cancel，并认为二者是相似的概念）。</p>
<p>&emsp;&emsp;国内最早关于TCC的报道，应该是InfoQ上对阿里程立博士的一篇采访。经过程博士的这一次传道之后，TCC在国内逐渐被大家广为了解并接受。相应的实现方案和开源框架也先后被发布出来。</p>
<p>&emsp;&emsp;TCC事务机制相对于传统事务机制（X/Open XA），其特征在于它不依赖资源管理器(RM)对XA的支持，而是通过对（由业务系统提供的）业务逻辑的调度来实现分布式事务。对于业务系统中一个特定的业务逻辑S，其对外提供服务时，必须接受一些不确定性，即对业务逻辑执行的一次调用仅是一个临时性操作，调用它的消费方服务M保留了后续的取消权。如果M认为全局事务应该rollback，它会要求取消之前的临时性操作，这就对应S的一个取消操作。而当M认为全局事务应该commit时，它会放弃之前临时性操作的取消权，这对应S的一个确认操作。 每一个初步操作，最终都会被确认或取消。因此，针对一个具体的业务服务，TCC事务机制需要业务系统提供三段业务逻辑：初步操作Try、确认操作Confirm、取消操作Cancel。</p>
<hr>
<p><font color="red">1. 初步操作（Try）</font><br>&emsp;&emsp;TCC事务机制中的业务逻辑（Try），从执行阶段来看，与传统事务机制中业务逻辑相同。但从业务角度来看，是不一样的。TCC机制中的Try仅是一个初步操作，它和后续的次确认一起才能真正构成一个完整的业务逻辑。因此，可以认为[传统事务机制]的业务逻辑 = [TCC事务机制]的初步操作（Try） + [TCC事务机制]的确认逻辑（Confirm）。TCC机制将传统事务机制中的业务逻辑一分为二，拆分后保留的部分即为初步操作（Try）；而分离出的部分即为确认操作（Confirm），被延迟到事务提交阶段执行。<br>TCC事务机制以初步操作（Try）为中心，确认操作（Confirm）和取消操作（Cancel）都是围绕初步操作（Try）而展开。因此，Try阶段中的操作，其保障性是最好的，即使失败，仍然有取消操作（Cancel）可以将其不良影响进行回撤。</p>
<p><font color="red">2. 确认操作（Confirm）</font><br>&emsp;&emsp;确认操作（Confirm）是对初步操作（Try）的一个补充。当TCC事务管理器认为全局事务可以正确提交时，就会逐个执行初步操作（Try）指定的确认操作（Confirm），将初步操作（Try）未完成的事项最终完成。</p>
<p><font color="red">3. 取消操作（Cancel）</font><br>&emsp;&emsp;取消操作（Cancel）是对初步操作（Try）的一个回撤。当TCC事务管理器认为全局事务不能正确提交时，就会逐个执行初步操作（Try）指定的取消操作（Cancel），将初步操作（Try）已完成的事项全部撤回。</p>
</blockquote>
<h2 id="支付宝运营架构中柔性事务"><a href="#支付宝运营架构中柔性事务" class="headerlink" title="支付宝运营架构中柔性事务"></a>支付宝运营架构中柔性事务</h2><blockquote>
<ul>
<li><font color="red">柔性事务：业务活动</font><blockquote>
<p><img src="/2017/08/30/transaction_tcc/1.jpg" alt="柔性事务：业务活动"></p>
</blockquote>
</li>
<li><font color="red">柔性事务：业务活动举例</font><br><img src="/2017/08/30/transaction_tcc/2.jpg" alt="柔性事务：业务活动举例"></li>
<li><font color="red">柔性事务：TCC型业务服务</font><blockquote>
<p><img src="/2017/08/30/transaction_tcc/3.jpg" alt="柔性事务：TCC型业务服务"></p>
</blockquote>
</li>
<li><font color="red">柔性事务：TCC服务事务协调模式</font><blockquote>
<p><img src="/2017/08/30/transaction_tcc/4.jpg" alt="柔性事务：TCC服务事务协调模式"><br>&emsp;&emsp;可以看出，柔性事务（<a href="http://localhost:4000/2017/08/25/cap/#BASE" target="_blank" rel="external">遵循BASE理论</a>）是指相对于<a href="http://localhost:4000/2017/07/08/transaction/#事务的-ACID" target="_blank" rel="external">ACID刚性事务</a>而言的。</p>
</blockquote>
</li>
</ul>
<p>&emsp;&emsp;支付宝所说的柔性事务分为：两阶段型、补偿型、异步确保型、最大努力通知型几种。由于支付宝整个架构是SOA架构，因此传统单机环境下数据库的ACID事务满足了分布式环境下的业务需要，以上几种事务类似就是针对分布式环境下业务需要设定的。其中：<br>1、两阶段型：就是分布式事务两阶段提交，对应技术上的XA、JTA/JTS。这是分布式环境下事务处理的典型模式。<br>2、补偿型：TCC型事务（Try/Confirm/Cancel）可以归为补偿型。补偿型的例子，在一个长事务（long-running）中，一个由两台服务器一起参与的事务，服务器A发起事务，服务器B参与事务，B的事务需要人工参与，所以处理时间可能很长。如果按照ACID的原则，要保持事务的隔离性、一致性，服务器A中发起的事务中使用到的事务资源将会被锁定，不允许其他应用访问到事务过程中的中间结果，直到整个事务被提交或者回滚。这就造成事务A中的资源被长时间锁定，系统的可用性将不可接受。WS-BusinessActivity提供了一种基于补偿的long-running的事务处理模型。还是上面的例子，服务器A的事务如果执行顺利，那么事务A就先行提交，如果事务B也执行顺利，则事务B也提交，整个事务就算完成。但是如果事务B执行失败，事务B本身回滚，这时事务A已经被提交，所以需要执行一个补偿操作，将已经提交的事务A执行的操作作反操作，恢复到未执行前事务A的状态。这样的SAGA事务模型，是牺牲了一定的隔离性和一致性的，但是提高了long-running事务的可用性。例子来源：OASIS的WS-BusinessActivity文档<br>3、异步确保型将一些同步阻塞的事务操作变为异步的操作，避免对数据库事务的争用，典型例子是热点账户异步记账、批量记账的处理。<br>4、最大努力型PPT中提到的例子交易的消息通知（例如商户交易结果通知重试、补单重试）</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p> <a href="https://wenku.baidu.com/view/be946bec0975f46527d3e104.html" target="_blank" rel="external">大规模SOA系统中的分布事务处事</a><br> <a href="https://wenku.baidu.com/view/d1bbd25877232f60ddcca1d9.html" target="_blank" rel="external">支付宝架构与技术</a></p>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/08/25/mongodb/">MongoDB 简介</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/08/25/mongodb/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-08-24T16:00:00.000Z" itemprop="datePublished">2017-08-25</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/NoSQL/">NoSQL</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="什么是MongoDB"><a href="#什么是MongoDB" class="headerlink" title="什么是MongoDB ?"></a>什么是MongoDB ?</h2><blockquote>
<p>MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。<br>在高负载的情况下，添加更多的节点，可以保证服务器性能。<br>MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。<br>MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。<br><img src="/2017/08/25/mongodb/1.png" alt=""></p>
</blockquote>
<h2 id="MongoDB特点"><a href="#MongoDB特点" class="headerlink" title="MongoDB特点"></a>MongoDB特点</h2><blockquote>
<ol>
<li>支持特别查询<br>在MongoDB中，可以通过字段，范围查询进行搜索，并且还支持正则表达式搜索。</li>
<li>索引<br>可以索引文档中的任何字段。</li>
<li>复制<br>MongoDB支持主从复制。主机可以执行读写操作，从机从主机复制数据，只能用于读取或备份(不写入)</li>
<li>复制数据<br>MongoDB可以在多台服务器上运行。 复制数据以保持系统正常运行，并在硬件故障的情况下保持其运行状态。</li>
<li>负载均衡<br>由于数据放在碎片中，因此具有自动负载平衡配置。</li>
<li>支持映射缩减和聚合工具</li>
<li>使用JavaScript而不是Procedure</li>
<li>它是一个用C++编写的无模式数据库</li>
<li>提供高性能</li>
<li>轻松存储任何大小的文件，而不会使您的堆栈复杂化</li>
<li>在故障的情况下易于管理</li>
<li>它还支持：</li>
</ol>
<ul>
<li>具有动态模式的JSON数据模型</li>
<li>自动分片用于水平可扩展性</li>
<li>内置复制高可用性</li>
</ul>
</blockquote>
<h2 id="MongoDB优点"><a href="#MongoDB优点" class="headerlink" title="MongoDB优点"></a>MongoDB优点</h2><blockquote>
<ul>
<li>MongoDB 的架构较少。它是一个文档数据库，它的一个集合持有不同的文档。</li>
<li>从一个到另一个的文档的数量，内容和大小可能有差异。</li>
<li>MongoDB 中单个对象的结构很清淅。</li>
<li>MongoDB 中没有复杂的连接。</li>
<li>MongoDB 提供深度查询的功能，因为它支持对文档的强大的动态查询。</li>
<li>MongoDB 很容易扩展。</li>
<li>它使用内部存储器来存储工作集，这是其快速访问的原因。</li>
</ul>
</blockquote>
<h2 id="MongoDB的独特功能"><a href="#MongoDB的独特功能" class="headerlink" title="MongoDB的独特功能"></a>MongoDB的独特功能</h2><blockquote>
<ul>
<li>使用方便</li>
<li>重量轻/轻量级</li>
<li>比RDBMS快得多</li>
</ul>
</blockquote>
<h2 id="应该使用MongoDB在哪些场景"><a href="#应该使用MongoDB在哪些场景" class="headerlink" title="应该使用MongoDB在哪些场景"></a>应该使用MongoDB在哪些场景</h2><blockquote>
<ul>
<li>大而复杂的数据</li>
<li>移动和社会基础设施数据</li>
<li>内容管理和交付</li>
<li>用户数据管理</li>
<li>数据中心</li>
</ul>
</blockquote>
<h2 id="MongoDB和RDBMS的性能分析"><a href="#MongoDB和RDBMS的性能分析" class="headerlink" title="MongoDB和RDBMS的性能分析"></a>MongoDB和RDBMS的性能分析</h2><blockquote>
<ul>
<li>在关系数据库(RDBMS)中，表用作存储元素，而在 MongoDB 中使用的是集合。</li>
<li>在RDBMS中有多个模式，在每个模式中，可创建用于存储数据的表，而 MongoDB 是面向文档的数据库，数据是以类似JSON格式的BSON格式编写的存储的。</li>
<li>MongoDB几乎比传统数据库系统快100倍。</li>
</ul>
</blockquote>
<h2 id="MongoDB-应用案例"><a href="#MongoDB-应用案例" class="headerlink" title="MongoDB 应用案例"></a>MongoDB 应用案例</h2><blockquote>
<p>下面列举一些公司MongoDB的实际应用：</p>
<ul>
<li>Craiglist上使用MongoDB的存档数十亿条记录。</li>
<li>FourSquare，基于位置的社交网站，在Amazon EC2的服务器上使用MongoDB分享数据。</li>
<li>Shutterfly，以互联网为基础的社会和个人出版服务，使用MongoDB的各种持久性数据存储的要求。</li>
<li>bit.ly, 一个基于Web的网址缩短服务，使用MongoDB的存储自己的数据。</li>
<li>spike.com，一个MTV网络的联营公司， spike.com使用MongoDB的。</li>
<li>Intuit公司，一个为小企业和个人的软件和服务提供商，为小型企业使用MongoDB的跟踪用户的数据。</li>
<li>sourceforge.net，资源网站查找，创建和发布开源软件免费，使用MongoDB的后端存储。</li>
<li>etsy.com ，一个购买和出售手工制作物品网站，使用MongoDB。</li>
<li>纽约时报，领先的在线新闻门户网站之一，使用MongoDB。</li>
<li>CERN，著名的粒子物理研究所，欧洲核子研究中心大型强子对撞机的数据使用MongoDB。</li>
</ul>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/08/25/nosql/">NoSQL 简介</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/08/25/nosql/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-08-24T16:00:00.000Z" itemprop="datePublished">2017-08-25</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/NoSQL/">NoSQL</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="什么是NoSQL"><a href="#什么是NoSQL" class="headerlink" title="什么是NoSQL?"></a>什么是NoSQL?</h2><blockquote>
<p>NoSQL，指的是非关系型的数据库。NoSQL有时也称作Not Only SQL的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称。<br>NoSQL用于超大规模数据的存储。（例如谷歌或Facebook每天为他们的用户收集万亿比特的数据）。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。</p>
</blockquote>
<h2 id="为什么使用NoSQL"><a href="#为什么使用NoSQL" class="headerlink" title="为什么使用NoSQL ?"></a>为什么使用NoSQL ?</h2><blockquote>
<p>今天我们可以通过第三方平台（如：Google,Facebook等）可以很容易的访问和抓取数据。用户的个人信息，社交网络，地理位置，用户生成的数据和用户操作日志已经成倍的增加。我们如果要对这些用户数据进行挖掘，那SQL数据库已经不适合这些应用了, NoSQL数据库的发展也却能很好的处理这些大的数据。<br><img src="/2017/08/25/nosql/1.png" alt="NoSQL"></p>
</blockquote>
<h2 id="RDBMS-vs-NoSQL"><a href="#RDBMS-vs-NoSQL" class="headerlink" title="RDBMS vs NoSQL"></a>RDBMS vs NoSQL</h2><blockquote>
<h3 id="RDBMS"><a href="#RDBMS" class="headerlink" title="RDBMS"></a>RDBMS</h3><ul>
<li>高度组织化结构化数据</li>
<li>结构化查询语言（SQL） (SQL)</li>
<li>数据和关系都存储在单独的表中。</li>
<li>数据操纵语言，数据定义语言</li>
<li>严格的一致性</li>
<li>基础事务<h3 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h3></li>
<li>代表着不仅仅是SQL</li>
<li>没有声明性查询语言</li>
<li>没有预定义的模式</li>
<li>键值对存储，列存储，文档存储，图形数据库</li>
<li>最终一致性，而非ACID属性</li>
<li>非结构化和不可预知的数据</li>
<li>CAP定理</li>
<li>高性能，高可用性和可伸缩性</li>
</ul>
</blockquote>
<h2 id="NoSQL的优点-缺点"><a href="#NoSQL的优点-缺点" class="headerlink" title="NoSQL的优点/缺点"></a>NoSQL的优点/缺点</h2><blockquote>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h3><ul>
<li>高可扩展性</li>
<li>分布式计算</li>
<li>低成本</li>
<li>架构的灵活性，半结构化数据</li>
<li>没有复杂的关系<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点:"></a>缺点:</h3></li>
<li>没有标准化</li>
<li>有限的查询功能（到目前为止）</li>
<li>最终一致是不直观的程序</li>
</ul>
</blockquote>
<h2 id="NoSQL-数据库分类"><a href="#NoSQL-数据库分类" class="headerlink" title="NoSQL 数据库分类"></a>NoSQL 数据库分类</h2><table>
<thead>
<tr>
<th>类型</th>
<th>部分代表</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>列存储</td>
<td>Hbase Cassandra Hypertable</td>
<td>顾名思义，是按列存储数据的。最大的特点是方便存储结构化和半结构化数据，方便做数据压缩，对针对某一列或者某几列的查询有非常大的IO优势。</td>
</tr>
<tr>
<td>文档存储</td>
<td>MongoDB CouchDB</td>
<td>文档存储一般用类似json的格式存储，存储的内容是文档型的。这样也就有有机会对某些字段建立索引，实现关系数据库的某些功能。</td>
</tr>
<tr>
<td>key-value存储</td>
<td>Tokyo Cabinet / Tyrant Berkeley DB MemcacheDB Redis</td>
<td>可以通过key快速查询到其value。一般来说，存储不管value的格式，照单全收。（Redis包含了其他功能）</td>
</tr>
<tr>
<td>图存储</td>
<td>Neo4J FlockDB</td>
<td>图形关系的最佳存储。使用传统关系数据库来解决的话性能低下，而且设计使用不方便。</td>
</tr>
<tr>
<td>对象存储</td>
<td>db4o Versant</td>
<td>通过类似面向对象语言的语法操作数据库，通过对象的方式存取数据。</td>
</tr>
<tr>
<td>xml数据库</td>
<td>Berkeley DB XML BaseX</td>
<td>高效的存储XML数据，并支持XML的内部查询语法，比如XQuery,Xpath。</td>
</tr>
</tbody>
</table>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/08/25/cap/">CAP定理（CAP theorem）</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/08/25/cap/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-08-24T16:00:00.000Z" itemprop="datePublished">2017-08-25</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/NoSQL/">NoSQL</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>在计算机科学中, CAP定理（CAP theorem）, 又被称作 布鲁尔定理（Brewer’s theorem）, 它指出对于一个分布式计算系统来说，不可能同时满足以下三点:</p>
<ul>
<li>一致性(Consistency) (所有节点在同一时间具有相同的数据)</li>
<li>可用性(Availability) (保证每个请求不管成功或者失败都有响应)</li>
<li>分隔容忍(Partition tolerance) (系统中任意信息的丢失或失败不会影响系统的继续运作)<br>CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。<br>因此，根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 CP 原则和满足 AP 原则三 大类：</li>
<li>CA:单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。</li>
<li>CP:满足一致性，分区容忍性的系统，通常性能不是特别高。</li>
<li>AP:满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。<br><img src="/2017/08/25/cap/1.png" alt="cap"></li>
</ul>
</blockquote>
<h2 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h2><blockquote>
<p>BASE：Basically Available, Soft-state, Eventually Consistent。 由 Eric Brewer 定义。<br>CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。<br>BASE是NoSQL数据库通常对可用性及一致性的弱要求原则:</p>
<ul>
<li>Basically Availble –基本可用</li>
<li>Soft-state –软状态/柔性事务。 “Soft state” 可以理解为”无连接”的, 而 “Hard state” 是”面向连接”的</li>
<li>Eventual Consistency –最终一致性 最终一致性， 也是是 ACID 的最终目的。</li>
</ul>
</blockquote>
<h2 id="ACID-vs-BASE"><a href="#ACID-vs-BASE" class="headerlink" title="ACID vs BASE"></a>ACID vs BASE</h2><table>
<thead>
<tr>
<th>ACID</th>
<th>BASE</th>
</tr>
</thead>
<tbody>
<tr>
<td>原子性(Atomicity)</td>
<td>基本可用(Basically Available)</td>
</tr>
<tr>
<td>一致性(Consistency)</td>
<td>软状态/柔性事务(Soft state)</td>
</tr>
<tr>
<td>隔离性(Isolation)</td>
<td>最终一致性 (Eventual consistency)</td>
</tr>
<tr>
<td>持久性 (Durable)</td>
<td></td>
</tr>
</tbody>
</table>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/08/25/thymeleaf/">thymeleaf 使用</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/08/25/thymeleaf/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-08-24T16:00:00.000Z" itemprop="datePublished">2017-08-25</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/spring-boot/">spring boot</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="thymeleaf介绍"><a href="#thymeleaf介绍" class="headerlink" title="thymeleaf介绍"></a>thymeleaf介绍</h2><blockquote>
<p>简单说， Thymeleaf 是一个跟 Velocity、FreeMarker 类似的模板引擎，它可以完全替代 JSP 。相较与其他的模板引擎，它有如下三个极吸引人的特点：</p>
<ul>
<li>Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。这是由于它支持 html 原型，然后在 html 标签里增加额外的属性来达到模板+数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。</li>
<li>Thymeleaf 开箱即用的特性。它提供标准和spring标准两种方言，可以直接套用模板实现JSTL、 OGNL表达式效果，避免每天套模板、该jstl、改标签的困扰。同时也可以扩展和创建自定义的方言。</li>
<li>Thymeleaf 提供spring标准方言和一个与 SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。</li>
</ul>
</blockquote>
<h2 id="标准表达式语法"><a href="#标准表达式语法" class="headerlink" title="标准表达式语法"></a>标准表达式语法</h2><blockquote>
<p>分为四类：</p>
<ol>
<li>变量表达式</li>
<li>选择或星号表达式</li>
<li>文字国际化表达式</li>
<li>URL表达式</li>
</ol>
</blockquote>
<h3 id="变量表达式"><a href="#变量表达式" class="headerlink" title="变量表达式"></a>变量表达式</h3><blockquote>
<p>变量表达式即OGNL表达式或Spring EL表达式(在Spring术语中也叫model attributes)。如下所示：</p>
<pre><code>${session.user.name}
</code></pre><p>它们将以HTML标签的一个属性来表示：</p>
<pre><code>&lt;span th:text=&quot;${book.author.name}&quot;&gt;&lt;/span&gt;
&lt;li th:each=&quot;book : ${books}&quot;&gt;&lt;/li&gt;
</code></pre></blockquote>
<h3 id="选择-星号-表达式"><a href="#选择-星号-表达式" class="headerlink" title="选择(星号)表达式"></a>选择(星号)表达式</h3><blockquote>
<p>选择表达式很像变量表达式，不过它们用一个预先选择的对象来代替上下文变量容器(map)来执行，如下：</p>
<pre><code>* {customer.name}
</code></pre><p>被指定的object由th:object属性定义：</p>
<pre><code>&lt;div th:object=&quot;${book}&quot;&gt;  
  ...  
  &lt;span th:text=&quot;* {title}&quot;&gt;...&lt;/span&gt;  
  ...  
&lt;/div&gt;  
</code></pre></blockquote>
<h3 id="文字国际化表达式"><a href="#文字国际化表达式" class="headerlink" title="文字国际化表达式"></a>文字国际化表达式</h3><blockquote>
<p>文字国际化表达式允许我们从一个外部文件获取区域文字信息(.properties)，用Key索引Value，还可以提供一组参数(可选).</p>
<pre><code>#{main.title}  
#{message.entrycreated(${entryId})}  
</code></pre><p>可以在模板文件中找到这样的表达式代码：</p>
<pre><code>&lt;table&gt;  
  ...  
  &lt;th th:text=&quot;#{header.address.city}&quot;&gt;...&lt;/th&gt;  
  &lt;th th:text=&quot;#{header.address.country}&quot;&gt;...&lt;/th&gt;  
  ...  
&lt;/table&gt;  
</code></pre></blockquote>
<h3 id="URL表达式"><a href="#URL表达式" class="headerlink" title="URL表达式"></a>URL表达式</h3><blockquote>
<p>URL表达式指的是把一个有用的上下文或回话信息添加到URL，这个过程经常被叫做URL重写。</p>
<pre><code>@{/order/list}
</code></pre><p>URL还可以设置参数：</p>
<pre><code>@{/order/details(id=${orderId})}
</code></pre><p>相对路径：</p>
<pre><code>@{../documents/report}
</code></pre><p>让我们看这些表达式：</p>
<pre><code>&lt;form th:action=&quot;@{/createOrder}&quot;&gt;  
&lt;a href=&quot;main.html&quot; th:href=&quot;@{/main}&quot;&gt;
</code></pre></blockquote>
<h3 id="变量表达式和星号表达有什么区别吗？"><a href="#变量表达式和星号表达有什么区别吗？" class="headerlink" title="变量表达式和星号表达有什么区别吗？"></a>变量表达式和星号表达有什么区别吗？</h3><blockquote>
<p>如果不考虑上下文的情况下，两者没有区别；星号语法评估在选定对象上表达，而不是整个上下文<br>什么是选定对象？就是父标签的值，如下：</p>
<pre><code>&lt;div th:object=&quot;${session.user}&quot;&gt;
  &lt;p&gt;Name: &lt;span th:text=&quot;* {firstName}&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt;
  &lt;p&gt;Surname: &lt;span th:text=&quot;* {lastName}&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt;
  &lt;p&gt;Nationality: &lt;span th:text=&quot;* {nationality}&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt;
&lt;/div&gt;
</code></pre><p>这是完全等价于：</p>
<pre><code>&lt;div th:object=&quot;${session.user}&quot;&gt;
    &lt;p&gt;Name: &lt;span th:text=&quot;${session.user.firstName}&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt;
    &lt;p&gt;Surname: &lt;span th:text=&quot;${session.user.lastName}&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt;
    &lt;p&gt;Nationality: &lt;span th:text=&quot;${session.user.nationality}&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt;
&lt;/div&gt;
</code></pre><p>当然，美元符号和星号语法可以混合使用：</p>
<pre><code>&lt;div th:object=&quot;${session.user}&quot;&gt;
    &lt;p&gt;Name: &lt;span th:text=&quot;* {firstName}&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt;
    &lt;p&gt;Surname: &lt;span th:text=&quot;${session.user.lastName}&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt;
    &lt;p&gt;Nationality: &lt;span th:text=&quot;* {nationality}&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt;
&lt;/div&gt;
</code></pre></blockquote>
<h2 id="表达式支持的语法"><a href="#表达式支持的语法" class="headerlink" title="表达式支持的语法"></a>表达式支持的语法</h2><blockquote>
<h3 id="字面（Literals）"><a href="#字面（Literals）" class="headerlink" title="字面（Literals）"></a>字面（Literals）</h3><ul>
<li>文本文字（Text literals）: ‘one text’, ‘Another one!’,…</li>
<li>数字文本（Number literals）: 0, 34, 3.0, 12.3,…</li>
<li>布尔文本（Boolean literals）: true, false</li>
<li>空（Null literal）: null</li>
<li>文字标记（Literal tokens）: one, sometext, main,…<h3 id="文本操作（Text-operations）"><a href="#文本操作（Text-operations）" class="headerlink" title="文本操作（Text operations）"></a>文本操作（Text operations）</h3><ul>
<li>字符串连接(String concatenation): +</li>
</ul>
</li>
<li>文本替换（Literal substitutions）: |The name is ${name}|<h3 id="算术运算（Arithmetic-operations）"><a href="#算术运算（Arithmetic-operations）" class="headerlink" title="算术运算（Arithmetic operations）"></a>算术运算（Arithmetic operations）</h3></li>
<li>二元运算符（Binary operators）: +, -, * , /, %</li>
<li>减号（单目运算符）Minus sign (unary operator): -<h3 id="布尔操作（Boolean-operations）"><a href="#布尔操作（Boolean-operations）" class="headerlink" title="布尔操作（Boolean operations）"></a>布尔操作（Boolean operations）</h3></li>
<li>二元运算符（Binary operators）:and, or</li>
<li>布尔否定（一元运算符）Boolean negation (unary operator):!, not<h3 id="比较和等价-Comparisons-and-equality"><a href="#比较和等价-Comparisons-and-equality" class="headerlink" title="比较和等价(Comparisons and equality)"></a>比较和等价(Comparisons and equality)</h3></li>
<li>比较（Comparators）: &gt;, &lt;, &gt;=, &lt;= (gt, lt, ge, le)</li>
<li>等值运算符（Equality operators）:==, != (eq, ne)<h3 id="条件运算符（Conditional-operators）"><a href="#条件运算符（Conditional-operators）" class="headerlink" title="条件运算符（Conditional operators）"></a>条件运算符（Conditional operators）</h3></li>
<li>If-then: (if) ? (then)</li>
<li>If-then-else: (if) ? (then) : (else)</li>
<li><p>Default: (value) ?: (defaultvalue)</p>
<h3 id="所有这些特征可以被组合并嵌套："><a href="#所有这些特征可以被组合并嵌套：" class="headerlink" title="所有这些特征可以被组合并嵌套："></a>所有这些特征可以被组合并嵌套：</h3><pre><code>&apos;User is of type &apos; + (${user.isAdmin()} ? &apos;Administrator&apos; : (${user.type} ?: &apos;Unknown&apos;))
</code></pre></li>
</ul>
</blockquote>
<h2 id="常用th标签都有那些？"><a href="#常用th标签都有那些？" class="headerlink" title="常用th标签都有那些？"></a>常用th标签都有那些？</h2><blockquote>
<table>
<thead>
<tr>
<th>关键字</th>
<th>功能介绍</th>
<th>案例</th>
</tr>
</thead>
<tbody>
<tr>
<td>th:id</td>
<td>替换id</td>
<td>&lt;input th:id=”‘xxx’ + ${collect.id}”/&gt;</td>
</tr>
<tr>
<td>th:text</td>
<td>文本替换</td>
<td>&lt;p th:text=”${collect.description}”&gt;description<p></p></td>
</tr>
<tr>
<td>th:utext</td>
<td>支持html的文本替换</td>
<td>&lt;p th:utext=”${htmlcontent}”&gt;conten<p></p></td>
</tr>
<tr>
<td>th:object</td>
<td>替换对象</td>
<td>&lt;div th:object=”${session.user}”&gt;</td>
</tr>
<tr>
<td>th:value</td>
<td>属性赋值</td>
<td>&lt;input th:value=”${user.name}” /&gt;</td>
</tr>
<tr>
<td>th:with</td>
<td>变量赋值运算</td>
<td>&lt;div th:with=”isEven=${prodStat.count}%2==0”&gt;</td>
</tr>
<tr>
<td>th:style</td>
<td>设置样式</td>
<td>th:style=”‘display:’ + @{(${sitrue} ? ‘none’ : ‘inline-block’)} + ‘’”</td>
</tr>
<tr>
<td>th:onclick</td>
<td>点击事件</td>
<td>th:onclick=”‘getCollect()’”</td>
</tr>
<tr>
<td>th:each</td>
<td>属性赋值</td>
<td>tr th:each=”user,userStat:${users}”&gt;</td>
</tr>
<tr>
<td>th:if</td>
<td>判断条件</td>
<td>&lt;a th:if=”${userId == collect.userId}” &gt;</td>
</tr>
<tr>
<td>th:unless</td>
<td>和th:if判断相反</td>
<td>&lt;a th:href=”@{/login}” th:unless=${session.user != null}&gt;Login</td>
</tr>
<tr>
<td>th:href</td>
<td>链接地址</td>
<td>&lt;a th:href=”@{/login}” th:unless=${session.user != null}&gt;Login /&gt;</td>
</tr>
<tr>
<td>th:switch</td>
<td>多路选择 配合th:case 使用</td>
<td>&lt;div th:switch=”${user.role}”&gt;</td>
</tr>
<tr>
<td>th:case</td>
<td>th:switch的一个分支</td>
<td>&lt;p th:case=”‘admin’”&gt;User is an administrator<p></p></td>
</tr>
<tr>
<td>th:fragment</td>
<td>布局标签，定义一个代码片段，方便其它地方引用</td>
<td>&lt;div th:fragment=”alert”&gt;</td>
</tr>
<tr>
<td>th:include</td>
<td>布局标签，替换内容到引入的文件</td>
<td>&lt;head th:include=”layout :: htmlhead” th:with=”title=’xx’”&gt; /&gt;</td>
</tr>
<tr>
<td>th:replace</td>
<td>布局标签，替换整个标签到引入的文件</td>
<td>&lt;div th:replace=”fragments/header :: title”&gt;</td>
</tr>
<tr>
<td>th:selected</td>
<td>selected选择框 选中</td>
<td>th:selected=”(${xxx.id} == ${configObj.dd})”</td>
</tr>
<tr>
<td>th:src</td>
<td>图片类地址引入</td>
<td>&lt;img class=”img-responsive” alt=”App Logo” th:src=”@{/img/logo.png}” /&gt;</td>
</tr>
<tr>
<td>th:inline</td>
<td>定义js脚本可以使用变量</td>
<td>&lt;script type=”text/javascript” th:inline=”javascript”&gt;</td>
</tr>
<tr>
<td>th:action</td>
<td>表单提交的地址</td>
<td>&lt;form action=”subscribe.html” th:action=”@{/subscribe}”&gt;</td>
</tr>
<tr>
<td>th:remove</td>
<td>删除某个属性</td>
<td>&lt;tr th:remove=”all”&gt; 1.all:删除包含标签和所有的孩子。</td>
</tr>
<tr>
<td>th:attr</td>
<td>设置标签属性，多个属性可以用逗号分隔</td>
<td>比如 th:attr=”src=@{/image/aa.jpg},title=#{logo}”，此标签不太优雅，一般用的比较少。</td>
</tr>
</tbody>
</table>
<hr>
<p>还有非常多的标签，这里只列出最常用的几个,由于一个标签内可以包含多个th:x属性，其生效的优先级顺序为:<br>include,each,if/unless/switch/case,with,attr/attrprepend/attrappend,value/href,src ,etc,text/utext,fragment,remove。</p>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/08/24/grpc_service/">gRPC服务方法的定义</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/08/24/grpc_service/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-08-23T16:00:00.000Z" itemprop="datePublished">2017-08-24</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/RPC/">RPC</a>, <a class="article-tag-link" href="/tags/gRPC/">gRPC</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="服务定义"><a href="#服务定义" class="headerlink" title="服务定义"></a>服务定义</h2><blockquote>
<p>向其它的RPC服务一样，GPRC的基础是服务的定义。服务定义远程调用方法的名称、传入参数和返回参数。GRPC默认使用 Protobuf描述服务</p>
<hr>
<p>GRPC一共定义4种服务方法：<br>1、一元RPC(Unary RPCs )：这是最简单的定义，客户端发送一个请求，服务端返回一个结果<br>2、服务器流RPC（Server streaming RPCs）：客户端发送一个请求，服务端返回一个流给客户端，客户从流中读取一系列消息，直到读取所有小心<br>3、客户端流RPC(Client streaming RPCs )：客户端通过流向服务端发送一系列消息，然后等待服务端读取完数据并返回处理结果<br>4、双向流RPC(Bidirectional streaming RPCs)：客户端和服务端都可以独立向对方发送或接受一系列的消息。客户端和服务端读写的顺序是任意。   </p>
<hr>
<p>以上的服务方法定义在proto文件，如下:   </p>
<pre><code>  syntax = &quot;proto3&quot;;

  option java_multiple_files = true;
  option java_package = &quot;io.github.donjote.hello&quot;;
  option java_outer_classname = &quot;HelloProto&quot;;

  service Hello {
  // A Unary RPC.
  rpc simpleRpc(Simple) returns (SimpleFeature) {}

  // A server-to-client streaming RPC.
  rpc server2ClientRpc(SimpleList) returns (stream SimpleFeature) {}

  // A client-to-server streaming RPC.
  rpc client2ServerRpc(stream Simple) returns (SimpleSummary) {}

  // A Bidirectional streaming RPC.
  rpc bindirectionalStreamRpc(stream Simple) returns (stream Simple) {}
}

message Simple {
  int32 num = 1;
  string name = 2;
}

message SimpleList {
  repeated Simple simpleList = 1;
}

message SimpleFeature {
  string name = 1;
  Simple location = 2;
}

message SimpleSummary {
  int32 feature_count = 2;
}

// 测试类
message SimpleFeatureDatabase {
  repeated SimpleFeature feature = 1;
}
</code></pre></blockquote>
<h2 id="同步RPC和异步RPC"><a href="#同步RPC和异步RPC" class="headerlink" title="同步RPC和异步RPC"></a>同步RPC和异步RPC</h2><blockquote>
<p>GRPC 同时支持同步RPC和异步RPC。<br>同步RPC调用服务方法只支持流RPC（Server streaming RPCs）和一元RPC(Unary RPCs )。异步RPC调用服务方法支持4种方法。</p>
</blockquote>

        
    </section>
</article>




<nav class="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
</nav>


</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
        });
    </script>

</body>
</html>
