<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Donjote 博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://donjote.github.io/"/>
  <updated>2018-08-06T06:30:31.568Z</updated>
  <id>http://donjote.github.io/</id>
  
  <author>
    <name>Donjote</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>什么是区块链</title>
    <link href="http://donjote.github.io/2018/08/06/blockchain_1/"/>
    <id>http://donjote.github.io/2018/08/06/blockchain_1/</id>
    <published>2018-08-05T16:00:00.000Z</published>
    <updated>2018-08-06T06:30:31.568Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>互联网的贸易，几乎都需要借助可资信赖的<font color="red"><strong>第三方信用机构</strong></font>来处理电子支付信息。这类系统仍然内生性地受制于“基于信用的模式”。<br>区块链技术是构建比特币区块链网络与交易信息和加密传输的基础技术。它基于密码学原理而不基于信用，使得任何达成一致的<font color="red"><strong>双方直接支付</strong></font>，从而不需要第三方中介的参与。</p>
</blockquote>
<h2 id="区块链起源"><a href="#区块链起源" class="headerlink" title="区块链起源"></a>区块链起源</h2><blockquote>
<p>区块链技术起源于2008年中本聪《比特币：一种点对点电子现金系统》，区块链诞生自中本聪的比特币。</p>
</blockquote>
<h2 id="拜占庭将军问题"><a href="#拜占庭将军问题" class="headerlink" title="拜占庭将军问题"></a>拜占庭将军问题</h2><blockquote>
<p>拜占庭帝国派10支军队进攻一敌人，这个敌人可抵御5支军队同时攻击，这10支军队不能集合单点突破，须分开同时攻击。问题是多个将军相互并不信任(存在叛徒)时，这种状态下要保证进攻一致，需要某种分布式协议来进行远程协调。如果每个将军向其他九个将军派出一名信使，总计90次传输，每个将军会收到9条信息，可能每一封都附着不同的进攻时间。此外，部分叛徒会故意答应超过一个的攻击时间，所以他们将重新广播超过一条的信息链。这个系统变成不可靠信息和攻击时间矛盾的混合体。</p>
<ul>
<li>解决思路<br>拜占庭将军故事的最后，数学家设计了一套算法，让将军们在接到上一位将军的信息之后，加上自己的签名再转给自己之外的其他将军，这样的信息模块就形成了<font color="blue"><strong>区块链</strong></font>。</li>
</ul>
</blockquote>
<h2 id="区块链引言"><a href="#区块链引言" class="headerlink" title="区块链引言"></a>区块链引言</h2><blockquote>
<ul>
<li>拜占庭将军问题延伸至互联网生活，即：在互联网大背景下，当需要与不熟悉的对手进行价值交换活动时，人们如何才能防止不会被其中的恶意破坏欺骗、迷惑从而错误决策。</li>
<li>再把该问题抽象化，理解为：在缺少可信任中央节点和可信任通道情况下，分布在网络中的各节点应如何达成共识。</li>
<li>这一对拜占庭将军问题的解决方案，可以推广到任何核心问题是在分布式网络上缺乏信任的领域。</li>
</ul>
</blockquote>
<h2 id="区块链的目的：用于验证其信息的有效性（防伪）"><a href="#区块链的目的：用于验证其信息的有效性（防伪）" class="headerlink" title="区块链的目的：用于验证其信息的有效性（防伪）"></a><font color="red"><strong>区块链的目的：用于验证其信息的有效性（防伪）</strong></font></h2><h2 id="什么是区块链"><a href="#什么是区块链" class="headerlink" title="什么是区块链"></a>什么是区块链</h2><blockquote>
<p>区块链是比特币的底层技术，像一个数据库账本，记载所有的交易记录。</p>
<hr>
<p>在一个40人以上的微信群里组局聚餐，如何统计人数？一种方式是大家纷纷发言，有个人来统计；另一种方式是大家接龙，每个人在上一个人的发言后面累加一个号并加上自己的名字，最后就能记录全部的报名人员和人数–》区块链。</p>
</blockquote>
<table>
<thead>
<tr>
<th>微信组局</th>
<th>在区块链里的概念</th>
</tr>
</thead>
<tbody>
<tr>
<td>接龙发帖</td>
<td>链式数据结构（1）</td>
</tr>
<tr>
<td>规则：每个人发帖 = 上一个帖子内容 + 下一个编号 + 自己的名字</td>
<td>共识机制，根据严格的规则和公开的协议形成</td>
</tr>
<tr>
<td>规则定下来后，大家自发登记</td>
<td>去中心化，没有任何单一用户能够控制它</td>
</tr>
<tr>
<td>在微信群里记录登记情况</td>
<td>点对点对等网络</td>
</tr>
<tr>
<td>只要联网就能得知最新进展</td>
<td>博弈机制（2）</td>
</tr>
<tr>
<td>为了形成40个人的报名记录，至少要有40人发40篇帖子才够，群友手机里都存档</td>
<td>分布式（多点备份）、高冗余</td>
</tr>
<tr>
<td>每篇帖子大家都看得见，更新的记录是否数字错了，人重复了，每个人都可以检查</td>
<td>共享账薄</td>
</tr>
<tr>
<td>群里的人大家都认识，各有各的名字/代号</td>
<td>通过非对称加密技术保证陌生人可信（3）</td>
</tr>
</tbody>
</table>
<p><strong>区块链中的“区块”指的是信息块，这个信息块内包含有一个特殊的信息就是时间戳。含有时间戳的信息块彼此互联，形成的信息块链条被称为“区块链”。</strong></p>
<ul>
<li>一是数据结构，接龙发帖只记录“上一贴加1”这个简单计算，而区块链里记账的信息会复杂的多，每一个区块记录了上一个区块、时间戳、从上一个区块到这个区块之间发生的所有交易记录。</li>
<li>二是博弈机制，用来解决链式结构万一遇到分叉了怎么办？在微信组局的情景里，如果有两人同时发帖、或者有人因为网络延迟导致没有在最新的帖子后面跟帖导致重号怎么办？很自然的办法就是，哪个跟帖跟的多，以哪个为准；出现重复的人乖乖到较多的哪个跟帖后面写上自己的跟帖。区块链里也基本一样，以一定时间为限，哪条分叉较长就以哪个为准进行记录，较短的分叉上记录的交易作废，推迟到下一个时间段里记的账里。</li>
<li>三是非对称加密技术，用来解决陌生人之间的信任问题。这是跟微信组局最大的不同，微信的认证帮助用户做了过滤，群里的都是熟人/可信的人。在区块链里利用哈希、PKI公钥体系为每个人制作了一个唯一密码生成的唯一地址，功能类似于国内网银用的“U盾”，凡是用这个”U盾”接入区块链的，就可以进行交易，别人能识别你的身份，但是无法伪装成你。这样解决了信任体系的问题。<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2>区块链是一个<font color="red">分布式账本</font>，一种通过<font color="red">去中心化、去信任</font>的方式集体维护一个可靠数据库的技术方案。<h3 id="从数据的角度来看"><a href="#从数据的角度来看" class="headerlink" title="从数据的角度来看"></a>从数据的角度来看</h3>区块链是一种几乎不可能被更改的分布式数据库。这里的“分布式”不仅体现为数据的<font color="red">分布式存储</font>，也体现为数据的<font color="red">分布式记录</font>（即由系统参与者共同维护）。<h3 id="从技术的角度来看"><a href="#从技术的角度来看" class="headerlink" title="从技术的角度来看"></a>从技术的角度来看</h3>区块链并不是一种单一的技术，而是<font color="red">多种技术整合</font>的结果。这些技术以新的结构组合在一起，形成了一种新的数据记录、存储和表达的方式。<h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><h3 id="开放，共识"><a href="#开放，共识" class="headerlink" title="开放，共识"></a>开放，共识</h3>任何人都可以参与到区块链网络，每一台设备都能作为一个节点，每个节点都允许后的一份完整的数据库拷贝。节点间基于一同共识机制，通过竞争计算共同维护整个区块链。任一节点失效，其他节点仍能正常工作。<h3 id="去中心，去信任"><a href="#去中心，去信任" class="headerlink" title="去中心，去信任"></a>去中心，去信任</h3>区块链由众多节点共同组成一个端到端的网络，不存在中心化的设备和管理机构。节点之间数据交换通过数字签名技术进行验证，无需互相信任，只要按照系统既定的规则进行，节点之间不能也无法欺骗其它节点。<h3 id="交易透明，双方匿名"><a href="#交易透明，双方匿名" class="headerlink" title="交易透明，双方匿名"></a>交易透明，双方匿名</h3>区块链的运行规则是公开透明的，所有的数据信息也是公开的，因此每一笔交易都对所有节点可见。由于节点与节点之间是去信任的，因此节点之间无需公开身份，每个参与的节点都是匿名的。<h3 id="不可篡改，可追溯"><a href="#不可篡改，可追溯" class="headerlink" title="不可篡改，可追溯"></a>不可篡改，可追溯</h3>单个甚至多个节点对数据库的修改无法影响其他节点的数据库，除非能控制整个网络中超过51%的节点同时修改，这几乎不可能发生。区块链中的每一笔交易都通过密码学方法与相邻两个区块串联，因此可以追溯到任何一笔交易的前世今生。<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="公有链"><a href="#公有链" class="headerlink" title="公有链"></a>公有链</h3>无官方组织及管理机构，无中心服务器，参与的节点按照系统规则自由接入网络、不受控制，节点间基于共识机制开展工作。<h3 id="私有链"><a href="#私有链" class="headerlink" title="私有链"></a>私有链</h3>建立在某个企业内部，系统的运作规则根据企业要求进行设定，修改甚至是读取权限仅限于少数节点，同时仍然保留着区块链的真实性和部分去中心化的特性。<h3 id="联盟链"><a href="#联盟链" class="headerlink" title="联盟链"></a>联盟链</h3>由若干机构联合发起，介于公有链和私有链之间，兼具部分去中心化的特性。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;互联网的贸易，几乎都需要借助可资信赖的&lt;font color=&quot;red&quot;&gt;&lt;strong&gt;第三方信用机构&lt;/strong&gt;&lt;/font&gt;来处理电子支付信息。这类系统仍然内生性地受制于“基于信用的模式”。&lt;br&gt;区块链技术是构建比特币区块链网络与交易
    
    </summary>
    
      <category term="区块链" scheme="http://donjote.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://donjote.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>RESTful API 设计指南[引用]</title>
    <link href="http://donjote.github.io/2017/09/01/restful/"/>
    <id>http://donjote.github.io/2017/09/01/restful/</id>
    <published>2017-08-31T16:00:00.000Z</published>
    <updated>2018-08-03T02:59:35.912Z</updated>
    
    <content type="html"><![CDATA[<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><blockquote>
<p>API与用户的通信协议，总是使用HTTPs协议。</p>
</blockquote>
<h2 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h2><blockquote>
<p>应该尽量将API部署在专用域名之下。</p>
<blockquote>
<p><a href="https://api.example.com" target="_blank" rel="external">https://api.example.com</a></p>
</blockquote>
<p>如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。</p>
<blockquote>
<p><a href="https://example.com/api/" target="_blank" rel="external">https://example.com/api/</a></p>
</blockquote>
</blockquote>
<h2 id="版本（Versioning）"><a href="#版本（Versioning）" class="headerlink" title="版本（Versioning）"></a>版本（Versioning）</h2><blockquote>
<p>应该将API的版本号放入URL。</p>
<blockquote>
<p><a href="https://api.example.com/v1/" target="_blank" rel="external">https://api.example.com/v1/</a></p>
</blockquote>
<p>另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。<a href="https://developer.github.com/v3/media/#request-specific-version" target="_blank" rel="external">Github</a>采用这种做法。</p>
</blockquote>
<h2 id="路径（Endpoint）"><a href="#路径（Endpoint）" class="headerlink" title="路径（Endpoint）"></a>路径（Endpoint）</h2><blockquote>
<p>路径又称”终结点”（endpoint），表示API的具体网址。<br>在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。<br>举例来说，有一个API提供用户（user）的信息，则它的路径应该设计成下面这样。</p>
<blockquote>
<p><a href="https://api.example.com/v1/users" target="_blank" rel="external">https://api.example.com/v1/users</a></p>
</blockquote>
</blockquote>
<h2 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h2><blockquote>
<p>对于资源的具体操作类型，由HTTP方法表示。<br>常用的HTTP方法有下面五个（括号里是对应的SQL命令）。</p>
<blockquote>
<ul>
<li>GET（SELECT）：从服务器取出资源（一项或多项）。</li>
<li>POST（CREATE）：在服务器新建一个资源。</li>
<li>PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。</li>
<li>PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。</li>
<li>DELETE（DELETE）：从服务器删除资源。</li>
</ul>
<hr>
<p>还有两个不常用的HTTP方法。</p>
<ul>
<li>HEAD：获取资源的元数据。</li>
<li>OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。</li>
</ul>
</blockquote>
<p>下面是一些例子。</p>
<blockquote>
<ul>
<li>GET /users：列出所有用户</li>
<li>POST /users：新建一个用户</li>
<li>GET /users/ID：获取某个指定用户的信息</li>
<li>PUT /users/ID：更新某个指定用户的信息（提供该用户的全部信息）</li>
<li>PATCH /users/ID：更新某个指定用户的信息（提供该用户的部分信息）</li>
<li>DELETE /users/ID：删除某个用户</li>
<li>GET /users/ID/address：列出某个指定用户的所有地址</li>
<li>DELETE /users/ID/address/ID：删除某个指定用户的指定地址</li>
</ul>
</blockquote>
</blockquote>
<h2 id="过滤信息（Filtering）"><a href="#过滤信息（Filtering）" class="headerlink" title="过滤信息（Filtering）"></a>过滤信息（Filtering）</h2><blockquote>
<p>如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。<br>下面是一些常见的参数。</p>
<blockquote>
<ul>
<li>?limit=10：指定返回记录的数量</li>
<li>?offset=10：指定返回记录的开始位置。</li>
<li>?page=2&amp;per_page=100：指定第几页，以及每页的记录数。</li>
<li>?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</li>
<li>?animal_type_id=1：指定筛选条件</li>
</ul>
</blockquote>
<p>参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /users/ID/address 与 GET /address?user_id=ID 的含义是相同的。</p>
</blockquote>
<h2 id="状态码（Status-Codes）"><a href="#状态码（Status-Codes）" class="headerlink" title="状态码（Status Codes）"></a>状态码（Status Codes）</h2><blockquote>
<p>服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。</p>
<blockquote>
<ul>
<li>200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</li>
<li>201 CREATED - [POST/PUT]：用户新建或修改数据成功。</li>
<li>202 Accepted - [* ]：表示一个请求已经进入后台排队（异步任务）</li>
<li>204 NO CONTENT - [DELETE/PATCH]：服务器成功处理了请求,但不需要返回任何实体内容。</li>
<li>400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。</li>
<li>401 Unauthorized - [* ]：表示用户没有权限（令牌、用户名、密码错误）。</li>
<li>403 Forbidden - [* ] 表示用户得到授权（与401错误相对），但是访问是被禁止的。</li>
<li>404 NOT FOUND - [* ]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</li>
<li>406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。</li>
<li>410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。</li>
<li>422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。</li>
<li>500 INTERNAL SERVER ERROR - [* ]：服务器发生错误，用户将无法判断发出的请求是否成功。</li>
</ul>
</blockquote>
<p>状态码的完全列表参见<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html" target="_blank" rel="external">这里</a>。</p>
</blockquote>
<h2 id="错误处理（Error-handling）"><a href="#错误处理（Error-handling）" class="headerlink" title="错误处理（Error handling）"></a>错误处理（Error handling）</h2><blockquote>
<p>如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。</p>
<pre><code>{
  error: &quot;Invalid API key&quot;
}
</code></pre></blockquote>
<h2 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h2><blockquote>
<p>针对不同操作，服务器向用户返回的结果应该符合以下规范。</p>
<blockquote>
<ul>
<li>GET /collection：返回资源对象的列表（数组）</li>
<li>GET /collection/resource：返回单个资源对象</li>
<li>POST /collection：返回新生成的资源对象</li>
<li>PUT /collection/resource：返回完整的资源对象</li>
<li>PATCH /collection/resource：返回一个空文档</li>
<li>DELETE /collection/resource：返回一个空文档</li>
</ul>
</blockquote>
</blockquote>
<h2 id="Hypermedia-API"><a href="#Hypermedia-API" class="headerlink" title="Hypermedia API"></a>Hypermedia API</h2><blockquote>
<p>RESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。<br>比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。</p>
<pre><code>{
  &quot;link&quot;: {
    &quot;rel&quot;:   &quot;collection https://www.example.com/users&quot;,
    &quot;href&quot;:  &quot;https://api.example.com/users&quot;,
    &quot;title&quot;: &quot;List of users&quot;,
    &quot;type&quot;:  &quot;application/vnd.yourformat+json&quot;
  }
}
</code></pre><p>上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。<br>Hypermedia API的设计被称为<a href="https://en.wikipedia.org/wiki/HATEOAS" target="_blank" rel="external">HATEOAS</a>。Github的API就是这种设计，访问api.github.com会得到一个所有可用API的网址列表。</p>
<pre><code>{
  &quot;current_user_url&quot;: &quot;https://api.github.com/user&quot;,
  &quot;authorizations_url&quot;: &quot;https://api.github.com/authorizations&quot;,
  // ...
}
</code></pre><p>从上面可以看到，如果想获取当前用户的信息，应该去访问api.github.com/user，然后就得到了下面结果。</p>
<pre><code>{
  &quot;message&quot;: &quot;Requires authentication&quot;,
  &quot;documentation_url&quot;: &quot;https://developer.github.com/v3&quot;
}
</code></pre><p>上面代码表示，服务器给出了提示信息，以及文档的网址。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;协议&quot;&gt;&lt;a href=&quot;#协议&quot; class=&quot;headerlink&quot; title=&quot;协议&quot;&gt;&lt;/a&gt;协议&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;API与用户的通信协议，总是使用HTTPs协议。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;域名&quot;&gt;&lt;a
    
    </summary>
    
      <category term="架构" scheme="http://donjote.github.io/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="架构" scheme="http://donjote.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="Restful" scheme="http://donjote.github.io/tags/Restful/"/>
    
  </entry>
  
  <entry>
    <title>Git使用简介</title>
    <link href="http://donjote.github.io/2017/08/31/git/"/>
    <id>http://donjote.github.io/2017/08/31/git/</id>
    <published>2017-08-30T16:00:00.000Z</published>
    <updated>2018-08-03T02:59:35.901Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>Git是一款免费、开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理</p>
</blockquote>
<h2 id="git和svn的差异"><a href="#git和svn的差异" class="headerlink" title="git和svn的差异"></a>git和svn的差异</h2><blockquote>
<p>git和svn最大的差异在于git是分布式的管理方式而svn是集中式的管理方式。</p>
</blockquote>
<h3 id="集中式管理"><a href="#集中式管理" class="headerlink" title="集中式管理"></a>集中式管理</h3><blockquote>
<ul>
<li>集中式管理的工作流程图：<blockquote>
<p><img src="/2017/08/31/git/1.png" alt="集中式管理的工作流程图"></p>
</blockquote>
</li>
</ul>
<p>&emsp;&emsp;集中式代码管理的核心是服务器，所有开发者在开始新一天的工作之前必须从服务器获取代码，然后开发，最后解决冲突，提交。所有的版本信息都放在服务器上。如果脱离了服务器，开发者基本上是不可以工作。下面举例说明：</p>
<p><font color="red"> <strong>开始新一天的工作：</strong></font></p>
<ol>
<li>从服务器下载项目组最新代码。</li>
<li>进入自己的分支，进行工作，每隔1个小时向服务器自己的分支提交一次代码（很多人都有这个习惯。因为有时候自己对代码改来改去，最后又想还原到前一个小时的版本，或者看看前一个小时自己修改了哪些代码，就需要这样做了）。</li>
<li>下班时间快到了，把自己的分支合并到服务器主分支上，一天的工作完成，并反映给服务器。<br>这就是经典的svn工作流程，从流程上看，有不少缺点，但也有优点。</li>
</ol>
<ul>
<li><strong>缺点：</strong></li>
</ul>
<ol>
<li>服务器压力太大，数据库容量暴增。</li>
<li>如果不能连接到服务器上，基本上不可以工作，看上面第二步，如果服务器不能连接上，就不能提交，还原，对比等等。</li>
<li>不适合开源开发（开发人数非常非常多，但是Google app engine就是用svn的）。但是一般集中式管理的有非常明确的权限管理机制（例如分支访问限制），可以实现分层管理，从而很好的解决开发人数众多的问题。</li>
</ol>
<ul>
<li><strong>优点：</strong></li>
</ul>
<ol>
<li>管理方便，逻辑明确，符合一般人思维习惯。</li>
<li>易于管理，集中式服务器更能保证安全性。</li>
<li>代码一致性非常高。</li>
<li>适合开发人数不多的项目开发。</li>
<li>大部分软件配置管理的大学教材都是使用svn 和vss。</li>
</ol>
</blockquote>
<h3 id="分布式管理"><a href="#分布式管理" class="headerlink" title="分布式管理"></a>分布式管理</h3><blockquote>
<ul>
<li>分布式管理的工作流程图：<blockquote>
<p><img src="/2017/08/31/git/2.png" alt="分布式管理的工作流程图"></p>
</blockquote>
</li>
</ul>
<p>&emsp;&emsp;分布式和集中式的最大区别在于开发者可以在本地提交。每个开发者机器上都有一个服务器的数据库。<br>&emsp;&emsp;上图就是经典的git开发过程。步骤如下：</p>
<ul>
<li><strong>一般开发者的角度：</strong></li>
</ul>
<ol>
<li>从服务器上克隆数据库（包括代码和版本信息）到单机上。</li>
<li>在自己的机器上创建分支，修改代码。</li>
<li>在单机上自己创建的分支上提交代码。</li>
<li>在单机上合并分支。</li>
<li>新建一个分支，把服务器上最新版的代码fetch下来，然后跟自己的主分支合并。</li>
<li>生成补丁（patch），把补丁发送给主开发者。</li>
<li>看主开发者的反馈，如果主开发者发现两个一般开发者之间有冲突（他们之间可以合作解决的冲突），就会要求他们先解决冲突，然后再由其中一个人提交。如果主开发者可以自己解决，或者没有冲突，就通过。</li>
<li>一般开发者之间解决冲突的方法，开发者之间可以使用pull命令解决冲突，解决完冲突之后再向主开发者提交补丁。</li>
</ol>
<ul>
<li><strong>主开发者的角度（假设主开发者不用开发代码）：</strong></li>
</ul>
<ol>
<li>查看邮件或者通过其它方式查看一般开发者的提交状态。</li>
<li>打上补丁，解决冲突（可以自己解决，也可以要求开发者之间解决以后再重新提交，如果是开源项目，还要决定哪些补丁可用，哪些不用）。</li>
<li>向公共服务器提交结果，然后通知所有开发人员。</li>
</ol>
<ul>
<li><strong>优点：</strong></li>
</ul>
<ol>
<li>适合分布式开发，强调个体。</li>
<li>公共服务器压力和数据量都不会太大。</li>
<li>速度快、灵活。</li>
<li>任意两个开发者之间可以很容易的解决冲突。</li>
</ol>
<ul>
<li><strong>缺点：</strong></li>
</ul>
<ol>
<li>资料少（起码中文资料很少）。</li>
<li>学习周期相对而言比较长。</li>
<li>不符合常规思维。</li>
<li>代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有代码和版本信息。</li>
</ol>
</blockquote>
<h2 id="git常用命令介绍"><a href="#git常用命令介绍" class="headerlink" title="git常用命令介绍"></a>git常用命令介绍</h2><blockquote>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>git init　</td>
<td>创建一个数据库</td>
</tr>
<tr>
<td>git clone</td>
<td>复制一个数据到制定文件夹</td>
</tr>
<tr>
<td>git add 和git commit</td>
<td>把想提交的文件add上，然后commit这些文件到本地数据库。</td>
</tr>
<tr>
<td>git pull</td>
<td>从服务器下载数据库，并跟自己的数据库合并。</td>
</tr>
<tr>
<td>git fetch</td>
<td>从服务器下载数据库，并放到新分支，不跟自己的数据库合并。</td>
</tr>
<tr>
<td>git whatchanged</td>
<td>查看两个分支的变化</td>
</tr>
<tr>
<td>git branch</td>
<td>创建分支，查看分支，删除分支</td>
</tr>
<tr>
<td>git checkout</td>
<td>切换分支</td>
</tr>
<tr>
<td>git merge</td>
<td>合并分支，把目标分支合并到当前分支</td>
</tr>
<tr>
<td>git config</td>
<td>配置相关信息，例如email和name</td>
</tr>
<tr>
<td>git log</td>
<td>查看版本历史</td>
</tr>
<tr>
<td>git show</td>
<td>查看版本号对于版本的历史，如果参数是HEAD查看最新版本。</td>
</tr>
<tr>
<td>git tag</td>
<td>标定版本号</td>
</tr>
<tr>
<td>git reset</td>
<td>恢复到之前的版本 <br>–mixed是git-reset的默认选项，它的作用是重置索引内容，将其定位到指定的项目版本，而不改变你的工作树中的所有内容，只是提示你有哪些文件还未更新。<br>–soft选项既不触动索引的位置，也不改变工作树中的任何内容。该选项会保留你在工作树中的所有更新并使之处于待提交状态。相当于在<br>–mixed基础上加上git add。 –hard 把整个目录还原到一个版本，包括所有文件。</td>
</tr>
<tr>
<td>git push</td>
<td>向其他数据库推送自己的数据库</td>
</tr>
<tr>
<td>git status</td>
<td>显示当前的状态</td>
</tr>
<tr>
<td>git mv</td>
<td>重命名文件或者文件夹</td>
</tr>
<tr>
<td>git rm</td>
<td>删除文件或者文件夹</td>
</tr>
<tr>
<td>git help</td>
<td>查看帮助，还有几个无关紧要的命令，请自己查看帮助。</td>
</tr>
</tbody>
</table>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Git是一款免费、开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理&lt;/p&gt;
&lt;/bloc
    
    </summary>
    
      <category term="架构" scheme="http://donjote.github.io/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="Git" scheme="http://donjote.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>TCC柔性事务</title>
    <link href="http://donjote.github.io/2017/08/30/transaction_tcc/"/>
    <id>http://donjote.github.io/2017/08/30/transaction_tcc/</id>
    <published>2017-08-29T16:00:00.000Z</published>
    <updated>2018-08-03T02:59:35.917Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>&emsp;&emsp;分布式事务是一个绕不过去的挑战！微服务架构本质上就是分布式服务化架构，微服务架构的流行，让分布式事务问题日益突出！尤其是在订单业务、资金业务等系统核心业务流程中，一定要有可靠的分布式事务解决方案来保证业务数据的可靠性和准确性。</p>
<h2 id="TCC事务机制简介"><a href="#TCC事务机制简介" class="headerlink" title="TCC事务机制简介"></a>TCC事务机制简介</h2><p>&emsp;&emsp;关于TCC（Try-Confirm-Cancel）的概念，最早是由Pat Helland于2007年发表的一篇名为《Life beyond Distributed Transactions:an Apostate’s Opinion》的论文提出。在该论文中，TCC还是以Tentative-Confirmation-Cancellation作为名称；正式以Try-Confirm-Cancel作为名称的，可能是Atomikos（Gregor Hohpe所著书籍《Enterprise Integration Patterns》中收录了关于TCC的介绍，提到了Atomikos的Try-Confirm-Cancel，并认为二者是相似的概念）。</p>
<p>&emsp;&emsp;国内最早关于TCC的报道，应该是InfoQ上对阿里程立博士的一篇采访。经过程博士的这一次传道之后，TCC在国内逐渐被大家广为了解并接受。相应的实现方案和开源框架也先后被发布出来。</p>
<p>&emsp;&emsp;TCC事务机制相对于传统事务机制（X/Open XA），其特征在于它不依赖资源管理器(RM)对XA的支持，而是通过对（由业务系统提供的）业务逻辑的调度来实现分布式事务。对于业务系统中一个特定的业务逻辑S，其对外提供服务时，必须接受一些不确定性，即对业务逻辑执行的一次调用仅是一个临时性操作，调用它的消费方服务M保留了后续的取消权。如果M认为全局事务应该rollback，它会要求取消之前的临时性操作，这就对应S的一个取消操作。而当M认为全局事务应该commit时，它会放弃之前临时性操作的取消权，这对应S的一个确认操作。 每一个初步操作，最终都会被确认或取消。因此，针对一个具体的业务服务，TCC事务机制需要业务系统提供三段业务逻辑：初步操作Try、确认操作Confirm、取消操作Cancel。</p>
<hr>
<p><font color="red">1. 初步操作（Try）</font><br>&emsp;&emsp;TCC事务机制中的业务逻辑（Try），从执行阶段来看，与传统事务机制中业务逻辑相同。但从业务角度来看，是不一样的。TCC机制中的Try仅是一个初步操作，它和后续的次确认一起才能真正构成一个完整的业务逻辑。因此，可以认为[传统事务机制]的业务逻辑 = [TCC事务机制]的初步操作（Try） + [TCC事务机制]的确认逻辑（Confirm）。TCC机制将传统事务机制中的业务逻辑一分为二，拆分后保留的部分即为初步操作（Try）；而分离出的部分即为确认操作（Confirm），被延迟到事务提交阶段执行。<br>TCC事务机制以初步操作（Try）为中心，确认操作（Confirm）和取消操作（Cancel）都是围绕初步操作（Try）而展开。因此，Try阶段中的操作，其保障性是最好的，即使失败，仍然有取消操作（Cancel）可以将其不良影响进行回撤。</p>
<p><font color="red">2. 确认操作（Confirm）</font><br>&emsp;&emsp;确认操作（Confirm）是对初步操作（Try）的一个补充。当TCC事务管理器认为全局事务可以正确提交时，就会逐个执行初步操作（Try）指定的确认操作（Confirm），将初步操作（Try）未完成的事项最终完成。</p>
<p><font color="red">3. 取消操作（Cancel）</font><br>&emsp;&emsp;取消操作（Cancel）是对初步操作（Try）的一个回撤。当TCC事务管理器认为全局事务不能正确提交时，就会逐个执行初步操作（Try）指定的取消操作（Cancel），将初步操作（Try）已完成的事项全部撤回。</p>
</blockquote>
<h2 id="支付宝运营架构中柔性事务"><a href="#支付宝运营架构中柔性事务" class="headerlink" title="支付宝运营架构中柔性事务"></a>支付宝运营架构中柔性事务</h2><blockquote>
<ul>
<li><font color="red">柔性事务：业务活动</font><blockquote>
<p><img src="/2017/08/30/transaction_tcc/1.jpg" alt="柔性事务：业务活动"></p>
</blockquote>
</li>
<li><font color="red">柔性事务：业务活动举例</font><br><img src="/2017/08/30/transaction_tcc/2.jpg" alt="柔性事务：业务活动举例"></li>
<li><font color="red">柔性事务：TCC型业务服务</font><blockquote>
<p><img src="/2017/08/30/transaction_tcc/3.jpg" alt="柔性事务：TCC型业务服务"></p>
</blockquote>
</li>
<li><font color="red">柔性事务：TCC服务事务协调模式</font><blockquote>
<p><img src="/2017/08/30/transaction_tcc/4.jpg" alt="柔性事务：TCC服务事务协调模式"><br>&emsp;&emsp;可以看出，柔性事务（<a href="http://localhost:4000/2017/08/25/cap/#BASE" target="_blank" rel="external">遵循BASE理论</a>）是指相对于<a href="http://localhost:4000/2017/07/08/transaction/#事务的-ACID" target="_blank" rel="external">ACID刚性事务</a>而言的。</p>
</blockquote>
</li>
</ul>
<p>&emsp;&emsp;支付宝所说的柔性事务分为：两阶段型、补偿型、异步确保型、最大努力通知型几种。由于支付宝整个架构是SOA架构，因此传统单机环境下数据库的ACID事务满足了分布式环境下的业务需要，以上几种事务类似就是针对分布式环境下业务需要设定的。其中：<br>1、两阶段型：就是分布式事务两阶段提交，对应技术上的XA、JTA/JTS。这是分布式环境下事务处理的典型模式。<br>2、补偿型：TCC型事务（Try/Confirm/Cancel）可以归为补偿型。补偿型的例子，在一个长事务（long-running）中，一个由两台服务器一起参与的事务，服务器A发起事务，服务器B参与事务，B的事务需要人工参与，所以处理时间可能很长。如果按照ACID的原则，要保持事务的隔离性、一致性，服务器A中发起的事务中使用到的事务资源将会被锁定，不允许其他应用访问到事务过程中的中间结果，直到整个事务被提交或者回滚。这就造成事务A中的资源被长时间锁定，系统的可用性将不可接受。WS-BusinessActivity提供了一种基于补偿的long-running的事务处理模型。还是上面的例子，服务器A的事务如果执行顺利，那么事务A就先行提交，如果事务B也执行顺利，则事务B也提交，整个事务就算完成。但是如果事务B执行失败，事务B本身回滚，这时事务A已经被提交，所以需要执行一个补偿操作，将已经提交的事务A执行的操作作反操作，恢复到未执行前事务A的状态。这样的SAGA事务模型，是牺牲了一定的隔离性和一致性的，但是提高了long-running事务的可用性。例子来源：OASIS的WS-BusinessActivity文档<br>3、异步确保型将一些同步阻塞的事务操作变为异步的操作，避免对数据库事务的争用，典型例子是热点账户异步记账、批量记账的处理。<br>4、最大努力型PPT中提到的例子交易的消息通知（例如商户交易结果通知重试、补单重试）</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p> <a href="https://wenku.baidu.com/view/be946bec0975f46527d3e104.html" target="_blank" rel="external">大规模SOA系统中的分布事务处事</a><br> <a href="https://wenku.baidu.com/view/d1bbd25877232f60ddcca1d9.html" target="_blank" rel="external">支付宝架构与技术</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;分布式事务是一个绕不过去的挑战！微服务架构本质上就是分布式服务化架构，微服务架构的流行，让分布式事务问题日益突出！尤其是在订单业务、资金业务等系统核心业务流程中，一定要有可靠的分布式事务解决方案来保证业务数据的可靠性和准确性
    
    </summary>
    
      <category term="架构" scheme="http://donjote.github.io/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="架构" scheme="http://donjote.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="事务" scheme="http://donjote.github.io/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>docker简介</title>
    <link href="http://donjote.github.io/2017/08/30/docker/"/>
    <id>http://donjote.github.io/2017/08/30/docker/</id>
    <published>2017-08-29T16:00:00.000Z</published>
    <updated>2018-08-03T02:59:35.878Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker"></a>什么是Docker</h2><blockquote>
<p>&emsp;&emsp;Docker 是一个开源项目，诞生于 2013 年初，最初是 dotCloud 公司内部的一个业余项目。它基于 Google 公司推出的 Go 语言实现。 它基于Linux容器技术（LXC），Namespace(命名空间)，Cgroup(控制组)，UnionFS（联合文件系统）等技术。项目后来加入了 Linux 基金会，遵从了 Apache 2.0 协议，项目代码在 GitHub 上进行维护。   </p>
<p><strong><font color="red"> namespace（命名空间）：</font></strong> 命名空间是 Linux 内核一个强大的特性。每个容器都有自己单独的名字空间，运行在其中的应用都像是在独立的操作系统中运行一样。名字空间保证了容器之间彼此互不影响。docker实际上一个进程容器，它通过namespace实现了进程和进程所使用的资源的隔离。使不同的进程之间彼此不可见。我们可以把Docker容器想像成进程＋操作系统除内核之外的一套软件。</p>
<p><strong><font color="red"> cgroup（控制组）：</font></strong> 是 Linux 内核的一个特性，主要用来对共享资源进行隔离、限制、审计等。只有能控制分配到容器的资源，才能避免当多个容器同时运行时的对系统资源的竞争。控制组技术最早是由 Google 的程序员 2006 年起提出，Linux 内核自 2.6.24 开始支持。控制组可以提供对容器的内存、CPU、磁盘 IO 等资源的限制和审计管理。</p>
<p><strong><font color="red"> UnionFS（联合文件系统）：</font></strong> Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对 文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。另外，不同 Docker 容器就可以共享一些基础的文件系统层，同时再加上自己独有的改动层，大大提高了存储的效率。Docker 中使用的 AUFS（AnotherUnionFS）就是一种 Union FS。 AUFS 支持为每一个成员目录（类似 Git 的分支）设定只读（readonly）、读写（readwrite）和写出（whiteout-able）权限, 同时 AUFS 里有一个类似分层的概念, 对只读权限的分支可以逻辑上进行增量地修改(不影响只读部分的)。</p>
</blockquote>
<h2 id="快速理解Docker"><a href="#快速理解Docker" class="headerlink" title="快速理解Docker"></a>快速理解Docker</h2><blockquote>
<p>&emsp;&emsp;拿现实世界中货物的运输作类比, 为了解决各种型号规格尺寸的货物在各种运输工具上进行运输的问题,我们发明了集装箱<br><img src="/2017/08/30/docker/1.jpg" alt="集装箱"><br>&emsp;&emsp;docker的初衷也就是将各种应用程序和他们所依赖的运行环境打包成标准的Container/image,进而发布到不同的平台上运行<br><img src="/2017/08/30/docker/2.jpg" alt="docker"><br>&emsp;&emsp;从理论上说这一概念并不新鲜, 各种虚拟机Image也起着类似的作用<br>&emsp;&emsp;Docker container和普通的虚拟机Image相比, 最大的区别是它并不包含操作系统内核.<br><img src="/2017/08/30/docker/3.jpg" alt="docker"><br>&emsp;&emsp;普通虚拟机将整个操作系统运行在虚拟的硬件平台上, 进而提供完整的运行环境供应用程序运行, 而Docker则直接在宿主平台上加载运行应用程序. 本质上他在底层使用LXC启动一个Linux Container,通过cgroup等机制对不同的container内运行的应用程序进行隔离,权限管理和quota分配等</p>
<p>&emsp;&emsp;每个container拥有自己独立的各种命名空间(亦即资源)包括:PID 进程, MNT 文件系统, NET 网络, IPC , UTS 主机名 等</p>
</blockquote>
<h2 id="为什么要使用Docker"><a href="#为什么要使用Docker" class="headerlink" title="为什么要使用Docker"></a>为什么要使用Docker</h2><blockquote>
<p>&emsp;&emsp;作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。</p>
<p>&emsp;&emsp;首先，Docker 容器的启动可以在秒级实现，这相比传统的虚拟机方式要快得多。 其次，Docker 对系统资源的利用率很高，一台主机上可以同时运行数千个 Docker 容器。</p>
<p>&emsp;&emsp;容器除了运行其中应用外，基本不消耗额外的系统资源，使得应用的性能很高，同时系统的开销尽量小。传统虚拟机方式运行 10 个不同的应用就要起 10 个虚拟机，而Docker 只需要启动 10 个隔离的应用即可。</p>
<p>&emsp;&emsp;具体说来，Docker 在如下几个方面具有较大的优势。</p>
<ul>
<li>更快速的交付和部署<br>&emsp;&emsp;对开发和运维（devop）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。<br>&emsp;&emsp;开发者可以使用一个标准的镜像来构建一套开发容器，开发完成之后，运维人员可以直接使用这个容器来部署代码。 Docker 可以快速创建容器，快速迭代应用程序，并让整个过程全程可见，使团队中的其他成员更容易理解应用程序是如何创建和工作的。 Docker 容器很轻很快！容器的启动时间是秒级的，大量地节约开发、测试、部署的时间。</li>
<li>更高效的虚拟化<br>&emsp;&emsp;Docker 容器的运行不需要额外的 hypervisor 支持，它是内核级的虚拟化，因此可以实现更高的性能和效率。</li>
<li>更轻松的迁移和扩展<br>&emsp;&emsp;Docker 容器几乎可以在任意的平台上运行，包括物理机、虚拟机、公有云、私有云、个人电脑、服务器等。 这种兼容性可以让用户把一个应用程序从一个平台直接迁移到另外一个。</li>
<li>更简单的管理<br>&emsp;&emsp;使用 Docker，只需要小小的修改，就可以替代以往大量的更新工作。所有的修改都以增量的方式被分发和更新，从而实现自动化并且高效的管理。</li>
</ul>
</blockquote>
<h2 id="Docker基本概念"><a href="#Docker基本概念" class="headerlink" title="Docker基本概念"></a>Docker基本概念</h2><blockquote>
<ul>
<li>镜像（Image）<br>&emsp;&emsp;Docker的镜像概念类似于虚拟机里的镜像，是一个只读的模板，一个独立的文件系统，包括运行容器所需的数据，可以用来创建新的容器。镜像可以基于Dockerfile构建，Dockerfile是一个描述文件，里面包含若干条命令，每条命令都会对基础文件系统创建新的层次结构。用户可以通过编写Dockerfile创建新的镜像，也可以直接从类似github的Docker Hub上下载镜像使用。</li>
<li>容器（Container）<br>&emsp;&emsp;Docker容器是由Docker镜像创建的运行实例。Docker容器类似虚拟机，可以支持的操作包括启动，停止，删除等。每个容器间是相互隔离的，但隔离的效果比不上虚拟机。容器中会运行特定的应用，包含特定应用的代码及所需的依赖文件。</li>
</ul>
<p>&emsp;&emsp;在Docker容器中，每个容器之间的隔离使用Linux的 CGroups 和 Namespaces技术实现的。其中 CGroups 对CPU，内存，磁盘等资源的访问限制，Namespaces 提供了环境的隔离。</p>
<ul>
<li>仓库（Repository）<br>&emsp;&emsp;Docker仓库相当于一个 github 上的代码库。</li>
</ul>
<p>&emsp;&emsp;Docker 仓库是用来包含镜像的位置，Docker提供一个注册服务器（Registry）来保存多个仓库，每个仓库又可以包含多个具备不同tag的镜像。Docker运行中使用的默认仓库是 Docker Hub 公共仓库。</p>
<p>&emsp;&emsp;仓库支持的操作类似 git，创建了新的镜像后，我们可以 push 提交到仓库，也可以从指定仓库 pull 拉取镜像到本地。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是Docker&quot;&gt;&lt;a href=&quot;#什么是Docker&quot; class=&quot;headerlink&quot; title=&quot;什么是Docker&quot;&gt;&lt;/a&gt;什么是Docker&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;Docker 是一个开源项目，诞生
    
    </summary>
    
      <category term="容器" scheme="http://donjote.github.io/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="docker" scheme="http://donjote.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>thymeleaf 使用</title>
    <link href="http://donjote.github.io/2017/08/25/thymeleaf/"/>
    <id>http://donjote.github.io/2017/08/25/thymeleaf/</id>
    <published>2017-08-24T16:00:00.000Z</published>
    <updated>2018-08-03T02:59:35.916Z</updated>
    
    <content type="html"><![CDATA[<h2 id="thymeleaf介绍"><a href="#thymeleaf介绍" class="headerlink" title="thymeleaf介绍"></a>thymeleaf介绍</h2><blockquote>
<p>简单说， Thymeleaf 是一个跟 Velocity、FreeMarker 类似的模板引擎，它可以完全替代 JSP 。相较与其他的模板引擎，它有如下三个极吸引人的特点：</p>
<ul>
<li>Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。这是由于它支持 html 原型，然后在 html 标签里增加额外的属性来达到模板+数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。</li>
<li>Thymeleaf 开箱即用的特性。它提供标准和spring标准两种方言，可以直接套用模板实现JSTL、 OGNL表达式效果，避免每天套模板、该jstl、改标签的困扰。同时也可以扩展和创建自定义的方言。</li>
<li>Thymeleaf 提供spring标准方言和一个与 SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。</li>
</ul>
</blockquote>
<h2 id="标准表达式语法"><a href="#标准表达式语法" class="headerlink" title="标准表达式语法"></a>标准表达式语法</h2><blockquote>
<p>分为四类：</p>
<ol>
<li>变量表达式</li>
<li>选择或星号表达式</li>
<li>文字国际化表达式</li>
<li>URL表达式</li>
</ol>
</blockquote>
<h3 id="变量表达式"><a href="#变量表达式" class="headerlink" title="变量表达式"></a>变量表达式</h3><blockquote>
<p>变量表达式即OGNL表达式或Spring EL表达式(在Spring术语中也叫model attributes)。如下所示：</p>
<pre><code>${session.user.name}
</code></pre><p>它们将以HTML标签的一个属性来表示：</p>
<pre><code>&lt;span th:text=&quot;${book.author.name}&quot;&gt;&lt;/span&gt;
&lt;li th:each=&quot;book : ${books}&quot;&gt;&lt;/li&gt;
</code></pre></blockquote>
<h3 id="选择-星号-表达式"><a href="#选择-星号-表达式" class="headerlink" title="选择(星号)表达式"></a>选择(星号)表达式</h3><blockquote>
<p>选择表达式很像变量表达式，不过它们用一个预先选择的对象来代替上下文变量容器(map)来执行，如下：</p>
<pre><code>* {customer.name}
</code></pre><p>被指定的object由th:object属性定义：</p>
<pre><code>&lt;div th:object=&quot;${book}&quot;&gt;  
  ...  
  &lt;span th:text=&quot;* {title}&quot;&gt;...&lt;/span&gt;  
  ...  
&lt;/div&gt;  
</code></pre></blockquote>
<h3 id="文字国际化表达式"><a href="#文字国际化表达式" class="headerlink" title="文字国际化表达式"></a>文字国际化表达式</h3><blockquote>
<p>文字国际化表达式允许我们从一个外部文件获取区域文字信息(.properties)，用Key索引Value，还可以提供一组参数(可选).</p>
<pre><code>#{main.title}  
#{message.entrycreated(${entryId})}  
</code></pre><p>可以在模板文件中找到这样的表达式代码：</p>
<pre><code>&lt;table&gt;  
  ...  
  &lt;th th:text=&quot;#{header.address.city}&quot;&gt;...&lt;/th&gt;  
  &lt;th th:text=&quot;#{header.address.country}&quot;&gt;...&lt;/th&gt;  
  ...  
&lt;/table&gt;  
</code></pre></blockquote>
<h3 id="URL表达式"><a href="#URL表达式" class="headerlink" title="URL表达式"></a>URL表达式</h3><blockquote>
<p>URL表达式指的是把一个有用的上下文或回话信息添加到URL，这个过程经常被叫做URL重写。</p>
<pre><code>@{/order/list}
</code></pre><p>URL还可以设置参数：</p>
<pre><code>@{/order/details(id=${orderId})}
</code></pre><p>相对路径：</p>
<pre><code>@{../documents/report}
</code></pre><p>让我们看这些表达式：</p>
<pre><code>&lt;form th:action=&quot;@{/createOrder}&quot;&gt;  
&lt;a href=&quot;main.html&quot; th:href=&quot;@{/main}&quot;&gt;
</code></pre></blockquote>
<h3 id="变量表达式和星号表达有什么区别吗？"><a href="#变量表达式和星号表达有什么区别吗？" class="headerlink" title="变量表达式和星号表达有什么区别吗？"></a>变量表达式和星号表达有什么区别吗？</h3><blockquote>
<p>如果不考虑上下文的情况下，两者没有区别；星号语法评估在选定对象上表达，而不是整个上下文<br>什么是选定对象？就是父标签的值，如下：</p>
<pre><code>&lt;div th:object=&quot;${session.user}&quot;&gt;
  &lt;p&gt;Name: &lt;span th:text=&quot;* {firstName}&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt;
  &lt;p&gt;Surname: &lt;span th:text=&quot;* {lastName}&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt;
  &lt;p&gt;Nationality: &lt;span th:text=&quot;* {nationality}&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt;
&lt;/div&gt;
</code></pre><p>这是完全等价于：</p>
<pre><code>&lt;div th:object=&quot;${session.user}&quot;&gt;
    &lt;p&gt;Name: &lt;span th:text=&quot;${session.user.firstName}&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt;
    &lt;p&gt;Surname: &lt;span th:text=&quot;${session.user.lastName}&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt;
    &lt;p&gt;Nationality: &lt;span th:text=&quot;${session.user.nationality}&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt;
&lt;/div&gt;
</code></pre><p>当然，美元符号和星号语法可以混合使用：</p>
<pre><code>&lt;div th:object=&quot;${session.user}&quot;&gt;
    &lt;p&gt;Name: &lt;span th:text=&quot;* {firstName}&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt;
    &lt;p&gt;Surname: &lt;span th:text=&quot;${session.user.lastName}&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt;
    &lt;p&gt;Nationality: &lt;span th:text=&quot;* {nationality}&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt;
&lt;/div&gt;
</code></pre></blockquote>
<h2 id="表达式支持的语法"><a href="#表达式支持的语法" class="headerlink" title="表达式支持的语法"></a>表达式支持的语法</h2><blockquote>
<h3 id="字面（Literals）"><a href="#字面（Literals）" class="headerlink" title="字面（Literals）"></a>字面（Literals）</h3><ul>
<li>文本文字（Text literals）: ‘one text’, ‘Another one!’,…</li>
<li>数字文本（Number literals）: 0, 34, 3.0, 12.3,…</li>
<li>布尔文本（Boolean literals）: true, false</li>
<li>空（Null literal）: null</li>
<li>文字标记（Literal tokens）: one, sometext, main,…<h3 id="文本操作（Text-operations）"><a href="#文本操作（Text-operations）" class="headerlink" title="文本操作（Text operations）"></a>文本操作（Text operations）</h3><ul>
<li>字符串连接(String concatenation): +</li>
</ul>
</li>
<li>文本替换（Literal substitutions）: |The name is ${name}|<h3 id="算术运算（Arithmetic-operations）"><a href="#算术运算（Arithmetic-operations）" class="headerlink" title="算术运算（Arithmetic operations）"></a>算术运算（Arithmetic operations）</h3></li>
<li>二元运算符（Binary operators）: +, -, * , /, %</li>
<li>减号（单目运算符）Minus sign (unary operator): -<h3 id="布尔操作（Boolean-operations）"><a href="#布尔操作（Boolean-operations）" class="headerlink" title="布尔操作（Boolean operations）"></a>布尔操作（Boolean operations）</h3></li>
<li>二元运算符（Binary operators）:and, or</li>
<li>布尔否定（一元运算符）Boolean negation (unary operator):!, not<h3 id="比较和等价-Comparisons-and-equality"><a href="#比较和等价-Comparisons-and-equality" class="headerlink" title="比较和等价(Comparisons and equality)"></a>比较和等价(Comparisons and equality)</h3></li>
<li>比较（Comparators）: &gt;, &lt;, &gt;=, &lt;= (gt, lt, ge, le)</li>
<li>等值运算符（Equality operators）:==, != (eq, ne)<h3 id="条件运算符（Conditional-operators）"><a href="#条件运算符（Conditional-operators）" class="headerlink" title="条件运算符（Conditional operators）"></a>条件运算符（Conditional operators）</h3></li>
<li>If-then: (if) ? (then)</li>
<li>If-then-else: (if) ? (then) : (else)</li>
<li><p>Default: (value) ?: (defaultvalue)</p>
<h3 id="所有这些特征可以被组合并嵌套："><a href="#所有这些特征可以被组合并嵌套：" class="headerlink" title="所有这些特征可以被组合并嵌套："></a>所有这些特征可以被组合并嵌套：</h3><pre><code>&apos;User is of type &apos; + (${user.isAdmin()} ? &apos;Administrator&apos; : (${user.type} ?: &apos;Unknown&apos;))
</code></pre></li>
</ul>
</blockquote>
<h2 id="常用th标签都有那些？"><a href="#常用th标签都有那些？" class="headerlink" title="常用th标签都有那些？"></a>常用th标签都有那些？</h2><blockquote>
<table>
<thead>
<tr>
<th>关键字</th>
<th>功能介绍</th>
<th>案例</th>
</tr>
</thead>
<tbody>
<tr>
<td>th:id</td>
<td>替换id</td>
<td>&lt;input th:id=”‘xxx’ + ${collect.id}”/&gt;</td>
</tr>
<tr>
<td>th:text</td>
<td>文本替换</td>
<td>&lt;p th:text=”${collect.description}”&gt;description<p></p></td>
</tr>
<tr>
<td>th:utext</td>
<td>支持html的文本替换</td>
<td>&lt;p th:utext=”${htmlcontent}”&gt;conten<p></p></td>
</tr>
<tr>
<td>th:object</td>
<td>替换对象</td>
<td>&lt;div th:object=”${session.user}”&gt;</td>
</tr>
<tr>
<td>th:value</td>
<td>属性赋值</td>
<td>&lt;input th:value=”${user.name}” /&gt;</td>
</tr>
<tr>
<td>th:with</td>
<td>变量赋值运算</td>
<td>&lt;div th:with=”isEven=${prodStat.count}%2==0”&gt;</td>
</tr>
<tr>
<td>th:style</td>
<td>设置样式</td>
<td>th:style=”‘display:’ + @{(${sitrue} ? ‘none’ : ‘inline-block’)} + ‘’”</td>
</tr>
<tr>
<td>th:onclick</td>
<td>点击事件</td>
<td>th:onclick=”‘getCollect()’”</td>
</tr>
<tr>
<td>th:each</td>
<td>属性赋值</td>
<td>tr th:each=”user,userStat:${users}”&gt;</td>
</tr>
<tr>
<td>th:if</td>
<td>判断条件</td>
<td>&lt;a th:if=”${userId == collect.userId}” &gt;</td>
</tr>
<tr>
<td>th:unless</td>
<td>和th:if判断相反</td>
<td>&lt;a th:href=”@{/login}” th:unless=${session.user != null}&gt;Login</td>
</tr>
<tr>
<td>th:href</td>
<td>链接地址</td>
<td>&lt;a th:href=”@{/login}” th:unless=${session.user != null}&gt;Login /&gt;</td>
</tr>
<tr>
<td>th:switch</td>
<td>多路选择 配合th:case 使用</td>
<td>&lt;div th:switch=”${user.role}”&gt;</td>
</tr>
<tr>
<td>th:case</td>
<td>th:switch的一个分支</td>
<td>&lt;p th:case=”‘admin’”&gt;User is an administrator<p></p></td>
</tr>
<tr>
<td>th:fragment</td>
<td>布局标签，定义一个代码片段，方便其它地方引用</td>
<td>&lt;div th:fragment=”alert”&gt;</td>
</tr>
<tr>
<td>th:include</td>
<td>布局标签，替换内容到引入的文件</td>
<td>&lt;head th:include=”layout :: htmlhead” th:with=”title=’xx’”&gt; /&gt;</td>
</tr>
<tr>
<td>th:replace</td>
<td>布局标签，替换整个标签到引入的文件</td>
<td>&lt;div th:replace=”fragments/header :: title”&gt;</td>
</tr>
<tr>
<td>th:selected</td>
<td>selected选择框 选中</td>
<td>th:selected=”(${xxx.id} == ${configObj.dd})”</td>
</tr>
<tr>
<td>th:src</td>
<td>图片类地址引入</td>
<td>&lt;img class=”img-responsive” alt=”App Logo” th:src=”@{/img/logo.png}” /&gt;</td>
</tr>
<tr>
<td>th:inline</td>
<td>定义js脚本可以使用变量</td>
<td>&lt;script type=”text/javascript” th:inline=”javascript”&gt;</td>
</tr>
<tr>
<td>th:action</td>
<td>表单提交的地址</td>
<td>&lt;form action=”subscribe.html” th:action=”@{/subscribe}”&gt;</td>
</tr>
<tr>
<td>th:remove</td>
<td>删除某个属性</td>
<td>&lt;tr th:remove=”all”&gt; 1.all:删除包含标签和所有的孩子。</td>
</tr>
<tr>
<td>th:attr</td>
<td>设置标签属性，多个属性可以用逗号分隔</td>
<td>比如 th:attr=”src=@{/image/aa.jpg},title=#{logo}”，此标签不太优雅，一般用的比较少。</td>
</tr>
</tbody>
</table>
<hr>
<p>还有非常多的标签，这里只列出最常用的几个,由于一个标签内可以包含多个th:x属性，其生效的优先级顺序为:<br>include,each,if/unless/switch/case,with,attr/attrprepend/attrappend,value/href,src ,etc,text/utext,fragment,remove。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;thymeleaf介绍&quot;&gt;&lt;a href=&quot;#thymeleaf介绍&quot; class=&quot;headerlink&quot; title=&quot;thymeleaf介绍&quot;&gt;&lt;/a&gt;thymeleaf介绍&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;简单说， Thymeleaf 是一个跟 V
    
    </summary>
    
      <category term="Java" scheme="http://donjote.github.io/categories/Java/"/>
    
    
      <category term="spring boot" scheme="http://donjote.github.io/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>NoSQL 简介</title>
    <link href="http://donjote.github.io/2017/08/25/nosql/"/>
    <id>http://donjote.github.io/2017/08/25/nosql/</id>
    <published>2017-08-24T16:00:00.000Z</published>
    <updated>2018-08-03T02:59:35.911Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是NoSQL"><a href="#什么是NoSQL" class="headerlink" title="什么是NoSQL?"></a>什么是NoSQL?</h2><blockquote>
<p>NoSQL，指的是非关系型的数据库。NoSQL有时也称作Not Only SQL的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称。<br>NoSQL用于超大规模数据的存储。（例如谷歌或Facebook每天为他们的用户收集万亿比特的数据）。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。</p>
</blockquote>
<h2 id="为什么使用NoSQL"><a href="#为什么使用NoSQL" class="headerlink" title="为什么使用NoSQL ?"></a>为什么使用NoSQL ?</h2><blockquote>
<p>今天我们可以通过第三方平台（如：Google,Facebook等）可以很容易的访问和抓取数据。用户的个人信息，社交网络，地理位置，用户生成的数据和用户操作日志已经成倍的增加。我们如果要对这些用户数据进行挖掘，那SQL数据库已经不适合这些应用了, NoSQL数据库的发展也却能很好的处理这些大的数据。<br><img src="/2017/08/25/nosql/1.png" alt="NoSQL"></p>
</blockquote>
<h2 id="RDBMS-vs-NoSQL"><a href="#RDBMS-vs-NoSQL" class="headerlink" title="RDBMS vs NoSQL"></a>RDBMS vs NoSQL</h2><blockquote>
<h3 id="RDBMS"><a href="#RDBMS" class="headerlink" title="RDBMS"></a>RDBMS</h3><ul>
<li>高度组织化结构化数据</li>
<li>结构化查询语言（SQL） (SQL)</li>
<li>数据和关系都存储在单独的表中。</li>
<li>数据操纵语言，数据定义语言</li>
<li>严格的一致性</li>
<li>基础事务<h3 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h3></li>
<li>代表着不仅仅是SQL</li>
<li>没有声明性查询语言</li>
<li>没有预定义的模式</li>
<li>键值对存储，列存储，文档存储，图形数据库</li>
<li>最终一致性，而非ACID属性</li>
<li>非结构化和不可预知的数据</li>
<li>CAP定理</li>
<li>高性能，高可用性和可伸缩性</li>
</ul>
</blockquote>
<h2 id="NoSQL的优点-缺点"><a href="#NoSQL的优点-缺点" class="headerlink" title="NoSQL的优点/缺点"></a>NoSQL的优点/缺点</h2><blockquote>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h3><ul>
<li>高可扩展性</li>
<li>分布式计算</li>
<li>低成本</li>
<li>架构的灵活性，半结构化数据</li>
<li>没有复杂的关系<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点:"></a>缺点:</h3></li>
<li>没有标准化</li>
<li>有限的查询功能（到目前为止）</li>
<li>最终一致是不直观的程序</li>
</ul>
</blockquote>
<h2 id="NoSQL-数据库分类"><a href="#NoSQL-数据库分类" class="headerlink" title="NoSQL 数据库分类"></a>NoSQL 数据库分类</h2><table>
<thead>
<tr>
<th>类型</th>
<th>部分代表</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>列存储</td>
<td>Hbase Cassandra Hypertable</td>
<td>顾名思义，是按列存储数据的。最大的特点是方便存储结构化和半结构化数据，方便做数据压缩，对针对某一列或者某几列的查询有非常大的IO优势。</td>
</tr>
<tr>
<td>文档存储</td>
<td>MongoDB CouchDB</td>
<td>文档存储一般用类似json的格式存储，存储的内容是文档型的。这样也就有有机会对某些字段建立索引，实现关系数据库的某些功能。</td>
</tr>
<tr>
<td>key-value存储</td>
<td>Tokyo Cabinet / Tyrant Berkeley DB MemcacheDB Redis</td>
<td>可以通过key快速查询到其value。一般来说，存储不管value的格式，照单全收。（Redis包含了其他功能）</td>
</tr>
<tr>
<td>图存储</td>
<td>Neo4J FlockDB</td>
<td>图形关系的最佳存储。使用传统关系数据库来解决的话性能低下，而且设计使用不方便。</td>
</tr>
<tr>
<td>对象存储</td>
<td>db4o Versant</td>
<td>通过类似面向对象语言的语法操作数据库，通过对象的方式存取数据。</td>
</tr>
<tr>
<td>xml数据库</td>
<td>Berkeley DB XML BaseX</td>
<td>高效的存储XML数据，并支持XML的内部查询语法，比如XQuery,Xpath。</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是NoSQL&quot;&gt;&lt;a href=&quot;#什么是NoSQL&quot; class=&quot;headerlink&quot; title=&quot;什么是NoSQL?&quot;&gt;&lt;/a&gt;什么是NoSQL?&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;NoSQL，指的是非关系型的数据库。NoSQL有时也称作Not
    
    </summary>
    
      <category term="数据库" scheme="http://donjote.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="NoSQL" scheme="http://donjote.github.io/tags/NoSQL/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB 简介</title>
    <link href="http://donjote.github.io/2017/08/25/mongodb/"/>
    <id>http://donjote.github.io/2017/08/25/mongodb/</id>
    <published>2017-08-24T16:00:00.000Z</published>
    <updated>2018-08-03T02:59:35.910Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是MongoDB"><a href="#什么是MongoDB" class="headerlink" title="什么是MongoDB ?"></a>什么是MongoDB ?</h2><blockquote>
<p>MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。<br>在高负载的情况下，添加更多的节点，可以保证服务器性能。<br>MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。<br>MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。<br><img src="/2017/08/25/mongodb/1.png" alt=""></p>
</blockquote>
<h2 id="MongoDB特点"><a href="#MongoDB特点" class="headerlink" title="MongoDB特点"></a>MongoDB特点</h2><blockquote>
<ol>
<li>支持特别查询<br>在MongoDB中，可以通过字段，范围查询进行搜索，并且还支持正则表达式搜索。</li>
<li>索引<br>可以索引文档中的任何字段。</li>
<li>复制<br>MongoDB支持主从复制。主机可以执行读写操作，从机从主机复制数据，只能用于读取或备份(不写入)</li>
<li>复制数据<br>MongoDB可以在多台服务器上运行。 复制数据以保持系统正常运行，并在硬件故障的情况下保持其运行状态。</li>
<li>负载均衡<br>由于数据放在碎片中，因此具有自动负载平衡配置。</li>
<li>支持映射缩减和聚合工具</li>
<li>使用JavaScript而不是Procedure</li>
<li>它是一个用C++编写的无模式数据库</li>
<li>提供高性能</li>
<li>轻松存储任何大小的文件，而不会使您的堆栈复杂化</li>
<li>在故障的情况下易于管理</li>
<li>它还支持：</li>
</ol>
<ul>
<li>具有动态模式的JSON数据模型</li>
<li>自动分片用于水平可扩展性</li>
<li>内置复制高可用性</li>
</ul>
</blockquote>
<h2 id="MongoDB优点"><a href="#MongoDB优点" class="headerlink" title="MongoDB优点"></a>MongoDB优点</h2><blockquote>
<ul>
<li>MongoDB 的架构较少。它是一个文档数据库，它的一个集合持有不同的文档。</li>
<li>从一个到另一个的文档的数量，内容和大小可能有差异。</li>
<li>MongoDB 中单个对象的结构很清淅。</li>
<li>MongoDB 中没有复杂的连接。</li>
<li>MongoDB 提供深度查询的功能，因为它支持对文档的强大的动态查询。</li>
<li>MongoDB 很容易扩展。</li>
<li>它使用内部存储器来存储工作集，这是其快速访问的原因。</li>
</ul>
</blockquote>
<h2 id="MongoDB的独特功能"><a href="#MongoDB的独特功能" class="headerlink" title="MongoDB的独特功能"></a>MongoDB的独特功能</h2><blockquote>
<ul>
<li>使用方便</li>
<li>重量轻/轻量级</li>
<li>比RDBMS快得多</li>
</ul>
</blockquote>
<h2 id="应该使用MongoDB在哪些场景"><a href="#应该使用MongoDB在哪些场景" class="headerlink" title="应该使用MongoDB在哪些场景"></a>应该使用MongoDB在哪些场景</h2><blockquote>
<ul>
<li>大而复杂的数据</li>
<li>移动和社会基础设施数据</li>
<li>内容管理和交付</li>
<li>用户数据管理</li>
<li>数据中心</li>
</ul>
</blockquote>
<h2 id="MongoDB和RDBMS的性能分析"><a href="#MongoDB和RDBMS的性能分析" class="headerlink" title="MongoDB和RDBMS的性能分析"></a>MongoDB和RDBMS的性能分析</h2><blockquote>
<ul>
<li>在关系数据库(RDBMS)中，表用作存储元素，而在 MongoDB 中使用的是集合。</li>
<li>在RDBMS中有多个模式，在每个模式中，可创建用于存储数据的表，而 MongoDB 是面向文档的数据库，数据是以类似JSON格式的BSON格式编写的存储的。</li>
<li>MongoDB几乎比传统数据库系统快100倍。</li>
</ul>
</blockquote>
<h2 id="MongoDB-应用案例"><a href="#MongoDB-应用案例" class="headerlink" title="MongoDB 应用案例"></a>MongoDB 应用案例</h2><blockquote>
<p>下面列举一些公司MongoDB的实际应用：</p>
<ul>
<li>Craiglist上使用MongoDB的存档数十亿条记录。</li>
<li>FourSquare，基于位置的社交网站，在Amazon EC2的服务器上使用MongoDB分享数据。</li>
<li>Shutterfly，以互联网为基础的社会和个人出版服务，使用MongoDB的各种持久性数据存储的要求。</li>
<li>bit.ly, 一个基于Web的网址缩短服务，使用MongoDB的存储自己的数据。</li>
<li>spike.com，一个MTV网络的联营公司， spike.com使用MongoDB的。</li>
<li>Intuit公司，一个为小企业和个人的软件和服务提供商，为小型企业使用MongoDB的跟踪用户的数据。</li>
<li>sourceforge.net，资源网站查找，创建和发布开源软件免费，使用MongoDB的后端存储。</li>
<li>etsy.com ，一个购买和出售手工制作物品网站，使用MongoDB。</li>
<li>纽约时报，领先的在线新闻门户网站之一，使用MongoDB。</li>
<li>CERN，著名的粒子物理研究所，欧洲核子研究中心大型强子对撞机的数据使用MongoDB。</li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是MongoDB&quot;&gt;&lt;a href=&quot;#什么是MongoDB&quot; class=&quot;headerlink&quot; title=&quot;什么是MongoDB ?&quot;&gt;&lt;/a&gt;什么是MongoDB ?&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;MongoDB 是由C++语言编写的，是一
    
    </summary>
    
      <category term="数据库" scheme="http://donjote.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="NoSQL" scheme="http://donjote.github.io/tags/NoSQL/"/>
    
  </entry>
  
  <entry>
    <title>CAP定理（CAP theorem）</title>
    <link href="http://donjote.github.io/2017/08/25/cap/"/>
    <id>http://donjote.github.io/2017/08/25/cap/</id>
    <published>2017-08-24T16:00:00.000Z</published>
    <updated>2018-08-03T02:59:35.874Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>在计算机科学中, CAP定理（CAP theorem）, 又被称作 布鲁尔定理（Brewer’s theorem）, 它指出对于一个分布式计算系统来说，不可能同时满足以下三点:</p>
<ul>
<li>一致性(Consistency) (所有节点在同一时间具有相同的数据)</li>
<li>可用性(Availability) (保证每个请求不管成功或者失败都有响应)</li>
<li>分隔容忍(Partition tolerance) (系统中任意信息的丢失或失败不会影响系统的继续运作)<br>CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。<br>因此，根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 CP 原则和满足 AP 原则三 大类：</li>
<li>CA:单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。</li>
<li>CP:满足一致性，分区容忍性的系统，通常性能不是特别高。</li>
<li>AP:满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。<br><img src="/2017/08/25/cap/1.png" alt="cap"></li>
</ul>
</blockquote>
<h2 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h2><blockquote>
<p>BASE：Basically Available, Soft-state, Eventually Consistent。 由 Eric Brewer 定义。<br>CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。<br>BASE是NoSQL数据库通常对可用性及一致性的弱要求原则:</p>
<ul>
<li>Basically Availble –基本可用</li>
<li>Soft-state –软状态/柔性事务。 “Soft state” 可以理解为”无连接”的, 而 “Hard state” 是”面向连接”的</li>
<li>Eventual Consistency –最终一致性 最终一致性， 也是是 ACID 的最终目的。</li>
</ul>
</blockquote>
<h2 id="ACID-vs-BASE"><a href="#ACID-vs-BASE" class="headerlink" title="ACID vs BASE"></a>ACID vs BASE</h2><table>
<thead>
<tr>
<th>ACID</th>
<th>BASE</th>
</tr>
</thead>
<tbody>
<tr>
<td>原子性(Atomicity)</td>
<td>基本可用(Basically Available)</td>
</tr>
<tr>
<td>一致性(Consistency)</td>
<td>软状态/柔性事务(Soft state)</td>
</tr>
<tr>
<td>隔离性(Isolation)</td>
<td>最终一致性 (Eventual consistency)</td>
</tr>
<tr>
<td>持久性 (Durable)</td>
<td></td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在计算机科学中, CAP定理（CAP theorem）, 又被称作 布鲁尔定理（Brewer’s theorem）
    
    </summary>
    
      <category term="数据库" scheme="http://donjote.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="NoSQL" scheme="http://donjote.github.io/tags/NoSQL/"/>
    
  </entry>
  
  <entry>
    <title>gRPC服务方法的定义</title>
    <link href="http://donjote.github.io/2017/08/24/grpc_service/"/>
    <id>http://donjote.github.io/2017/08/24/grpc_service/</id>
    <published>2017-08-23T16:00:00.000Z</published>
    <updated>2018-08-03T02:59:35.906Z</updated>
    
    <content type="html"><![CDATA[<h2 id="服务定义"><a href="#服务定义" class="headerlink" title="服务定义"></a>服务定义</h2><blockquote>
<p>向其它的RPC服务一样，GPRC的基础是服务的定义。服务定义远程调用方法的名称、传入参数和返回参数。GRPC默认使用 Protobuf描述服务</p>
<hr>
<p>GRPC一共定义4种服务方法：<br>1、一元RPC(Unary RPCs )：这是最简单的定义，客户端发送一个请求，服务端返回一个结果<br>2、服务器流RPC（Server streaming RPCs）：客户端发送一个请求，服务端返回一个流给客户端，客户从流中读取一系列消息，直到读取所有小心<br>3、客户端流RPC(Client streaming RPCs )：客户端通过流向服务端发送一系列消息，然后等待服务端读取完数据并返回处理结果<br>4、双向流RPC(Bidirectional streaming RPCs)：客户端和服务端都可以独立向对方发送或接受一系列的消息。客户端和服务端读写的顺序是任意。   </p>
<hr>
<p>以上的服务方法定义在proto文件，如下:   </p>
<pre><code>  syntax = &quot;proto3&quot;;

  option java_multiple_files = true;
  option java_package = &quot;io.github.donjote.hello&quot;;
  option java_outer_classname = &quot;HelloProto&quot;;

  service Hello {
  // A Unary RPC.
  rpc simpleRpc(Simple) returns (SimpleFeature) {}

  // A server-to-client streaming RPC.
  rpc server2ClientRpc(SimpleList) returns (stream SimpleFeature) {}

  // A client-to-server streaming RPC.
  rpc client2ServerRpc(stream Simple) returns (SimpleSummary) {}

  // A Bidirectional streaming RPC.
  rpc bindirectionalStreamRpc(stream Simple) returns (stream Simple) {}
}

message Simple {
  int32 num = 1;
  string name = 2;
}

message SimpleList {
  repeated Simple simpleList = 1;
}

message SimpleFeature {
  string name = 1;
  Simple location = 2;
}

message SimpleSummary {
  int32 feature_count = 2;
}

// 测试类
message SimpleFeatureDatabase {
  repeated SimpleFeature feature = 1;
}
</code></pre></blockquote>
<h2 id="同步RPC和异步RPC"><a href="#同步RPC和异步RPC" class="headerlink" title="同步RPC和异步RPC"></a>同步RPC和异步RPC</h2><blockquote>
<p>GRPC 同时支持同步RPC和异步RPC。<br>同步RPC调用服务方法只支持流RPC（Server streaming RPCs）和一元RPC(Unary RPCs )。异步RPC调用服务方法支持4种方法。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;服务定义&quot;&gt;&lt;a href=&quot;#服务定义&quot; class=&quot;headerlink&quot; title=&quot;服务定义&quot;&gt;&lt;/a&gt;服务定义&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;向其它的RPC服务一样，GPRC的基础是服务的定义。服务定义远程调用方法的名称、传入参数和返回参数
    
    </summary>
    
      <category term="架构" scheme="http://donjote.github.io/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="gRPC" scheme="http://donjote.github.io/tags/gRPC/"/>
    
      <category term="RPC" scheme="http://donjote.github.io/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>gRPC入门简介</title>
    <link href="http://donjote.github.io/2017/08/23/grpc_introdution/"/>
    <id>http://donjote.github.io/2017/08/23/grpc_introdution/</id>
    <published>2017-08-22T16:00:00.000Z</published>
    <updated>2018-08-03T02:59:35.904Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p><a href="https://grpc.io/" target="_blank" rel="external">gRPC</a>是Go实现的：一个高性能，开源，将移动和HTTP/2放在首位通用的RPC框架， 有关详细信息，请参阅<a href="https://grpc.io/docs/" target="_blank" rel="external">gRPC快速入门指南</a>。</p>
<h3 id="gRPC概念图"><a href="#gRPC概念图" class="headerlink" title="gRPC概念图"></a>gRPC概念图</h3><p><img src="/2017/08/23/grpc_introdution/1.png" alt="gRPC概念图"></p>
</blockquote>
<h2 id="gRPC特性"><a href="#gRPC特性" class="headerlink" title="gRPC特性"></a>gRPC特性</h2><h3 id="基于HTTP-2协议标准"><a href="#基于HTTP-2协议标准" class="headerlink" title="基于HTTP/2协议标准"></a>基于HTTP/2协议标准</h3><blockquote>
<h4 id="什么是HTTP-2协议"><a href="#什么是HTTP-2协议" class="headerlink" title="什么是HTTP/2协议"></a>什么是HTTP/2协议</h4><p>HTTP 2.0即超文本传输协议 2.0，是下一代HTTP协议（基于二进制的传输协议）。是由互联网工程任务组（IETF）的Bis (httpbis)工作小组进行开发。</p>
<h4 id="HTTP-2的优点"><a href="#HTTP-2的优点" class="headerlink" title="HTTP/2的优点"></a>HTTP/2的优点</h4><ul>
<li>http2减少了网络往返传输的数量，并且用多路复用和快速丢弃不需要的流的办法来完全避免head of line blocking(线头阻塞)的困扰，降低延迟并提高安全性。</li>
<li>支持大量并行流，所以即使网站的数据分发在各处也不是问题。</li>
<li>合理利用流的优先级，可以让客户端尽可能优先收到更重要的数据。</li>
</ul>
</blockquote>
<h3 id="gRPC基于强大的IDL-Interface-description-language"><a href="#gRPC基于强大的IDL-Interface-description-language" class="headerlink" title="gRPC基于强大的IDL(Interface description language)"></a>gRPC基于强大的IDL(Interface description language)</h3><blockquote>
<p>gRPC基于ProtoBuf(Protocol Buffers)定义接口规范。</p>
<h4 id="ProtoBuf是什么？"><a href="#ProtoBuf是什么？" class="headerlink" title="ProtoBuf是什么？"></a>ProtoBuf是什么？</h4><p>Protocol Buffers 是google提供的一种轻便、高效、简单的数据存储语言，可以用于结构化、序列化数据。</p>
<h4 id="为什么要使用ProtoBuf？"><a href="#为什么要使用ProtoBuf？" class="headerlink" title="为什么要使用ProtoBuf？"></a>为什么要使用ProtoBuf？</h4><ul>
<li>适合应用场景：它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化数据结构。</li>
<li>支持语言众多（提供了完善的API）:Proto2提供了 C++、Java、Python 三种语言的 API。目前语言版本Proto3提供了更多的语言支持,包括 C++ 、C# 、GO 、JAVA、PYTHON。</li>
<li>易学易懂：protoBuf语法非常简单，掌握非常容易，便于读写。</li>
</ul>
</blockquote>
<h3 id="gRPC支持众多开发语言"><a href="#gRPC支持众多开发语言" class="headerlink" title="gRPC支持众多开发语言"></a>gRPC支持众多开发语言</h3><blockquote>
<p>GRPC目前支持的开发语言已达到了10种：C, C++, Java, Go, Node.js, Python, Ruby, Objective-C, PHP and C#。并且GRPC框架已在GitHub上开源。<br> GitHub地址：<a href="https://github.com/grpc" target="_blank" rel="external">https://github.com/grpc</a><br> JAVA GitHub地址：<a href="https://github.com/grpc/grpc-java" target="_blank" rel="external">https://github.com/grpc/grpc-java</a></p>
</blockquote>
<h2 id="为什么使用gRPC"><a href="#为什么使用gRPC" class="headerlink" title="为什么使用gRPC"></a>为什么使用gRPC</h2><blockquote>
<ul>
<li>它使用HTTP2协议，可复用链接，更充分的利用底层TCP传输协议，并以数据流的方式传输，比其他基于HTTP1的传输速率更高。</li>
<li>它基于Proto Buffer语言,对传输数据进行压缩、系列化和结构化，易于客户端与服务端数据的读写操作，并使数据量传输变得更小、传输效率更高。</li>
<li>基于以上及其他特性，使得基于GRPC的客户端和服务端更高效的利用流和链接，从而有助于节省宽带流量、降低链接次数、提高CUP使用效率和电池的使用寿命。</li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://grpc.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;
    
    </summary>
    
      <category term="架构" scheme="http://donjote.github.io/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="gRPC" scheme="http://donjote.github.io/tags/gRPC/"/>
    
      <category term="RPC" scheme="http://donjote.github.io/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow入门：简介</title>
    <link href="http://donjote.github.io/2017/07/14/tensorflow_1/"/>
    <id>http://donjote.github.io/2017/07/14/tensorflow_1/</id>
    <published>2017-07-13T16:00:00.000Z</published>
    <updated>2018-08-03T02:59:35.912Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>TensorFlow 是一个用于人工智能的开源神器</p>
</blockquote>
<h2 id="TensorFlow是什么？"><a href="#TensorFlow是什么？" class="headerlink" title="TensorFlow是什么？"></a>TensorFlow是什么？</h2><blockquote>
<p>TensorFlow™ 是一个采用数据流图（data flow graphs），用于数值计算的开源软件库。节点（Nodes）在图中表示数学操作，图中的线（edges）则表示在节点间相互联系的多维数据数组，即张量（tensor）。它灵活的架构让你可以在多种平台上展开计算，例如台式计算机中的一个或多个CPU（或GPU），服务器，移动设备等等。TensorFlow 最初由Google大脑小组（隶属于Google机器智能研究机构）的研究员和工程师们开发出来，用于机器学习和深度神经网络方面的研究，但这个系统的通用性使其也可广泛用于其他计算领域。<br><img src="/2017/07/14/tensorflow_1/1.gif" alt="TensorFlow"></p>
</blockquote>
<h2 id="什么是数据流图（Data-Flow-Graph）"><a href="#什么是数据流图（Data-Flow-Graph）" class="headerlink" title="什么是数据流图（Data Flow Graph）?"></a>什么是数据流图（Data Flow Graph）?</h2><blockquote>
<p>数据流图用“结点”（nodes）和“线”(edges)的有向图来描述数学计算。“节点” 一般用来表示施加的数学操作，但也可以表示数据输入（feed in）的起点/输出（push out）的终点，或者是读取/写入持久变量（persistent variable）的终点。“线”表示“节点”之间的输入/输出关系。这些数据“线”可以输运“size可动态调整”的多维数据数组，即“张量”（tensor）。张量从图中流过的直观图像是这个工具取名为“Tensorflow”的原因。一旦输入端的所有张量准备好，节点将被分配到各种计算设备完成异步并行地执行运算。</p>
</blockquote>
<h2 id="TensorFlow的特征"><a href="#TensorFlow的特征" class="headerlink" title="TensorFlow的特征"></a>TensorFlow的特征</h2><blockquote>
<ul>
<li>高度的灵活性</li>
<li>真正的可移植性（Portability）</li>
<li>将科研和产品联系在一起</li>
<li>自动求微分</li>
<li>多语言支持</li>
<li>性能最优化</li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;TensorFlow 是一个用于人工智能的开源神器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;TensorFlow是什么？&quot;&gt;&lt;a href=&quot;#TensorFlow是什么？&quot; class=&quot;headerlink&quot; title=&quot;Tens
    
    </summary>
    
      <category term="深度学习" scheme="http://donjote.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="http://donjote.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="神经网络" scheme="http://donjote.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="TensorFlow" scheme="http://donjote.github.io/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow入门：安装</title>
    <link href="http://donjote.github.io/2017/07/14/tensorflow_2/"/>
    <id>http://donjote.github.io/2017/07/14/tensorflow_2/</id>
    <published>2017-07-13T16:00:00.000Z</published>
    <updated>2018-08-03T02:59:35.916Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基于-Docker-的安装"><a href="#基于-Docker-的安装" class="headerlink" title="基于 Docker 的安装"></a>基于 Docker 的安装</h2><blockquote>
<p>首先, <a href="https://docs.docker.com/engine/installation/" target="_blank" rel="external">安装 Docker</a>. 一旦 Docker 已经启动运行, 可以通过命令启动一个容器:</p>
<pre><code>$ docker run -it --name tensorflow -p 8888:8888 tensorflow/tensorflow
</code></pre></blockquote>
<p>##才云TensorFlow镜像</p>
<blockquote>
<p>在官方镜像的基础上，才云科技提供的镜像进一步整合了其他机器学习工具包以及TensorFlow可视化工具TensorBoard，使用起来可以更加方便。</p>
<pre><code>$ docker run -it  --name tensorflow -p 8888:8888 -p 6006:6006 \
cargo.caicloud.io/caicloud/tensorflow
</code></pre><p>在这个命令中，-p 8888:8888 将容器内运行的Jupyter服务映射到本地机器，这样在浏览器中打开localhost:8888就能看到Jupyter界面。在此镜像中运行的Jupyter是一个网页版的代码编辑器，它支持创建、上传、修改和运行Python程序。</p>
<hr>
<p>-p 6006:6006将容器内运行的TensorFlow可视化工具TensorBoard映射到本地机器，通过在浏览器中打开localhost:6006就可以将TensorFlow在训练时的状态、图片数据以及神经网络结构等信息全部展示出来。此镜像会将所有输出到/log目录底下的日志全部可视化。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基于-Docker-的安装&quot;&gt;&lt;a href=&quot;#基于-Docker-的安装&quot; class=&quot;headerlink&quot; title=&quot;基于 Docker 的安装&quot;&gt;&lt;/a&gt;基于 Docker 的安装&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;首先, &lt;a href=&quot;
    
    </summary>
    
      <category term="深度学习" scheme="http://donjote.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="http://donjote.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="神经网络" scheme="http://donjote.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="TensorFlow" scheme="http://donjote.github.io/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>Golang包管理</title>
    <link href="http://donjote.github.io/2017/07/13/golang_vendor/"/>
    <id>http://donjote.github.io/2017/07/13/golang_vendor/</id>
    <published>2017-07-12T16:00:00.000Z</published>
    <updated>2018-08-03T02:59:35.903Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote>
<p>Golang并没有官方最佳管理方案，在Go的世界里存在大量的自制解决方案。go语言的包是没有中央库统一管理的，通过使用go get命令从远程代码库(github.com,goolge code 等)拉取，直接跳过中央版本库的约束，让代码的拉取直接基于源代码版本控制库，开发者间的协同直接依赖于源代码的版本控制。直接去除了库版本的概念。没有明显的包版本标识，感觉还是有点不适应，官方的建议是把外部依赖的代码全部复制到自己可控的源代码库中，进行同意管理。从而做到对依赖包的可控管理。</p>
<hr>
<p>对于国内开发者来说，最好是能一个一个包来管理。遇到网络问题，可以通过国内镜像下载。在这样的情况之下gvt 就是一个不错的选择。它可以帮助我们把一个包以及依赖都彻底的拉到本地的代码库中，统一了团队协作过程中编译环境不一致的问题。</p>
</blockquote>
<h2 id="gvt安装方法"><a href="#gvt安装方法" class="headerlink" title="gvt安装方法"></a>gvt安装方法</h2><blockquote>
<pre><code>$ go get -u github.com/FiloSottile/gvt
</code></pre></blockquote>
<h2 id="gvt使用"><a href="#gvt使用" class="headerlink" title="gvt使用"></a>gvt使用</h2><blockquote>
<h3 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h3><pre><code>$ gvt fetch [package]
</code></pre><h3 id="下载包"><a href="#下载包" class="headerlink" title="下载包"></a>下载包</h3><pre><code>$ gvt restore
</code></pre><h3 id="包列表"><a href="#包列表" class="headerlink" title="包列表"></a>包列表</h3><pre><code>$ gvt list
</code></pre><h3 id="更新指定包"><a href="#更新指定包" class="headerlink" title="更新指定包"></a>更新指定包</h3><pre><code>$ gvt update [package]
</code></pre><h3 id="删除指定包"><a href="#删除指定包" class="headerlink" title="删除指定包"></a>删除指定包</h3><pre><code>$ gvt delete [package]
</code></pre></blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Golang并没有官方最佳管理方案，在Go的世界里存在大量的自制解决方案。go语言的包是没有中央库统一管理的，通过
    
    </summary>
    
      <category term="Golang" scheme="http://donjote.github.io/categories/Golang/"/>
    
    
      <category term="Golang" scheme="http://donjote.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang简介与环境搭建</title>
    <link href="http://donjote.github.io/2017/07/13/golang_install/"/>
    <id>http://donjote.github.io/2017/07/13/golang_install/</id>
    <published>2017-07-12T16:00:00.000Z</published>
    <updated>2018-08-03T02:59:35.903Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Golang简介"><a href="#Golang简介" class="headerlink" title="Golang简介"></a>Golang简介</h2><blockquote>
<p>Go 是 2009 年发布的一种简单的并行开发，且跨平台的类 C 语言。由于其强大的并行性，很适合用于网络开发中</p>
<h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><ul>
<li>Less can be more</li>
<li>大道至简,小而蕴真</li>
<li>让事情变得复杂很容易，让事情变得简单才难</li>
<li>深刻的工程文化<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3></li>
</ul>
<ol>
<li>自带gc。</li>
<li>静态编译，编译好后，扔服务器直接运行。</li>
<li>简单的思想，没有继承，多态，类等。</li>
<li>丰富的库和详细的开发文档。</li>
<li>语法层支持并发，和拥有同步并发的channel类型，使并发开发变得非常方便。</li>
<li>简洁的语法，提高开发效率，同时提高代码的阅读性和可维护性。</li>
<li>超级简单的交叉编译，仅需更改环境变量。（花了我两天时间编译一个imagemagick到arm平台）</li>
<li>内含完善、全面的软件工程工具。Go语言自带的命令和工具相当地强大。通过它们，我们可以很轻松地完成Go语言程序的获取、编译、测试、安装、运行、运行分析等一系列工作，这几乎涉及了开发和维护一个软件的所有环节。<h3 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h3></li>
</ol>
<ul>
<li>自动垃圾回收</li>
<li>更丰富的内置类型</li>
<li>函数多返回值</li>
<li>错误处理</li>
<li>匿名函数和闭包</li>
<li>类型和接口</li>
<li>并发编程</li>
<li>反射</li>
<li>语言交互性</li>
<li>高性能/高效开发</li>
</ul>
</blockquote>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><blockquote>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>$ wget https://storage.googleapis.com/golang/go1.8.3.linux-amd64.tar.gz
$ tar -C /usr/local -xzf go1.8.3.linux-amd64.tar.gz  
</code></pre><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><pre><code>$ vim /etc/profile
</code></pre><p>添加对应的GOROOT和GOROOT的配置环境</p>
<pre><code>export GOROOT=/usr/local/go
export GOPATH=$HOME/Projects/golang
export PATH=$PATH:$GOROOT/bin:$GOPATH/bin
</code></pre><p>之后，source /etc/profile 使得其配置文件有效.</p>
</blockquote>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><blockquote>
<pre><code>$ go env
GOARCH=&quot;amd64&quot;
GOBIN=&quot;&quot;
GOEXE=&quot;&quot;
GOHOSTARCH=&quot;amd64&quot;
GOHOSTOS=&quot;linux&quot;
GOOS=&quot;linux&quot;
GOPATH=&quot;/home/donjote/Projects/golang&quot;
GORACE=&quot;&quot;
GOROOT=&quot;/usr/local/go&quot;
GOTOOLDIR=&quot;/usr/local/go/pkg/tool/linux_amd64&quot;
GCCGO=&quot;gccgo&quot;
CC=&quot;gcc&quot;
GOGCCFLAGS=&quot;-fPIC -m64 -pthread -fmessage-length=0 -fdebug-prefix-map=/tmp/go-build061263866=/tmp/go-build -gno-record-gcc-switches&quot;
CXX=&quot;g++&quot;
CGO_ENABLED=&quot;1&quot;
PKG_CONFIG=&quot;pkg-config&quot;
CGO_CFLAGS=&quot;-g -O2&quot;
CGO_CPPFLAGS=&quot;&quot;
CGO_CXXFLAGS=&quot;-g -O2&quot;
CGO_FFLAGS=&quot;-g -O2&quot;
CGO_LDFLAGS=&quot;-g -O2&quot;
</code></pre></blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Golang简介&quot;&gt;&lt;a href=&quot;#Golang简介&quot; class=&quot;headerlink&quot; title=&quot;Golang简介&quot;&gt;&lt;/a&gt;Golang简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Go 是 2009 年发布的一种简单的并行开发，且跨平台的类 C 
    
    </summary>
    
      <category term="Golang" scheme="http://donjote.github.io/categories/Golang/"/>
    
    
      <category term="Golang" scheme="http://donjote.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>深度学习：神经网络发展史</title>
    <link href="http://donjote.github.io/2017/07/12/deep_learning_phylogeny/"/>
    <id>http://donjote.github.io/2017/07/12/deep_learning_phylogeny/</id>
    <published>2017-07-11T16:00:00.000Z</published>
    <updated>2018-08-03T02:59:35.875Z</updated>
    
    <content type="html"><![CDATA[<h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><blockquote>
<p>机器学习(Machine Learning,ML)一门多领域交叉学科，涉及概率论、统计学、逼近学、凸分析、算法复杂度理论等多门学科。专门研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构使之不断改善自身的性能。</p>
<hr>
<p>它是人工智能的核心，是使计算机具有智能的根本途径，其应用遍及人工智能的各个领域，它主要使用归纳、综合不是演绎。</p>
</blockquote>
<h2 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h2><blockquote>
<p>深度学习是机器学习中一种基于对数据进行表征学习的方法。观测值（例如一幅图像）可以使用多种方式来表示，如每个像素强度值的向量，或者更抽象地表示成一系列边、特定形状的区域等。而使用某些特定的表示方法更容易从实例中学习任务（例如，人脸识别或面部表情识别）。深度学习的好处是用非监督式或半监督式的特征学习和分层特征提取高效算法来替代手工获取特征。</p>
<hr>
<p>深度学习是机器学习研究中的一个新的领域，其动机在于建立、模拟人脑进行分析学习的神经网络，它模仿人脑的机制来解释数据，例如图像，声音和文本。</p>
<hr>
<p>同机器学习方法一样，深度机器学习方法也有监督学习与无监督学习之分．不同的学习框架下建立的学习模型很是不同．例如，卷积神经网络（Convolutional neural networks，简称CNNs）就是一种深度的监督学习下的机器学习模型，而深度置信网（Deep Belief Nets，简称DBNs）就是一种无监督学习下的机器学习模型。</p>
</blockquote>
<h2 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h2><blockquote>
<p><img src="/2017/07/12/deep_learning_phylogeny/1.jpg" alt="发展历史"><br>由图可以明显看出DL在从06年崛起之前经历了两个低谷，这两个低谷也将神经网络的发展分为了三个不同的阶段。</p>
<h3 id="第一代神经网络"><a href="#第一代神经网络" class="headerlink" title="第一代神经网络"></a>第一代神经网络</h3><p><strong>感知器(~1960）</strong><br><img src="/2017/07/12/deep_learning_phylogeny/2.png" alt="感知器"><br>感知器（Perceptrons）使用一层手编（Hand-coded）特征，通过学习如何给这些特征加权来识别对象。<br>感知器的优点：调整权值的学习算法很简洁。<br>感知器的缺点：感知器一些先天的缺陷，导致它们可以学习的东西大大地受限。<br>Vapnik和他的同事们发明了大名鼎鼎的支持向量机（SVM），改进了感知器的一些缺陷（例如创建灵活的特征而不是手编的非适应的特征），并得到了广泛的应用。但是归根到底，它还是一种感知器，所以无法避免感知器的先天限制。</p>
<h3 id="第二代神经网络"><a href="#第二代神经网络" class="headerlink" title="第二代神经网络"></a>第二代神经网络</h3><p><strong>BP（反向传播，Back-propagate）神经网络（~1985） </strong><br><img src="/2017/07/12/deep_learning_phylogeny/3.png" alt="BP"><br>BP神经网络通常使用梯度法来修正权值。BP并不是一种很实用的方法。原因有三：</p>
<ul>
<li>它需要被标记的训练数据，但是几乎所有的数据都是未标记的。</li>
<li>学习时间不易衡量，在多层网络中，速度非常慢。</li>
<li>它陷入局部极小点而不收敛的情况极大。<h3 id="第三代神经网络"><a href="#第三代神经网络" class="headerlink" title="第三代神经网络"></a>第三代神经网络</h3>最近的神经科学研究表明，和人类的许多认知能力相关的大脑皮层，并不显式地预处理感知信号，而是让它们通过一个复杂的模块层次结构，久而久之，就可以根据观察结果呈现的规律来表达它们。<br>这一发现促进了深机器学习（DML, Deep Machine Learning）的发展。DML关注的恰恰正是是信息表达的计算模型，和大脑皮层类似。</li>
</ul>
<hr>
<p>目前DML领域有两种主流的方法：</p>
<ul>
<li>卷积神经网络<br><img src="/2017/07/12/deep_learning_phylogeny/4.png" alt="卷积神经网络"></li>
<li>深度信念网络<br><img src="/2017/07/12/deep_learning_phylogeny/5.png" alt="深度信念网络"></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;机器学习&quot;&gt;&lt;a href=&quot;#机器学习&quot; class=&quot;headerlink&quot; title=&quot;机器学习&quot;&gt;&lt;/a&gt;机器学习&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;机器学习(Machine Learning,ML)一门多领域交叉学科，涉及概率论、统计学、逼近学、
    
    </summary>
    
      <category term="深度学习" scheme="http://donjote.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="http://donjote.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="神经网络" scheme="http://donjote.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>使用docker-machine搭建etcd集群</title>
    <link href="http://donjote.github.io/2017/07/11/etcd_2/"/>
    <id>http://donjote.github.io/2017/07/11/etcd_2/</id>
    <published>2017-07-10T16:00:00.000Z</published>
    <updated>2018-08-03T02:59:35.901Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建Etcd集群"><a href="#创建Etcd集群" class="headerlink" title="创建Etcd集群"></a>创建Etcd集群</h2><blockquote>
<p>  $ curl -sSL <a href="https://raw.githubusercontent.com/donjote/shell-etcd/master/etcd.sh" target="_blank" rel="external">https://raw.githubusercontent.com/donjote/shell-etcd/master/etcd.sh</a> | sh -</p>
</blockquote>
<h3 id="集群验证"><a href="#集群验证" class="headerlink" title="集群验证"></a>集群验证</h3><blockquote>
<ol>
<li>验证集群members。在集群中的每台机器上查看members，得出的结果应该是相同的   </li>
</ol>
<pre><code>$ curl -L http://$(docker-machine ip etcd-node-0):2379/v2/members
$ curl -L http://$(docker-machine ip etcd-node-1):2379/v2/members
$ curl -L http://$(docker-machine ip etcd-node-2):2379/v2/members
{&quot;members&quot;:[{&quot;id&quot;:&quot;305750b374006637&quot;,&quot;name&quot;:&quot;etcd-node-2&quot;,&quot;peerURLs&quot;:[&quot;http://192.168.99.102:2380&quot;],&quot;clientURLs&quot;:[&quot;http://192.168.99.102:2379&quot;]},{&quot;id&quot;:&quot;c7177c3c5ff3b1b4&quot;,&quot;name&quot;:&quot;etcd-node-0&quot;,&quot;peerURLs&quot;:[&quot;http://192.168.99.100:2380&quot;],&quot;clientURLs&quot;:[&quot;http://192.168.99.100:2379&quot;]},{&quot;id&quot;:&quot;d5673e1f00b32e05&quot;,&quot;name&quot;:&quot;etcd-node-1&quot;,&quot;peerURLs&quot;:[&quot;http://192.168.99.101:2380&quot;],&quot;clientURLs&quot;:[&quot;http://192.168.99.101:2379&quot;]}]}
</code></pre><p>2.某台机器上添加数据，其他机器上查看数据，得出的结果应该是相同的</p>
<pre><code>$ curl -L http://$(docker-machine ip etcd-node-0):2379/v2/keys/message -XPUT -d value=&quot;Hello World&quot;
{&quot;action&quot;:&quot;set&quot;,&quot;node&quot;:{&quot;key&quot;:&quot;/message&quot;,&quot;value&quot;:&quot;Hello World&quot;,&quot;modifiedIndex&quot;:9,&quot;createdIndex&quot;:9}}
$ curl -L http://$(docker-machine ip etcd-node-1):2379/v2/keys/message
{&quot;action&quot;:&quot;set&quot;,&quot;node&quot;:{&quot;key&quot;:&quot;/message&quot;,&quot;value&quot;:&quot;Hello World&quot;,&quot;modifiedIndex&quot;:9,&quot;createdIndex&quot;:9}}
$ curl -L http://$(docker-machine ip etcd-node-1):2379/v2/keys/message
{&quot;action&quot;:&quot;set&quot;,&quot;node&quot;:{&quot;key&quot;:&quot;/message&quot;,&quot;value&quot;:&quot;Hello World&quot;,&quot;modifiedIndex&quot;:9,&quot;createdIndex&quot;:9}}
</code></pre></blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;创建Etcd集群&quot;&gt;&lt;a href=&quot;#创建Etcd集群&quot; class=&quot;headerlink&quot; title=&quot;创建Etcd集群&quot;&gt;&lt;/a&gt;创建Etcd集群&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;  $ curl -sSL &lt;a href=&quot;https://ra
    
    </summary>
    
      <category term="架构" scheme="http://donjote.github.io/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="微服务" scheme="http://donjote.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="etcd" scheme="http://donjote.github.io/tags/etcd/"/>
    
      <category term="服务发现" scheme="http://donjote.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>etcd概述和使用场景</title>
    <link href="http://donjote.github.io/2017/07/11/etcd_1/"/>
    <id>http://donjote.github.io/2017/07/11/etcd_1/</id>
    <published>2017-07-10T16:00:00.000Z</published>
    <updated>2018-08-03T02:59:35.885Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>etcd是一个高可用的键值存储系统，主要用于共享配置和服务发现。etcd是由CoreOS开发并维护的，灵感来自于 ZooKeeper 和 Doozer，它使用Go语言编写，并通过Raft一致性算法处理日志复制以保证强一致性。Raft是一个新的一致性算法，适用于分布式系统的日志复制，Raft通过选举的方式来实现一致性。Google的容器集群管理系统Kubernetes、开源PaaS平台Cloud Foundry和CoreOS的Fleet都广泛使用了etcd。在分布式系统中，如何管理节点间的状态一直是一个难题，etcd像是专门为集群环境的服务发现和注册而设计，它提供了数据TTL失效、数据改变监视、多值、目录监听、分布式锁原子操作等功能，可以方便的跟踪并管理集群节点的状态。</p>
<hr>
<p>etcd的特性如下：</p>
<ul>
<li>简单: 支持curl方式的用户API（HTTP+JSON）</li>
<li>安全: 可选的SSL客户端证书认证</li>
<li>快速: 单实例每秒 1000 次写操作</li>
<li>可靠: 使用Raft保证一致性</li>
</ul>
</blockquote>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h3 id="场景一：服务发现（Service-Discovery）"><a href="#场景一：服务发现（Service-Discovery）" class="headerlink" title="场景一：服务发现（Service Discovery）"></a>场景一：服务发现（Service Discovery）</h3><blockquote>
<p>服务发现要解决的也是分布式系统中最常见的问题之一，即在同一个分布式集群中的进程或服务，要如何才能找到对方并建立连接。本质上来说，服务发现就是想要了解集群中是否有进程在监听udp或tcp端口，并且通过名字就可以查找和连接。要解决服务发现的问题，需要有下面三大支柱，缺一不可。</p>
<hr>
<p>一个强一致性、高可用的服务存储目录。基于Raft算法的etcd天生就是这样一个强一致性高可用的服务存储目录。</p>
<hr>
<p>一种注册服务和监控服务健康状态的机制。用户可以在etcd中注册服务，并且对注册的服务设置key TTL，定时保持服务的心跳以达到监控健康状态的效果。</p>
<hr>
<p>一种查找和连接服务的机制。通过在etcd指定的主题下注册的服务也能在对应的主题下查找到。为了确保连接，我们可以在每个服务机器上都部署一个Proxy模式的etcd，这样就可以确保能访问etcd集群的服务都能互相连接。<br><img src="/2017/07/11/etcd_1/1.jpg" alt="服务发现示意图"><br>图一 服务发现示意图</p>
<hr>
<p>下面我们来看服务发现对应的具体场景。</p>
<hr>
<p>微服务协同工作架构中，服务动态添加。随着Docker容器的流行，多种微服务共同协作，构成一个相对功能强大的架构的案例越来越多。透明化的动态添加这些服务的需求也日益强烈。通过服务发现机制，在etcd中注册某个服务名字的目录，在该目录下存储可用的服务节点的IP。在使用服务的过程中，只要从服务目录下查找可用的服务节点去使用即可。<br><img src="/2017/07/11/etcd_1/2.jpg" alt="服务协同工作"><br>图二 微服务协同工作</p>
<hr>
<p>PaaS平台中应用多实例与实例故障重启透明化。PaaS平台中的应用一般都有多个实例，通过域名，不仅可以透明的对这多个实例进行访问，而且还可以做到负载均衡。但是应用的某个实例随时都有可能故障重启，这时就需要动态的配置域名解析（路由）中的信息。通过etcd的服务发现功能就可以轻松解决这个动态配置的问题。<br><img src="/2017/07/11/etcd_1/3.jpg" alt="多平台多实例透明化"><br>图三 多平台多实例透明化</p>
</blockquote>
<h3 id="场景二：消息发布与订阅"><a href="#场景二：消息发布与订阅" class="headerlink" title="场景二：消息发布与订阅"></a>场景二：消息发布与订阅</h3><blockquote>
<p>在分布式系统中，最适用的一种组件间通信方式就是消息发布与订阅。即构建一个配置共享中心，数据提供者在这个配置中心发布消息，而消息使用者则订阅他们关心的主题，一旦主题有消息发布，就会实时通知订阅者。通过这种方式可以做到分布式系统配置的集中式管理与动态更新。</p>
<hr>
<p>应用中用到的一些配置信息放到etcd上进行集中管理。这类场景的使用方式通常是这样：应用在启动的时候主动从etcd获取一次配置信息，同时，在etcd节点上注册一个Watcher并等待，以后每次配置有更新的时候，etcd都会实时通知订阅者，以此达到获取最新配置信息的目的。</p>
<hr>
<p>分布式搜索服务中，索引的元信息和服务器集群机器的节点状态存放在etcd中，供各个客户端订阅使用。使用etcd的key TTL功能可以确保机器状态是实时更新的。</p>
<hr>
<p>分布式日志收集系统。这个系统的核心工作是收集分布在不同机器的日志。收集器通常是按照应用（或主题）来分配收集任务单元，因此可以在etcd上创建一个以应用（主题）命名的目录P，并将这个应用（主题相关）的所有机器ip，以子目录的形式存储到目录P上，然后设置一个etcd递归的Watcher，递归式的监控应用（主题）目录下所有信息的变动。这样就实现了机器IP（消息）变动的时候，能够实时通知到收集器调整任务分配。</p>
<hr>
<p>系统中信息需要动态自动获取与人工干预修改信息请求内容的情况。通常是暴露出接口，例如JMX接口，来获取一些运行时的信息。引入etcd之后，就不用自己实现一套方案了，只要将这些信息存放到指定的etcd目录中即可，etcd的这些目录就可以通过HTTP的接口在外部访问。<br><img src="/2017/07/11/etcd_1/4.jpg" alt="消息发布和订阅"><br>图四 消息发布和订阅</p>
</blockquote>
<h3 id="场景三：负载均衡"><a href="#场景三：负载均衡" class="headerlink" title="场景三：负载均衡"></a>场景三：负载均衡</h3><blockquote>
<p>在场景一中也提到了负载均衡，本文所指的负载均衡均为软负载均衡。分布式系统中，为了保证服务的高可用以及数据的一致性，通常都会把数据和服务部署多份，以此达到对等服务，即使其中的某一个服务失效了，也不影响使用。由此带来的坏处是数据写入性能下降，而好处则是数据访问时的负载均衡。因为每个对等服务节点上都存有完整的数据，所以用户的访问流量就可以分流到不同的机器上。</p>
<hr>
<p>etcd本身分布式架构存储的信息访问支持负载均衡。etcd集群化以后，每个etcd的核心节点都可以处理用户的请求。所以，把数据量小但是访问频繁的消息数据直接存储到etcd中也是个不错的选择，如业务系统中常用的二级代码表（在表中存储代码，在etcd中存储代码所代表的具体含义，业务系统调用查表的过程，就需要查找表中代码的含义）。</p>
<hr>
<p>利用etcd维护一个负载均衡节点表。etcd可以监控一个集群中多个节点的状态，当有一个请求发过来后，可以轮询式的把请求转发给存活着的多个状态。类似KafkaMQ，通过ZooKeeper来维护生产者和消费者的负载均衡。同样也可以用etcd来做ZooKeeper的工作。<br><img src="/2017/07/11/etcd_1/5.jpg" alt="负载均衡"><br>图五 负载均衡</p>
</blockquote>
<h3 id="场景四：分布式通知与协调"><a href="#场景四：分布式通知与协调" class="headerlink" title="场景四：分布式通知与协调"></a>场景四：分布式通知与协调</h3><blockquote>
<p>这里说到的分布式通知与协调，与消息发布和订阅有些相似。都用到了etcd中的Watcher机制，通过注册与异步通知机制，实现分布式环境下不同系统之间的通知与协调，从而对数据变更做到实时处理。实现方式通常是这样：不同系统都在etcd上对同一个目录进行注册，同时设置Watcher观测该目录的变化（如果对子目录的变化也有需要，可以设置递归模式），当某个系统更新了etcd的目录，那么设置了Watcher的系统就会收到通知，并作出相应处理。</p>
<hr>
<p>通过etcd进行低耦合的心跳检测。检测系统和被检测系统通过etcd上某个目录关联而非直接关联起来，这样可以大大减少系统的耦合性。</p>
<hr>
<p>通过etcd完成系统调度。某系统有控制台和推送系统两部分组成，控制台的职责是控制推送系统进行相应的推送工作。管理人员在控制台作的一些操作，实际上是修改了etcd上某些目录节点的状态，而etcd就把这些变化通知给注册了Watcher的推送系统客户端，推送系统再作出相应的推送任务。</p>
<hr>
<p>通过etcd完成工作汇报。大部分类似的任务分发系统，子任务启动后，到etcd来注册一个临时工作目录，并且定时将自己的进度进行汇报（将进度写入到这个临时目录），这样任务管理者就能够实时知道任务进度。<br><img src="/2017/07/11/etcd_1/6.jpg" alt="分布式协同工作"><br>图六 分布式协同工作</p>
</blockquote>
<h3 id="场景五：分布式锁"><a href="#场景五：分布式锁" class="headerlink" title="场景五：分布式锁"></a>场景五：分布式锁</h3><blockquote>
<p>因为etcd使用Raft算法保持了数据的强一致性，某次操作存储到集群中的值必然是全局一致的，所以很容易实现分布式锁。锁服务有两种使用方式，一是保持独占，二是控制时序。</p>
<hr>
<p>保持独占即所有获取锁的用户最终只有一个可以得到。etcd为此提供了一套实现分布式锁原子操作CAS（CompareAndSwap）的API。通过设置prevExist值，可以保证在多个节点同时去创建某个目录时，只有一个成功。而创建成功的用户就可以认为是获得了锁。</p>
<hr>
<p>控制时序，即所有想要获得锁的用户都会被安排执行，但是获得锁的顺序也是全局唯一的，同时决定了执行顺序。etcd为此也提供了一套API（自动创建有序键），对一个目录建值时指定为POST动作，这样etcd会自动在目录下生成一个当前最大的值为键，存储这个新的值（客户端编号）。同时还可以使用API按顺序列出所有当前目录下的键值。此时这些键的值就是客户端的时序，而这些键中存储的值可以是代表客户端的编号。<br><img src="/2017/07/11/etcd_1/7.jpg" alt="分布式锁"><br>图七 分布式锁</p>
</blockquote>
<h3 id="场景六：分布式队列"><a href="#场景六：分布式队列" class="headerlink" title="场景六：分布式队列"></a>场景六：分布式队列</h3><blockquote>
<p>分布式队列的常规用法与场景五中所描述的分布式锁的控制时序用法类似，即创建一个先进先出的队列，保证顺序。</p>
<hr>
<p>另一种比较有意思的实现是在保证队列达到某个条件时再统一按顺序执行。这种方法的实现可以在/queue这个目录中另外建立一个/queue/condition节点。</p>
<hr>
<p>condition可以表示队列大小。比如一个大的任务需要很多小任务就绪的情况下才能执行，每次有一个小任务就绪，就给这个condition数字加1，直到达到大任务规定的数字，再开始执行队列里的一系列小任务，最终执行大任务。<br>condition可以表示某个任务在不在队列。这个任务可以是所有排序任务的首个执行程序，也可以是拓扑结构中没有依赖的点。通常，必须执行这些任务后才能执行队列中的其他任务。<br><img src="/2017/07/11/etcd_1/8.jpg" alt="分布式队列"><br>图八 分布式队列</p>
</blockquote>
<h3 id="场景七：集群监控与Leader竞选"><a href="#场景七：集群监控与Leader竞选" class="headerlink" title="场景七：集群监控与Leader竞选"></a>场景七：集群监控与Leader竞选</h3><blockquote>
<p>通过etcd来进行监控实现起来非常简单并且实时性强。</p>
<hr>
<p>前面几个场景已经提到Watcher机制，当某个节点消失或有变动时，Watcher会第一时间发现并告知用户。<br>节点可以设置TTL key，比如每隔30s发送一次心跳使代表该机器存活的节点继续存在，否则节点消失。<br>这样就可以第一时间检测到各节点的健康状态，以完成集群的监控要求。</p>
<hr>
<p>另外，使用分布式锁，可以完成Leader竞选。这种场景通常是一些长时间CPU计算或者使用IO操作的机器，只需要竞选出的Leader计算或处理一次，就可以把结果复制给其他的Follower。从而避免重复劳动，节省计算资源。</p>
<hr>
<p>这个的经典场景是搜索系统中建立全量索引。如果每个机器都进行一遍索引的建立，不但耗时而且建立索引的一致性不能保证。通过在etcd的CAS机制同时创建一个节点，创建成功的机器作为Leader，进行索引计算，然后把计算结果分发到其它节点。<br><img src="/2017/07/11/etcd_1/9.jpg" alt="Leader竞选"><br>图九 Leader竞选</p>
</blockquote>
<h2 id="为什么用etcd而不用ZooKeeper？"><a href="#为什么用etcd而不用ZooKeeper？" class="headerlink" title="为什么用etcd而不用ZooKeeper？"></a>为什么用etcd而不用ZooKeeper？</h2><blockquote>
<p>etcd实现的这些功能，ZooKeeper都能实现。那么为什么要用etcd而非直接使用ZooKeeper呢？</p>
<hr>
<p>相较之下，ZooKeeper有如下缺点：</p>
<ol>
<li>复杂。ZooKeeper的部署维护复杂，管理员需要掌握一系列的知识和技能；而Paxos强一致性算法也是素来以复杂难懂而闻名于世；另外，ZooKeeper的使用也比较复杂，需要安装客户端，官方只提供了Java和C两种语言的接口。</li>
<li>Java编写。这里不是对Java有偏见，而是Java本身就偏向于重型应用，它会引入大量的依赖。而运维人员则普遍希望保持强一致、高可用的机器集群尽可能简单，维护起来也不易出错。]</li>
<li>发展缓慢。Apache基金会项目特有的“Apache Way”在开源界饱受争议，其中一大原因就是由于基金会庞大的结构以及松散的管理导致项目发展缓慢。</li>
</ol>
<hr>
<p>而etcd作为一个后起之秀，其优点也很明显。</p>
<ol>
<li>简单。使用Go语言编写部署简单；使用HTTP作为接口使用简单；使用Raft算法保证强一致性让用户易于理解。</li>
<li>数据持久化。etcd默认数据一更新就进行持久化。</li>
<li>安全。etcd支持SSL客户端安全认证。</li>
</ol>
<hr>
<p>最后，etcd作为一个年轻的项目，真正告诉迭代和开发中，这既是一个优点，也是一个缺点。优点是它的未来具有无限的可能性，缺点是无法得到大项目长时间使用的检验。然而，目前CoreOS、Kubernetes和CloudFoundry等知名项目均在生产环境中使用了etcd，所以总的来说，etcd值得你去尝试。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;etcd是一个高可用的键值存储系统，主要用于共享配置和服务发现。etcd是由CoreOS开发并维护的，灵感来自于 
    
    </summary>
    
      <category term="架构" scheme="http://donjote.github.io/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="微服务" scheme="http://donjote.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="etcd" scheme="http://donjote.github.io/tags/etcd/"/>
    
      <category term="服务发现" scheme="http://donjote.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>在 Docker Machine 中使用 Mirror 服务</title>
    <link href="http://donjote.github.io/2017/07/11/docker_machine_mirror/"/>
    <id>http://donjote.github.io/2017/07/11/docker_machine_mirror/</id>
    <published>2017-07-10T16:00:00.000Z</published>
    <updated>2018-08-03T02:59:35.884Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<pre><code>$ export REGISTRY_MIRROR=https://***.mirror.aliyuncs.com
$ docker-machine create -d virtualbox --engine-registry-mirror $REGISTRY_MIRROR dev
</code></pre></blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;$ export REGISTRY_MIRROR=https://***.mirror.aliyuncs.com
$ docker-machine create -d virtualbox --engine-registry-mir
    
    </summary>
    
      <category term="容器" scheme="http://donjote.github.io/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="docker" scheme="http://donjote.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Yarn介绍</title>
    <link href="http://donjote.github.io/2017/07/10/yarn/"/>
    <id>http://donjote.github.io/2017/07/10/yarn/</id>
    <published>2017-07-09T16:00:00.000Z</published>
    <updated>2018-08-03T02:59:35.932Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Yarn介紹"><a href="#Yarn介紹" class="headerlink" title="Yarn介紹"></a>Yarn介紹</h2><blockquote>
<p>Facebook发布的新一代包管理工具，旨在解决以往使用npm作为包管理会遇到的一些问题。从其官方介绍可以看到其重点强调的3个点：快、可靠、安全。</p>
</blockquote>
<h2 id="Yarn特性"><a href="#Yarn特性" class="headerlink" title="Yarn特性"></a>Yarn特性</h2><blockquote>
<h3 id="离线模式"><a href="#离线模式" class="headerlink" title="离线模式"></a>离线模式</h3><p>以前安装过的包可以在没有任何互联网连接的情况下重新安装。</p>
<h3 id="确定性"><a href="#确定性" class="headerlink" title="确定性"></a>确定性</h3><p>不管安装顺序如何，相同的依赖关系将在每台机器上以相同的方式安装。</p>
<h3 id="网络性能"><a href="#网络性能" class="headerlink" title="网络性能"></a>网络性能</h3><p>Yarn 有效地对请求进行排队，并避免 request waterfalls， 以便最大限度地利用网络。</p>
<h3 id="多个-Registries"><a href="#多个-Registries" class="headerlink" title="多个 Registries"></a>多个 Registries</h3><p>支持从 npm 或 Bower 安装包，并保持安装包的工作流程相同。</p>
<h3 id="网络恢复"><a href="#网络恢复" class="headerlink" title="网络恢复"></a>网络恢复</h3><p>单个请求失败不会导致安装失败，而会重试请求。</p>
<h3 id="扁平模式"><a href="#扁平模式" class="headerlink" title="扁平模式"></a>扁平模式</h3><p>将不兼容版本的依赖项解析为单个版本，以避免重复下载。</p>
</blockquote>
<h2 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h2><blockquote>
<pre><code>$ sudo npm i -g yarn
</code></pre></blockquote>
<h2 id="设置淘宝镜像"><a href="#设置淘宝镜像" class="headerlink" title="设置淘宝镜像"></a>设置淘宝镜像</h2><blockquote>
<pre><code>$ yarn config set registry https://registry.npm.taobao.org --global
$ yarn config set disturl https://npm.taobao.org/dist --global
</code></pre></blockquote>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><blockquote>
<h3 id="初始化一个新的项目"><a href="#初始化一个新的项目" class="headerlink" title="初始化一个新的项目"></a>初始化一个新的项目</h3><pre><code>$ yarn init
</code></pre><h3 id="添加一个依赖包"><a href="#添加一个依赖包" class="headerlink" title="添加一个依赖包"></a>添加一个依赖包</h3><pre><code>$ yarn add [package]
$ yarn add [package]@[version]
$ yarn add [package]@[tag]
</code></pre><h3 id="更新一个依赖包"><a href="#更新一个依赖包" class="headerlink" title="更新一个依赖包"></a>更新一个依赖包</h3><pre><code>$ yarn upgrade [package]
$ yarn upgrade [package]@[version]
$ yarn upgrade [package]@[tag]
</code></pre><h3 id="移除一个依赖包"><a href="#移除一个依赖包" class="headerlink" title="移除一个依赖包"></a>移除一个依赖包</h3><pre><code>$ yarn remove [package]
</code></pre><h3 id="安装项目所有的依赖包"><a href="#安装项目所有的依赖包" class="headerlink" title="安装项目所有的依赖包"></a>安装项目所有的依赖包</h3><pre><code>$ yarn
或
$ yarn install
</code></pre><p> Yarn命令列表</p>
</blockquote>
<table>
<thead>
<tr>
<th>命令</th>
<th>操作</th>
<th>参数</th>
<th>标签</th>
</tr>
</thead>
<tbody>
<tr>
<td>yarn add</td>
<td>添加依赖包</td>
<td>包名</td>
<td>–dev/-D</td>
</tr>
<tr>
<td>yarn bin</td>
<td>显示yarn安装目录</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>yarn cache</td>
<td>显示缓存</td>
<td>列出缓存包：ls，打出缓存目录路径：dir，清除缓存：clean</td>
<td>无</td>
</tr>
<tr>
<td>yarn check</td>
<td>检查包</td>
<td></td>
<td></td>
</tr>
<tr>
<td>yarn config</td>
<td>配置</td>
<td>设置：set <key> <value>， 删除：delete， 列出：list</value></key></td>
<td>[-g或–global]</td>
</tr>
<tr>
<td>yarn generate-lock-entry</td>
<td>生成锁定文件</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>yarn global</td>
<td>全局安装依赖包</td>
<td>yarn global <add bin="" ls="" remove="" upgrade=""> [–prefix]</add></td>
<td>–prefix 包路径前缀</td>
</tr>
<tr>
<td>yarn info</td>
<td>显示依赖包的信息</td>
<td>包名</td>
<td>–json：json格式显示结果</td>
</tr>
<tr>
<td>yarn init</td>
<td>互动式创建/更新package.json文件</td>
<td>无</td>
<td>–yes/-y：以默认值生成package.json文件</td>
</tr>
<tr>
<td>yarn install</td>
<td>安装所有依赖包</td>
<td></td>
<td>–flat：只安装一个版本；–force：强制重新下载安装；–har：输出安装时网络性能日志；–no-lockfile：不生成yarn.lock文件；–production：生产模式安装（不安装devDependencies中的依赖）</td>
</tr>
<tr>
<td>yarn licenses</td>
<td>列出已安装依赖包的证书</td>
<td>ls：证书列表；generate-disclaimer：生成免责声明</td>
<td></td>
</tr>
<tr>
<td>yarn link</td>
<td>开发时链接依赖包，以便在其他项目中使用</td>
<td>包名</td>
<td></td>
</tr>
<tr>
<td>yarn login</td>
<td>保存你的用户名、邮箱</td>
<td></td>
<td></td>
</tr>
<tr>
<td>yarn logout</td>
<td>删除你的用户名、邮箱</td>
<td></td>
<td></td>
</tr>
<tr>
<td>yarn list</td>
<td>列出已安装依赖包</td>
<td></td>
<td>–depth=0：列表深度，从0开始</td>
</tr>
<tr>
<td>yarn outdated</td>
<td>检查过时的依赖包</td>
<td>包名</td>
<td></td>
</tr>
<tr>
<td>yarn owner</td>
<td>管理拥有者</td>
<td>ls/add/remove</td>
<td></td>
</tr>
<tr>
<td>yarn pack</td>
<td>给包的依赖打包</td>
<td>–filename</td>
<td></td>
</tr>
<tr>
<td>yarn publish</td>
<td>将包发布到npm</td>
<td></td>
<td>–tag：版本标签；–access：公开（public）还是限制的（restricted）</td>
</tr>
<tr>
<td>yarn remove</td>
<td>卸载包，更新package.json和yarn.lock</td>
<td>包名</td>
<td></td>
</tr>
<tr>
<td>yarn run</td>
<td>运行package.json中预定义的脚本</td>
<td></td>
<td></td>
</tr>
<tr>
<td>yarn self-update</td>
<td>yarn自身更新–未实现</td>
<td></td>
<td></td>
</tr>
<tr>
<td>yarn tag</td>
<td>显示包的标签</td>
<td>add/rm/ls</td>
<td></td>
</tr>
<tr>
<td>yarn team</td>
<td>管理团队</td>
<td>create/destroy/add/rm/ls</td>
<td></td>
</tr>
<tr>
<td>yarn test</td>
<td>测试 = yarn run test</td>
<td></td>
<td></td>
</tr>
<tr>
<td>yarn unlink</td>
<td>取消链接依赖包</td>
<td></td>
<td></td>
</tr>
<tr>
<td>yarn upgrade</td>
<td>升级依赖包</td>
<td></td>
<td></td>
</tr>
<tr>
<td>yarn version</td>
<td>管理当前项目的版本号</td>
<td>–new-version ：直接记录版本号；–no-git-tag-version：不生成git标签</td>
<td></td>
</tr>
<tr>
<td>yarn why</td>
<td>分析为什么需要安装依赖包</td>
<td>包名/包目录/包目录中的文件名</td>
<td></td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Yarn介紹&quot;&gt;&lt;a href=&quot;#Yarn介紹&quot; class=&quot;headerlink&quot; title=&quot;Yarn介紹&quot;&gt;&lt;/a&gt;Yarn介紹&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Facebook发布的新一代包管理工具，旨在解决以往使用npm作为包管理会遇到的一
    
    </summary>
    
      <category term="Nodejs" scheme="http://donjote.github.io/categories/Nodejs/"/>
    
    
      <category term="Nodejs" scheme="http://donjote.github.io/tags/Nodejs/"/>
    
      <category term="Yarn" scheme="http://donjote.github.io/tags/Yarn/"/>
    
  </entry>
  
</feed>
