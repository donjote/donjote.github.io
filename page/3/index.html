<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />

    

    

    <title>Donjote 博客</title>
    <meta name="author" content="Donjote" />
    <meta name="version" content="1.0.0" />
    <meta name="keywords" content="undefined" />
    <meta name="description" content="null" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
    <meta name="baidu-site-verification" content="F0CXvmUgA9" />

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item active">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Tags</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Electron/">Electron</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang/">Golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NoSQL/">NoSQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nodejs/">Nodejs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RPC/">RPC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React-Native/">React Native</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Restful/">Restful</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TensorFlow/">TensorFlow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Weex/">Weex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Yarn/">Yarn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/etcd/">etcd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gRPC/">gRPC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm镜像/">npm镜像</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-boot/">spring boot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/事务/">事务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式架构/">分布式架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/区块链/">区块链</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微服务/">微服务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/敏捷开发/">敏捷开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务发现/">服务发现</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/深度学习/">深度学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/神经网络/">神经网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/跨平台/">跨平台</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">归档</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/about">关于</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://donjote.github.io"></form>

        
        

        
        <div class="author-meta">
            
            <div class="author-avatar">
                <a href="/">
                    <img src="/images/avatar.jpg" title="Sanonz">
                </a>
            </div>
            
            <div class="author-name">Donjote</div>
            <div class="author-work"></div>
            <div class="author-location">
                <i class="icon-location vm"></i>
                <span class="vm">Shenzhen, China</span>
            </div>
            
            <div class="author-thread-wrap">
                <div class="author-threads clearfix">
                    
                    <a class="thread-item" href="https://github.com/donjote" target="_blank" rel="noopener"><i class="icon-github"></i></a>
                    
                    
                    
                </div>
            </div>
            
        </div>
        
    </div>
</aside>

</header>

        <div id="content" class="content">
    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/07/09/electron_install/">快速搭建Electron开发环境</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/07/09/electron_install/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-07-08T16:00:00.000Z" itemprop="datePublished">2017-07-09</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Electron/">Electron</a>, <a class="article-tag-link" href="/tags/跨平台/">跨平台</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="Nodejs安装"><a href="#Nodejs安装" class="headerlink" title="Nodejs安装"></a>Nodejs安装</h2><blockquote>
<p>查看 <a href="https://donjote.github.io/2017/07/07/nodejs_install_config/">Nodejs安装并配置淘宝镜像</a></p>
</blockquote>
<h2 id="Electron的安装"><a href="#Electron的安装" class="headerlink" title="Electron的安装"></a>Electron的安装</h2><blockquote>
<p>在~/.npmrc里做如下设置</p>
<pre><code>electron_mirror=&quot;https://npm.taobao.org/mirrors/electron/&quot;
</code></pre><p>用下面的命令安装</p>
<pre><code>$ sudo npm install -g electron  
</code></pre></blockquote>
<h2 id="打包输出工具"><a href="#打包输出工具" class="headerlink" title="打包输出工具"></a>打包输出工具</h2><blockquote>
<p>为了方便最终成果输出，建议安装electron-packager工具，安装也很简单，建议以下面的命令全局安装。</p>
<pre><code>$ sudo npm install -g electron-packager
</code></pre></blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/07/09/electron_introdution/">Electron入门简介</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/07/09/electron_introdution/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-07-08T16:00:00.000Z" itemprop="datePublished">2017-07-09</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Electron/">Electron</a>, <a class="article-tag-link" href="/tags/跨平台/">跨平台</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>Electron 可以让你使用纯 JavaScript 调用丰富的原生 APIs 来创造桌面应用。你可以把它看作一个专注于桌面应用的 Node.js 的变体，而不是 Web 服务器。    </p>
<hr>
<p>这不意味着 Electron 是绑定了 GUI 库的 JavaScript。相反，Electron 使用 web 页面作为它的 GUI，所以你能把它看作成一个被 JavaScript 控制的，精简版的 Chromium 浏览器。</p>
</blockquote>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="主进程"><a href="#主进程" class="headerlink" title="主进程"></a>主进程</h3><blockquote>
<p>在 Electron 里，运行 package.json 里 main 脚本的进程被称为主进程。在主进程运行的脚本可以以创建 web 页面的形式展示 GUI。</p>
</blockquote>
<h3 id="渲染进程"><a href="#渲染进程" class="headerlink" title="渲染进程"></a>渲染进程</h3><blockquote>
<p>由于 Electron 使用 Chromium 来展示页面，所以 Chromium 的多进程结构也被充分利用。每个 Electron 的页面都在运行着自己的进程，这样的进程我们称之为渲染进程。</p>
<hr>
<p>在一般浏览器中，网页通常会在沙盒环境下运行，并且不允许访问原生资源。然而，Electron 用户拥有在网页中调用 Node.js 的 APIs 的能力，可以与底层操作系统直接交互。</p>
</blockquote>
<h3 id="主进程与渲染进程的区别"><a href="#主进程与渲染进程的区别" class="headerlink" title="主进程与渲染进程的区别"></a>主进程与渲染进程的区别</h3><blockquote>
<p>主进程使用 BrowserWindow 实例创建页面。每个 BrowserWindow 实例都在自己的渲染进程里运行页面。当一个 BrowserWindow 实例被销毁后，相应的渲染进程也会被终止。</p>
<hr>
<p>主进程管理所有页面和与之对应的渲染进程。每个渲染进程都是相互独立的，并且只关心他们自己的页面。</p>
<hr>
<p>由于在页面里管理原生 GUI 资源是非常危险而且容易造成资源泄露，所以在页面调用 GUI 相关的 APIs 是不被允许的。如果你想在网页里使用 GUI 操作，其对应的渲染进程必须与主进程进行通讯，请求主进程进行相关的 GUI 操作。</p>
<hr>
<p>在 Electron，提供几种方法用于主进程和渲染进程之间的通讯。像 ipcRenderer 和 ipcMain 模块用于发送消息， remote 模块用于 RPC 方式通讯。这些内容都可以在一个 FAQ 中查看 how to share data between web pages。</p>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/07/08/transaction/">事务</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/07/08/transaction/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-07-07T16:00:00.000Z" itemprop="datePublished">2017-07-08</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/事务/">事务</a>, <a class="article-tag-link" href="/tags/架构/">架构</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h2><blockquote>
<p>事务(Transaction)是访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。事务通常由高级数据库操纵语言或编程语言（如SQL，C++或Java）书写的用户程序的执行所引起，并用形如begin transaction和end transaction语句（或函数调用）来界定。事务由事务开始(begin transaction)和事务结束(end transaction)之间执行的全体操作组成。<br>事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。<br>事务的结束有两种，当事务中的所以步骤全部成功执行时，事务提交。如果其中一个步骤失败，将发生回滚操作，撤消撤消之前到事务开始时的所以操作。</p>
</blockquote>
<h2 id="事务的-ACID"><a href="#事务的-ACID" class="headerlink" title="事务的 ACID"></a>事务的 ACID</h2><blockquote>
<p>事务具有四个特征：原子性（ Atomicity ）、一致性（ Consistency ）、隔离性（ Isolation ）和持续性（ Durability ）。这四个特性简称为 ACID 特性。</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>事务的原子性指的是，事务中包含的程序作为数据库的逻辑工作单位，它所做的对数据修改操作要么全部执行，要么完全不执行。这种特性称为原子性。<br>事务的原子性要求，如果把一个事务可看作是一个程序，它要么完整的被执行，要么完全不执行。就是说事务的操纵序列或者完全应用到数据库或者完全不影响数据库。这种特性称为原子性。    </p>
<hr>
<p>假如用户在一个事务内完成了对数据库的更新，这时所有的更新对外部世界必须是可见的，或者完全没有更新。前者称事务已提交，后者称事务撤消（或流产）。DBMS必须确保由成功提交的事务完成的所有操纵在数据库内有完全的反映，而失败的事务对数据库完全没有影响。</p>
<h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。这种特性称为事务的一致性。假如数据库的状态满足所有的完整性约束，就说该数据库是一致的。</p>
<hr>
<p>一致性处理数据库中对所有语义约束的保护。假如数据库的状态满足所有的完整性约束，就说该数据库是一致的。例如，当数据库处于一致性状态S1时，对数据库执行一个事务，在事务执行期间假定数据库的状态是不一致的，当事务执行结束时，数据库处在一致性状态S2。</p>
<h3 id="分离性"><a href="#分离性" class="headerlink" title="分离性"></a>分离性</h3><p>分离性指并发的事务是相互隔离的。即一个事务内部的操作及正在操作的数据必须封锁起来，不被其它企图进行修改的事务看到。    分离性是DBMS针对并发事务间的冲突提供的安全保证。DBMS可以通过加锁在并发执行的事务间提供不同级别的分离。假如并发交叉执行的事务没有任何控制，操纵相同的共享对象的多个并发事务的执行可能引起异常情况。</p>
<hr>
<p>DBMS可以在并发执行的事务间提供不同级别的分离。分离的级别和并发事务的吞吐量之间存在反比关系。较多事务的可分离性可能会带来较高的冲突和较多的事务流产。流产的事务要消耗资源，这些资源必须要重新被访问。因此，确保高分离级别的DBMS需要更多的开销。</p>
<h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><p>持久性意味着当系统或介质发生故障时，确保已提交事务的更新不能丢失。即一旦一个事务提交，DBMS保证它对数据库中数据的改变应该是永久性的，耐得住任何系统故障。持久性通过数据库备份和恢复来保证。  </p>
<hr>
<p>持久性意味着当系统或介质发生故障时，确保已提交事务的更新不能丢失。即对已提交事务的更新能恢复。一旦一个事务被提交，DBMS必须保证提供适当的冗余，使其耐得住系统的故障。所以，持久性主要在于DBMS的恢复性能。</p>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/07/07/idempotent/">幂等性</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/07/07/idempotent/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-07-06T16:00:00.000Z" itemprop="datePublished">2017-07-07</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/分布式架构/">分布式架构</a>, <a class="article-tag-link" href="/tags/架构/">架构</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="幂等性定义"><a href="#幂等性定义" class="headerlink" title="幂等性定义"></a>幂等性定义</h2><h3 id="数学定义"><a href="#数学定义" class="headerlink" title="数学定义"></a>数学定义</h3><blockquote>
<p>在数学里，幂等有两种主要的定义：</p>
<ul>
<li>在某二元运算下，幂等元素是指被自己重复运算(或对于函数是为复合)的结果等于它自己的元素。例如，乘法下唯一两个幂等实数为0和1。 即 s * s = s</li>
<li>某一元运算为幂等的时，其作用在任一元素两次后会和其作用一次的结果相同。例如，高斯符号便是幂等的，即f(f(x)) = f(x)。</li>
</ul>
</blockquote>
<h3 id="HTTP规范的定义"><a href="#HTTP规范的定义" class="headerlink" title="HTTP规范的定义"></a>HTTP规范的定义</h3><blockquote>
<p>在HTTP/1.1规范中幂等性的定义是：</p>
<hr>
<p>Methods can also have the property of “idempotence” in that (aside from error or expiration issues) the side-effects of N &gt; 0 identical requests is the same as for a single request.</p>
<hr>
<p>从定义上看，HTTP方法的幂等性是指一次和多次请求某一个资源应该具有同样的副作用。幂等性属于语义范畴，正如编译器只能帮助检查语法错误一样，HTTP规范也没有办法通过消息格式等语法手段来定义它，这可能是它不太受到重视的原因之一。但实际上，幂等性是分布式系统设计中十分重要的概念，而HTTP的分布式本质也决定了它在HTTP中具有重要地位。</p>
</blockquote>
<h2 id="HTTP的幂等性"><a href="#HTTP的幂等性" class="headerlink" title="HTTP的幂等性"></a>HTTP的幂等性</h2><blockquote>
<p>HTTP协议本身是一种面向资源的应用层协议，但对HTTP协议的使用实际上存在着两种不同的方式：一种是RESTful的，它把HTTP当成应用层协议，比较忠实地遵守了HTTP协议的各种规定；另一种是SOA的，它并没有完全把HTTP当成应用层协议，而是把HTTP协议作为了传输层协议，然后在HTTP之上建立了自己的应用层协议。本文所讨论的HTTP幂等性主要针对RESTful风格的，不过正如上一节所看到的那样，幂等性并不属于特定的协议，它是分布式系统的一种特性；所以，不论是SOA还是RESTful的Web API设计都应该考虑幂等性。下面将介绍HTTP GET、DELETE、PUT、POST四种主要方法的语义和幂等性。</p>
<hr>
<p>HTTP GET方法用于获取资源，不应有副作用，所以是幂等的。</p>
<hr>
<p>HTTP DELETE方法用于删除资源，有副作用，但它应该满足幂等性。</p>
<hr>
<p>比较容易混淆的是HTTP POST和PUT。POST和PUT的区别容易被简单地误认为“POST表示创建资源，PUT表示更新资源”；而实际上，二者均可用于创建资源，更为本质的差别是在幂等性方面。在HTTP规范中对POST和PUT是这样定义的：</p>
<hr>
<p>The POST method is used to request that the origin server accept the entity enclosed in the request as a new subordinate of the resource identified by the Request-URI in the Request-Line …… If a resource has been created on the origin server, the response SHOULD be 201 (Created) and contain an entity which describes the status of the request and refers to the new resource, and a Location header.</p>
<hr>
<p>The PUT method requests that the enclosed entity be stored under the supplied Request-URI. If the Request-URI refers to an already existing resource, the enclosed entity SHOULD be considered as a modified version of the one residing on the origin server. If the Request-URI does not point to an existing resource, and that URI is capable of being defined as a new resource by the requesting user agent, the origin server can create the resource with that URI.</p>
<hr>
<p>POST所对应的URI并非创建的资源本身，而是资源的接收者。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，POST方法不具备幂等性。而PUT所对应的URI是要创建或更新的资源本身。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，PUT方法具有幂等性。</p>
</blockquote>
<h2 id="幂等的实现方案"><a href="#幂等的实现方案" class="headerlink" title="幂等的实现方案"></a>幂等的实现方案</h2><h3 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h3><blockquote>
<p>查询一次和查询多次，在数据不变的情况下，查询结果是一样的。select是天然的幂等操作</p>
</blockquote>
<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><blockquote>
<p>删除操作也是幂等的，删除一次和多次删除都是把数据删除。(注意可能返回结果不一样，删除的数据不存在，返回0，删除的数据多条，返回结果多个)</p>
</blockquote>
<h3 id="唯一索引，防止新增脏数据"><a href="#唯一索引，防止新增脏数据" class="headerlink" title="唯一索引，防止新增脏数据"></a>唯一索引，防止新增脏数据</h3><blockquote>
<p>比如：支付宝的资金账户，支付宝也有用户账户，每个用户只能有一个资金账户，怎么防止给用户创建资金账户多个，那么给资金账户表中的用户ID加唯一索引，所以一个用户新增成功一个资金账户记录</p>
<hr>
<p><strong>要点：<br>唯一索引或唯一组合索引来防止新增数据存在脏数据（当表存在唯一索引，并发时新增报错时，再查询一次就可以了，数据应该已经存在了，返回结果即可）</strong></p>
</blockquote>
<h3 id="token机制，防止页面重复提交"><a href="#token机制，防止页面重复提交" class="headerlink" title="token机制，防止页面重复提交"></a>token机制，防止页面重复提交</h3><blockquote>
<h4 id="业务要求："><a href="#业务要求：" class="headerlink" title="业务要求："></a>业务要求：</h4><p>页面的数据只能被点击提交一次</p>
<h4 id="发生原因："><a href="#发生原因：" class="headerlink" title="发生原因："></a>发生原因：</h4><p>由于重复点击或者网络重发，或者nginx重发等情况会导致数据被重复提交</p>
<h4 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h4><p>集群环境：采用token加redis（redis单线程的，处理需要排队）<br>单JVM环境：采用token加redis或token加jvm内存</p>
<h4 id="处理流程："><a href="#处理流程：" class="headerlink" title="处理流程："></a>处理流程：</h4><ol>
<li>数据提交前要向服务的申请token，token放到redis或jvm内存，token有效时间</li>
<li>提交后后台校验token，同时删除token，生成新的token返回<h4 id="token特点："><a href="#token特点：" class="headerlink" title="token特点："></a>token特点：</h4>要申请，一次有效性，可以限流</li>
</ol>
<hr>
<p><strong>注意：<br>redis要用删除操作来判断token，删除成功代表token校验通过，如果用select+delete来校验token，存在并发问题，不建议使用</strong></p>
</blockquote>
<h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><blockquote>
<p>获取数据的时候加锁获取<br>select * from table_xxx where id=’xxx’ for update;<br>注意：id字段一定是主键或者唯一索引，不然是锁表，会死人的<br>悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，根据实际情况选用</p>
</blockquote>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><blockquote>
<p>乐观锁只是在更新数据那一刻锁表，其他时间不锁表，所以相对于悲观锁，效率更高。<br>乐观锁的实现方式多种多样可以通过version或者其他状态条件：</p>
<ol>
<li>通过版本号实现<br>update table_xxx set name=#name#,version=version+1 where version=#version#<br>如下图(来自网上)：<br><img src="/2017/07/07/idempotent/1.png" alt="乐观锁"></li>
<li>通过条件限制<br>update table_xxx set avai_amount=avai_amount-#subAmount# where avai_amount-#subAmount# &gt;= 0<br>要求：quality-#subQuality# &gt;= ，这个情景适合不用版本号，只更新是做数据安全校验，适合库存模型，扣份额和回滚份额，性能更高</li>
</ol>
<hr>
<p><strong>注意：乐观锁的更新操作，最好用主键或者唯一索引来更新,这样是行锁，否则更新时会锁表，上面两个sql改成下面的两个更好<br>update table_xxx set name=#name#,version=version+1 where id=#id# and version=#version#<br>update table_xxx set avai_amount=avai_amount-#subAmount# where id=#id# and avai_amount-#subAmount# &gt;= 0</strong></p>
</blockquote>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><blockquote>
<p>还是拿插入数据的例子，如果是分布是系统，构建全局唯一索引比较困难，例如唯一性的字段没法确定，这时候可以引入分布式锁，通过第三方的系统(redis或zookeeper)，在业务系统插入数据或者更新数据，获取分布式锁，然后做操作，之后释放锁，这样其实是把多线程并发的锁的思路，引入多多个系统，也就是分布式系统中得解决思路。</p>
<hr>
<p><strong>要点：某个长流程处理过程要求不能并发执行，可以在流程执行之前根据某个标志(用户ID+后缀等)获取分布式锁，其他流程执行时获取锁就会失败，也就是同一时间该流程只能有一个能执行成功，执行完成后，释放分布式锁(分布式锁要第三方系统提供)</strong></p>
</blockquote>
<h3 id="select-insert"><a href="#select-insert" class="headerlink" title="select + insert"></a>select + insert</h3><blockquote>
<p>并发不高的后台系统，或者一些任务JOB，为了支持幂等，支持重复执行，简单的处理方法是，先查询下一些关键数据，判断是否已经执行过，在进行业务处理，就可以了</p>
<hr>
<p><strong>注意：核心高并发流程不要用这种方法</strong></p>
</blockquote>
<h3 id="状态机幂等"><a href="#状态机幂等" class="headerlink" title="状态机幂等"></a>状态机幂等</h3><blockquote>
<p>在设计单据相关的业务，或者是任务相关的业务，肯定会涉及到状态机(状态变更图)，就是业务单据上面有个状态，状态在不同的情况下会发生变更，一般情况下存在有限状态机，这时候，如果状态机已经处于下一个状态，这时候来了一个上一个状态的变更，理论上是不能够变更的，这样的话，保证了有限状态机的幂等。</p>
</blockquote>
<h3 id="对外提供接口的api如何保证幂等"><a href="#对外提供接口的api如何保证幂等" class="headerlink" title="对外提供接口的api如何保证幂等"></a>对外提供接口的api如何保证幂等</h3><blockquote>
<p>如银联提供的付款接口：需要接入商户提交付款请求时附带：source来源，seq序列号<br>source+seq在数据库里面做唯一索引，防止多次付款，(并发时，只能处理一个请求)</p>
<hr>
<p><strong>重点：<br>对外提供接口为了支持幂等调用，接口有两个字段必须传，一个是来源source，一个是来源方序列号seq，这个两个字段在提供方系统里面做联合唯一索引，这样当第三方调用时，先在本方系统里面查询一下，是否已经处理过，返回相应处理结果；没有处理过，进行相应处理，返回结果。注意，为了幂等友好，一定要先查询一下，是否处理过该笔业务，不查询直接插入业务系统，会报错，但实际已经处理了。</strong></p>
</blockquote>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><blockquote>
<p>幂等性应该是合格程序员的一个基因，在设计系统时，是首要考虑的问题，尤其是在像支付宝，银行，互联网金融公司等涉及的都是钱的系统，既要高效，数据也要准确，所以不能出现多扣款，多打款等问题，这样会很难处理，用户体验也不好</p>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/07/06/agile_development/">敏捷开发</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/07/06/agile_development/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-07-05T16:00:00.000Z" itemprop="datePublished">2017-07-06</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/敏捷开发/">敏捷开发</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <blockquote>
<p>随着敏捷开发越来越流行，人人都在谈敏捷，人人也都在学习scrum等敏捷开发方法。。。</p>
</blockquote>
<h2 id="什么是敏捷开发"><a href="#什么是敏捷开发" class="headerlink" title="什么是敏捷开发"></a>什么是敏捷开发</h2><blockquote>
<p>敏捷开发（Agile Development）不是指某一种具体的方法论、过程或框架，而是一组价值观和原则。是一种以人为核心、迭代、循序渐进的开发方法。</p>
</blockquote>
<h3 id="怎么理解呢？"><a href="#怎么理解呢？" class="headerlink" title="怎么理解呢？"></a>怎么理解呢？</h3><blockquote>
<ul>
<li>首先，敏捷并不是一门具体的技术，而是一种理念或者说是一种思想。也就是一种软件开发的流程，它会指导我们用规定的环节去一步一步完成项目的开发；而这种开发方式的主要驱动核心是人；它采用的是迭代式开发；</li>
<li>其次，敏捷开发都具有以下共同的特征：<ol>
<li>迭代式开发</li>
<li>增量交付</li>
<li>开发团队和用户反馈推动产品开发</li>
<li>持续集成</li>
<li>开发团队自我管理</li>
</ol>
</li>
<li>最后，相比于“传统”的瀑布开发模式，敏捷开发是一种“现代”的开发模式。</li>
</ul>
</blockquote>
<h3 id="为什么说是以人为核心？"><a href="#为什么说是以人为核心？" class="headerlink" title="为什么说是以人为核心？"></a>为什么说是以人为核心？</h3><blockquote>
<p>我们大部分人都学过瀑布开发模型，它是以文档为驱动的，为什么呢？因为在瀑布的整个开发过程中，要写大量的文档，把需求文档写出来后，开发人员都是根据文档进行开发的，一切以文档为依据；而敏捷开发它只写有必要的文档，或尽量少写文档，敏开发注重的是人与人之间，面对面的交流，所以它强调以人为核心。</p>
</blockquote>
<h3 id="什么是迭代？"><a href="#什么是迭代？" class="headerlink" title="什么是迭代？"></a>什么是迭代？</h3><blockquote>
<p>迭代是指把一个复杂且开发周期很长的开发任务，分解为很多小周期可完成的任务，这样的一个周期就是一次迭代的过程；同时每一次迭代都可以生产或开发出一个可以交付的软件产品。</p>
</blockquote>
<h2 id="敏捷开发宣言"><a href="#敏捷开发宣言" class="headerlink" title="敏捷开发宣言"></a>敏捷开发宣言</h2><blockquote>
<p><strong>《敏捷宣言》</strong></p>
<p>我们通过身体力行和帮助他人来揭示更好的软件开发方式。经由这项工作，我们形成了如下价值观：</p>
<p><strong>个体与交互 重于 过程和工具<br>可用的软件 重于 完备的文档<br>客户协作 重于 合同谈判<br>响应变化 重于 遵循计划</strong></p>
<p>在每对比对中，后者并非全无价值，但我们更看重前者</p>
</blockquote>
<p>敏捷宣言是对敏捷的高度总结和升华，即使现在不理解也没有问题，在实践的过程中我们会逐渐对它有一个深刻的认识。</p>
<h2 id="敏捷开发十二原则"><a href="#敏捷开发十二原则" class="headerlink" title="敏捷开发十二原则"></a>敏捷开发十二原则</h2><blockquote>
<p>在敏捷开发中，我们遵循以下准则：</p>
<ol>
<li>我们的最高目标是，通过尽早和持续地交付有价值的软件来满足客户。</li>
<li>欢迎对需求提出变更——即使是在项目开发后期。要善于利用需求变更，帮助客户获得竞争优势。</li>
<li>要不断交付可用的软件，周期从几周到几个月不等，且越短越好</li>
<li>项目过程中，业务人员与开发人员必须在一起工作。</li>
<li>要善于激励项目人员，给他们以所需要的环境和支持，并相信他们能够完成任务。</li>
<li>无论是团队内还是团队间，最有效的沟通方法是面对面的交谈。</li>
<li>可用的软件是衡量进度的主要指标。</li>
<li>敏捷过程提倡可持续的开发。项目方、开发人员和用户应该能够保持恒久稳定的进展速度。</li>
<li>对技术的精益求精以及对设计的不断完善将提升敏捷性。</li>
<li>要做到简洁，即尽最大可能减少不必要的工作。这是一门艺术。</li>
<li>最佳的架构、需求和设计出自于自组织的团队。</li>
<li>团队要定期反省如何能够做到更有效，并相应地调整团队的行为。</li>
</ol>
</blockquote>
<h2 id="关于Scrum和XP"><a href="#关于Scrum和XP" class="headerlink" title="关于Scrum和XP"></a>关于Scrum和XP</h2><blockquote>
<p>前面说了敏捷它是一种指导思想或开发方式，但是它没有明确告诉我们到底采用什么样的流程进行开发，而Scrum和XP就是敏捷开发的具体方式了，你可以采用Scrum方式也可以采用XP方式；Scrum和XP的区别是，Scrum偏重于过程，XP则偏重于实践，但是实际中，两者是结合一起应用的，这里主要讲Scrum。</p>
</blockquote>
<h2 id="什么是Scrum？"><a href="#什么是Scrum？" class="headerlink" title="什么是Scrum？"></a>什么是Scrum？</h2><blockquote>
<p>Scrum的英文意思是橄榄球运动的一个专业术语，表示“争球”的动作；把一个开发流程的名字取名为Scrum，我想你一定能想象出你的开发团队在开发一个项目时，大家像打橄榄球一样迅速、富有战斗激情、人人你争我抢地完成它，你一定会感到非常兴奋的。<br>而Scrum就是这样的一个开发流程，运用该流程，你就能看到你团队高效的工作。</p>
<h3 id="【Scrum开发流程中的三大角色】"><a href="#【Scrum开发流程中的三大角色】" class="headerlink" title="【Scrum开发流程中的三大角色】"></a><strong>【Scrum开发流程中的三大角色】</strong></h3><h4 id="产品负责人（Product-Owner）"><a href="#产品负责人（Product-Owner）" class="headerlink" title="产品负责人（Product Owner）"></a><em>产品负责人（Product Owner）</em></h4><p>主要负责确定产品的功能和达到要求的标准，指定软件的发布日期和交付的内容，同时有权力接受或拒绝开发团队的工作成果。</p>
<h4 id="流程管理员（Scrum-Master）"><a href="#流程管理员（Scrum-Master）" class="headerlink" title="流程管理员（Scrum Master）"></a><em>流程管理员（Scrum Master）</em></h4><p>主要负责整个Scrum流程在项目中的顺利实施和进行，以及清除挡在客户和开发工作之间的沟通障碍，使得客户可以直接驱动开发。</p>
<h4 id="开发团队（Scrum-Team）"><a href="#开发团队（Scrum-Team）" class="headerlink" title="开发团队（Scrum Team）"></a><em>开发团队（Scrum Team）</em></h4><p>主要负责软件产品在Scrum规定流程下进行开发工作，人数控制在5~10人左右，每个成员可能负责不同的技术方面，但要求每成员必须要有很强的自我管理能力，同时具有一定的表达能力；成员可以采用任何工作方式，只要能达到Sprint的目标。</p>
</blockquote>
<h2 id="Scrum流程图"><a href="#Scrum流程图" class="headerlink" title="Scrum流程图"></a><strong>Scrum流程图</strong></h2><blockquote>
<p><img src="/2017/07/06/agile_development/ScrumModel.jpg" alt="Scrum流程图"></p>
</blockquote>
<h3 id="什么是Sprint？"><a href="#什么是Sprint？" class="headerlink" title="什么是Sprint？"></a>什么是Sprint？</h3><blockquote>
<p>Sprint是短距离赛跑的意思，这里面指的是一次迭代，而一次迭代的周期是1个月时间（即4个星期），也就是我们要把一次迭代的开发内容以最快的速度完成它，这个过程我们称它为Sprint。</p>
</blockquote>
<h3 id="如何进行Scrum开发？"><a href="#如何进行Scrum开发？" class="headerlink" title="如何进行Scrum开发？"></a>如何进行Scrum开发？</h3><blockquote>
<ol>
<li>我们首先需要确定一个Product Backlog（按优先顺序排列的一个产品需求列表），这个是由Product Owner 负责的；</li>
<li>Scrum Team根据Product Backlog列表，做工作量的预估和安排；</li>
<li>有了Product Backlog列表，我们需要通过 Sprint Planning Meeting（Sprint计划会议） 来从中挑选出一个Story作为本次迭代完成的目标，这个目标的时间周期是1~4个星期，然后把这个Story进行细化，形成一个Sprint Backlog；</li>
<li>Sprint Backlog是由Scrum Team去完成的，每个成员根据Sprint Backlog再细化成更小的任务（细到每个任务的工作量在2天内能完成）；</li>
<li>在Scrum Team完成计划会议上选出的Sprint Backlog过程中，需要进行 Daily Scrum Meeting（每日站立会议），每次会议控制在15分钟左右，每个人都必须发言，并且要向所有成员当面汇报你昨天完成了什么，并且向所有成员承诺你今天要完成什么，同时遇到不能解决的问题也可以提出，每个人回答完成后，要走到黑板前更新自己的 Sprint burn down（Sprint燃尽图）；</li>
<li>做到每日集成，也就是每天都要有一个可以成功编译、并且可以演示的版本；很多人可能还没有用过自动化的每日集成，其实TFS就有这个功能，它可以支持每次有成员进行签入操作的时候，在服务器上自动获取最新版本，然后在服务器中编译，如果通过则马上再执行单元测试代码，如果也全部通过，则将该版本发布，这时一次正式的签入操作才保存到TFS中，中间有任何失败，都会用邮件通知项目管理人员；</li>
<li>当一个Story完成，也就是Sprint Backlog被完成，也就表示一次Sprint完成，这时，我们要进行 Srpint Review Meeting（演示会议），也称为评审会议，产品负责人和客户都要参加（最好本公司老板也参加），每一个Scrum Team的成员都要向他们演示自己完成的软件产品（这个会议非常重要，一定不能取消）；</li>
<li>最后就是 Sprint Retrospective Meeting（回顾会议），也称为总结会议，以轮流发言方式进行，每个人都要发言，总结并讨论改进的地方，放入下一轮Sprint的产品需求中；</li>
</ol>
</blockquote>
<p>下面是运用Scrum开发流程中的一些场景图：</p>
<blockquote>
<p><img src="/2017/07/06/agile_development/1.png" alt="产品需求"></p>
</blockquote>
<p>上图是一个 Product Backlog 的示例。</p>
<blockquote>
<p><img src="/2017/07/06/agile_development/2.png" alt="每日站会"></p>
</blockquote>
<p>上图就是每日的站立会议了，参会人员可以随意姿势站立，任务看板要保证让每个人看到，当每个人发言完后，要走到任务版前更新自己的燃尽图。</p>
<blockquote>
<p><img src="/2017/07/06/agile_development/3.png" alt="任务看板"></p>
</blockquote>
<p>任务看版包含 未完成、正在做、已完成 的工作状态，假设你今天把一个未完成的工作已经完成，那么你要把小卡片从未完成区域贴到已完成区域。</p>
<blockquote>
<p><img src="/2017/07/06/agile_development/4.png" alt="任务看板"></p>
</blockquote>
<p>每个人的工作进度和完成情况都是公开的，如果有一个人的工作任务在某一个位置放了好几天，大家都能发现他的工作进度出现了什么问题（成员人数最好是5~7个，这样每人可以使用一种专用颜色的标签纸，一眼就可以从任务版看出谁的工作进度快，谁的工作进度慢）</p>
<blockquote>
<p><img src="/2017/07/06/agile_development/5.png" alt="计划纸牌"></p>
</blockquote>
<p>上图可不是扑克牌，它是计划纸牌，它的作用是防止项目在开发过程中，被某些人所领导。</p>
<p>怎么用的呢？比如A程序员开发一个功能，需要5个小时，B程序员认为只需要半小时，那他们各自取相应的牌，藏在手中，最后摊牌，如果时间差距很大，那么A和B就可以讨论A为什么要5个小时…</p>
<p>一个免费在线敏捷开发工具截图</p>
<blockquote>
<p><img src="/2017/07/06/agile_development/6.png" alt="鱼骨-敏捷开发"></p>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/07/05/nodejs_install_config/">Nodejs安装并配置淘宝镜像</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/07/05/nodejs_install_config/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-07-04T16:00:00.000Z" itemprop="datePublished">2017-07-05</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Nodejs/">Nodejs</a>, <a class="article-tag-link" href="/tags/npm镜像/">npm镜像</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><blockquote>
<p>安装 Node.js 方式多种多样，最简单的方式是在<a href="https://nodejs.org/en/" target="_blank" rel="external">Node.js 官网</a> 下载可执行程序直接安装即可。</p>
<ul>
<li>对于 Mac，可以使用 <a href="http://brew.sh/" target="_blank" rel="external">Homebrew</a> 进行安装：<pre><code>brew install node
</code></pre>更多安装方式可参考 <a href="https://nodejs.org/en/download/" target="_blank" rel="external">Node.js 官方信息</a></li>
<li>安装完成后，可以使用以下命令检测是否安装成功:<pre><code>$ node -v
v6.11.0
$ npm -v
3.10.10
</code></pre></li>
</ul>
</blockquote>
<h2 id="配置Node-js"><a href="#配置Node-js" class="headerlink" title="配置Node.js"></a>配置Node.js</h2><blockquote>
<p>使用淘宝的 npm 镜像</p>
<ul>
<li>通过config命令<pre><code>$ npm config set registry https://registry.npm.taobao.org   
$ npm info underscore （如果上面配置正确这个命令会有字符串response）
</code></pre></li>
<li>命令行指定<pre><code>$ npm --registry https://registry.npm.taobao.org info underscore    
</code></pre></li>
<li>编辑 ~/.npmrc 加入下面内容<pre><code>registry = https://registry.npm.taobao.org
</code></pre></li>
</ul>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/07/04/weex_react_native/">Weex、React Native 对比</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/07/04/weex_react_native/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-07-03T16:00:00.000Z" itemprop="datePublished">2017-07-04</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/React-Native/">React Native</a>, <a class="article-tag-link" href="/tags/Weex/">Weex</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="App三种开发模式"><a href="#App三种开发模式" class="headerlink" title="App三种开发模式"></a>App三种开发模式</h2><blockquote>
<p>目前主流的应用大体分成三类：Native App（原生APP）, Web App(H5开发模式), Hybrid App（混合模式）.<br><img src="/2017/07/04/weex_react_native/1.png" alt="App三种开发模式"></p>
</blockquote>
<h3 id="Native-App特点"><a href="#Native-App特点" class="headerlink" title="Native App特点:"></a>Native App特点:</h3><blockquote>
<ul>
<li>性能好</li>
<li>完美的用户体验</li>
<li>开发成本高，无法跨平台</li>
<li>升级困难(审核),维护成本高</li>
</ul>
</blockquote>
<h3 id="Web-App特点"><a href="#Web-App特点" class="headerlink" title="Web App特点:"></a>Web App特点:</h3><blockquote>
<ul>
<li>开发成本低,更新快,版本升级容易,自动升级</li>
<li>跨平台，Write Once , Run Anywhere</li>
<li>无法调用系统级的API</li>
<li>临时入口，用户留存度低</li>
<li>性能差,体验差,设计受限制</li>
<li>相比Native App，Web App体验中受限于以上5个因素：网络环境，渲染性能，平台特性，受限于浏览器，系统限制。</li>
</ul>
</blockquote>
<h3 id="Hybrid-App特点"><a href="#Hybrid-App特点" class="headerlink" title="Hybrid App特点:"></a>Hybrid App特点:</h3><blockquote>
<ul>
<li>Native App 和 Web App 折中的方案，保留了 Native App 和 Web App 的优点。</li>
<li>但是还是性能差。页面渲染效率低，在Webview中绘制界面，实现动画，资源消耗都比较大,受限于技术,网速等因素</li>
</ul>
</blockquote>
<p>  <img src="/2017/07/04/weex_react_native/2.png" alt="App三种开发模式对比"></p>
<h2 id="Hybrid-App开发框架"><a href="#Hybrid-App开发框架" class="headerlink" title="Hybrid App开发框架"></a>Hybrid App开发框架</h2><h3 id="weex"><a href="#weex" class="headerlink" title="weex"></a>weex</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><blockquote>
<p>weex是阿里巴巴公司与2016年6月开源的一种用于构建移动跨平台的UI框架</p>
</blockquote>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点:"></a>特点:</h4><blockquote>
<ul>
<li>Lightweight:轻量级,语法简单,易于使用</li>
<li>Extendable:可扩展,丰富内置组件,可扩展的API,</li>
<li>High Performance:高性能</li>
<li>核心理念:<ul>
<li>Write Once Run Everywhere</li>
<li>基于JS开发框架:</li>
<li>weex基于vue.js</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="React-Native"><a href="#React-Native" class="headerlink" title="React Native"></a>React Native</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介:"></a>简介:</h4><blockquote>
<p>Facebook在2015年3月在F8开发者大会上开源的跨平台UI框架</p>
</blockquote>
<h4 id="核心理念"><a href="#核心理念" class="headerlink" title="核心理念:"></a>核心理念:</h4><blockquote>
<p>LEARN ONCE, WRITE ANYWHERE</p>
</blockquote>
<h4 id="基于JS开发框架"><a href="#基于JS开发框架" class="headerlink" title="基于JS开发框架:"></a>基于JS开发框架:</h4><blockquote>
<p>React Native基于React</p>
</blockquote>
<h2 id="知识拓展-vue-js和React"><a href="#知识拓展-vue-js和React" class="headerlink" title="知识拓展:vue.js和React"></a>知识拓展:vue.js和React</h2><h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue:"></a>Vue:</h3><blockquote>
<p>是一个构建数据驱动的 web 界面的库。Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件.</p>
</blockquote>
<h3 id="React"><a href="#React" class="headerlink" title="React:"></a>React:</h3><blockquote>
<p>基于HTML的前端界面开发正变得越来越复杂，其本质问题基本都可以归结于如何将来自于服务器端或者用户输入的动态数据高效的反映到复杂的用户界面上。而来自Facebook的React框架正是完全面向此问题的一个解决方案，按官网描述，其出发点为：用于开发数据不断变化的大型应用程序。相比传统型的前端开发，React开辟了一个相当另类的途径，实现了前端界面的高效率高性能开发。</p>
</blockquote>
<h3 id="Vue-js和React的异同"><a href="#Vue-js和React的异同" class="headerlink" title="Vue.js和React的异同:"></a>Vue.js和React的异同:</h3><blockquote>
<p><a href="https://cn.vuejs.org/v2/guide/comparison.html" target="_blank" rel="external">Vue和React的区别</a></p>
</blockquote>
<h2 id="Weex和React-Native的异同"><a href="#Weex和React-Native的异同" class="headerlink" title="Weex和React Native的异同"></a>Weex和React Native的异同</h2><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点:"></a>相同点:</h3><blockquote>
<ul>
<li>都采用Web的开发模式，使用JS开发；</li>
<li>都可以直接在Chrome中调试JS代码；</li>
<li>都支持跨平台的开发；</li>
<li>都可以实现hot reload，边更新代码边查看效果；</li>
</ul>
</blockquote>
<h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点:"></a>不同点:</h3><blockquote>
<h4 id="JS引擎"><a href="#JS引擎" class="headerlink" title="JS引擎"></a>JS引擎</h4><p>  <a href="https://zh.wikipedia.org/wiki/JavaScript%E5%BC%95%E6%93%8E" target="_blank" rel="external">什么是JS引擎</a></p>
<h4 id="学习成本"><a href="#学习成本" class="headerlink" title="学习成本"></a>学习成本</h4><h5 id="环境配置："><a href="#环境配置：" class="headerlink" title="环境配置："></a>环境配置：</h5><p>ReactNative需要按照文档安装配置很多依赖的工具，相对比较麻烦。 weex安装cli之后就可以使用</p>
<h6 id="vue-vs-react-上面已经做过对比"><a href="#vue-vs-react-上面已经做过对比" class="headerlink" title="vue vs react:上面已经做过对比"></a>vue vs react:上面已经做过对比</h6><p>react模板JSX学习使用有一定的成本 vue更接近常用的web开发方式，模板就是普通的html，数据绑定使用mustache风格，样式直接使用css</p>
<h4 id="社区支持"><a href="#社区支持" class="headerlink" title="社区支持"></a>社区支持</h4><ul>
<li>Weex开源较晚，互联网上相关资料还比较少，社区规模较小；</li>
<li>React Native社区则比较活跃，可以参考的项目和资料也比较丰富</li>
</ul>
</blockquote>
<p>一张图:从渲染时间,内存使用,CPU占用,帧率(图形处理器每秒钟能够刷新几次,高的帧率可以得到更流畅、更逼真的动画。每秒钟帧数 （fps） 愈多，所显示的动作就会愈流畅。)<br>  <img src="/2017/07/04/weex_react_native/3.png" alt="App三种开发模式对比"></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/07/04/micro_services_1/">微服务简介</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/07/04/micro_services_1/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-07-03T16:00:00.000Z" itemprop="datePublished">2017-07-04</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/微服务/">微服务</a>, <a class="article-tag-link" href="/tags/架构/">架构</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="Monolithic架构"><a href="#Monolithic架构" class="headerlink" title="Monolithic架构"></a>Monolithic架构</h2><blockquote>
<p><img src="/2017/07/04/micro_services_1/1.png" alt="Monolithic架构"><br>Monolithic比较适合小项目</p>
<h3 id="Monolithic架构优点"><a href="#Monolithic架构优点" class="headerlink" title="Monolithic架构优点"></a>Monolithic架构优点</h3><ul>
<li>开发简单直接，集中式管理, 基本不会重复开发</li>
<li>功能都在本地，没有分布式的管理开销和调用开销。<h3 id="Monolithic架构缺点"><a href="#Monolithic架构缺点" class="headerlink" title="Monolithic架构缺点"></a>Monolithic架构缺点</h3>它的缺点也非常明显，特别对于互联网公司来说（不一一列举了）：</li>
<li>开发效率低：所有的开发在一个项目改代码，递交代码相互等待，代码冲突不断</li>
<li>代码维护难：代码功能耦合在一起，新人不知道何从下手</li>
<li>部署不灵活：构建时间长，任何小修改必须重新构建整个项目，这个过程往往很长</li>
<li>稳定性不高：一个微不足道的小问题，可以导致整个应用挂掉</li>
<li>扩展性不够：无法满足高并发情况下的业务需求</li>
</ul>
</blockquote>
<h2 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h2><h3 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h3><blockquote>
<p>相对于单体（Monolithic）应用而言，微服务是采用一组服务的方式来构建一个应用，服务独立部署在不同的进程中，不同服务通过一些轻量级交互机制来通信，例如 RPC、HTTP 等,服务可独立扩展伸缩，每个服务定义了明确的边界，不同的服务甚至可以采用不同的编程语言来实现，由独立的团队来维护。</p>
</blockquote>
<h3 id="微服务的价值"><a href="#微服务的价值" class="headerlink" title="微服务的价值"></a>微服务的价值</h3><blockquote>
<ul>
<li>首先，在功能不变的情况下，应用被分解为多个可管理的服务，每个服务开发、运维变得简单。</li>
<li>其次，每个微服务独立部署，开发者不在需要协调其他服务部署对本服务的影响，这可以加快部署精度。</li>
<li>最后，每个服务可以自行决定自己的容量。</li>
</ul>
<hr>
<p>虽然对于一些简单的、规模有限的应用而言，单体架构仍然是有意义的。微服务是应用开发和部署的一个不同的方法。它非常适合许多现代的云应用对于敏捷性、扩展规模和可靠性的要求。一个微服务应用被分解成独立的部件，被称为“微服务”。“微服务”协同工作，以便提供应用的整体功能。“微服务”这一术语强调一个事实，那就是应用应该是由足够小的服务所组成，以便真正体现独立性，使得每个微服务实现单一的功能。此外，每个微服务都有明确的合同（API合同）——通常是RESTful 的——以便其他微服务能够与之进行交流和分享数据。微服务也必须能够彼此独立地进行版本更新。这种松耦合正是对一个应用实现快速而可靠地演化的支撑。下图显示了一个单体应用是如何被分解为不同的微服务的。<br><img src="/2017/07/04/micro_services_1/2.png" alt="微服务架构"></p>
<h3 id="微服务的特点"><a href="#微服务的特点" class="headerlink" title="微服务的特点"></a>微服务的特点</h3><ul>
<li>小, 且专注于做⼀件事情</li>
<li>进程独立</li>
<li>轻量级的通信机制</li>
<li>松耦合</li>
<li>独立部署</li>
</ul>
<hr>
<p><strong>领域驱动设计：</strong> 应用程序功能分解可以通过Eric Evans在<a href="http://www.jdon.com/ddd.html" target="_blank" rel="external">《领域驱动设计》</a>中明确定义的规则实现；每个团队负责与一个领域或业务功能相关的全部开发；团队拥有全系列的开发人员，具备用户界面、业务逻辑和持久化存储等方面的开发技能；<br><strong>单一职责原则：</strong> 每个服务应该负责该功能的一个单独的部分，这是<a href="http://www.cnblogs.com/shanyou/archive/2009/09/21/1570716.html" target="_blank" rel="external">面向对象设计的SOLID原则</a>原则之一；<br><strong>明确发布接口：</strong> 每个服务都会发布一个定义明确的接口，而且保持不变；服务消费者只关心接口，而对于被消费的服务没有任何运行依赖；<br><strong>独立部署、升级、扩展和替换：</strong> 每个服务都可以单独部署及重新部署而不影响整个系统。这使得服务很容易升级，每个服务都可以沿着<a href="https://pan.baidu.com/s/1qYpzBPE" target="_blank" rel="external">《架构即未来》</a>一书定义的<a href="http://www.jianshu.com/p/d08d0c14810f" target="_blank" rel="external">AKF扩展立方体</a>的X轴和Z轴进行扩展；<br><strong>可以异构/采用多种语言：</strong>　每个服务的实现细节都与其它服务无关，这使得服务之间能够解耦，团队可以针对每个服务选择最合适的开发语言、持久化存储、工具和方法；<br><strong>轻量级通信：</strong>　服务通信使用轻量级的通信协议，例如，同步的REST，异步的AMQP、STOMP、MQTT等。</p>
<hr>
<p>微服务架构的思想本质跟互联网的思想是一致的。它的组件对外发布的服务视同HTTP协议，采用HTTP Rest API的方式来进行。很多开放平台的API服务，基本都采用了Http API的方式进行服务的发布和管理。</p>
</blockquote>
<h3 id="微服务优点"><a href="#微服务优点" class="headerlink" title="微服务优点"></a>微服务优点</h3><blockquote>
<ul>
<li>每个微服务都很小，这样能聚焦一个指定的业务功能或业务需求。</li>
<li>微服务能够被小团队单独开发，这个小团队是2到5人的开发人员组成。</li>
<li>微服务是松耦合的，是有功能意义的服务，无论是在开发阶段或部署阶段都是独立的。</li>
<li>微服务能使用不同的语言开发。</li>
<li>微服务允许容易且灵活的方式集成自动部署，通过持续集成工具，如Jenkins, bamboo 。</li>
<li>一个团队的新成员能够更快投入生产。</li>
<li>微服务易于被一个开发人员理解，修改和维护，这样小团队能够更关注自己的工作成果。无需通过合作才能体现价值。</li>
<li>微服务允许你利用融合最新技术。</li>
<li>微服务只是业务逻辑的代码，不会和HTML,CSS 或其他界面组件混合。</li>
<li>微服务能够即时被要求扩展。</li>
<li>微服务能部署中低端配置的服务器上。</li>
<li>易于和第三方集成。</li>
<li>每个微服务都有自己的存储能力，可以有自己的数据库。也可以有统一数据库。</li>
</ul>
</blockquote>
<h3 id="微服务架构的缺点"><a href="#微服务架构的缺点" class="headerlink" title="微服务架构的缺点"></a>微服务架构的缺点</h3><blockquote>
<ul>
<li>微服务架构可能带来过多的操作。</li>
<li>需要DevOps技巧 (<a href="http://en.wikipedia.org/wiki/DevOps" target="_blank" rel="external">http://en.wikipedia.org/wiki/DevOps</a>).</li>
<li>可能双倍的努力。</li>
<li>分布式系统可能复杂难以管理。</li>
<li>因为分布部署跟踪问题难。</li>
<li>服务数量增加，管理复杂性增加。</li>
</ul>
</blockquote>
<h3 id="常见的微服务组件"><a href="#常见的微服务组件" class="headerlink" title="常见的微服务组件"></a>常见的微服务组件</h3><blockquote>
<ul>
<li>服务注册:服务提供方将自己调用地址注册到服务注册中心，让服务调用方能够方便地找到自己。</li>
<li>服务发现:服务调用方从服务注册中心找到自己需要调用的服务的地址。</li>
<li>负载均衡:服务提供方一般以多实例的形式提供服务，负载均衡功能能够让服务调用方连接到合适的服务节点。并且，节点选择的工作对服务调用方来说是透明的。</li>
<li>服务网关:服务网关是服务调用的唯一入口，可以在这个组件是实现用户鉴权、动态路由、灰度发布、A/B测试、负载限流等功能。</li>
<li>配置中心:将本地化的配置信息（properties,<br>xml, yaml等）注册到配置中心，实现程序包在开发、测试、生产环境的无差别性，方便程序包的迁移。</li>
<li>API管理:以方便的形式编写及更新API文档，并以方便的形式供调用者查看和测试。</li>
<li>集成框架:微服务组件都以职责单一的程序包对外提供服务，集成框架以配置的形式将所有微服务组件（特别是管理端组件）集成到统一的界面框架下，让用户能够在统一的界面中使用系统。</li>
<li>分布式事务:对于重要的业务，需要通过分布式事务技术（TCC、高可用消息服务、最大努力通知）保证数据的一致性。具有代表性的有spring transaction</li>
<li>调用链:记录完成一个业务逻辑时调用到的微服务，并将这种串行或并行的调用关系展示出来。在系统出错时，可以方便地找到出错点。具有代表性的有pinpoint.</li>
<li>支撑平台:系统微服务化后，系统变得更加碎片化，系统的部署、运维、监控等都比单体架构更加复杂，那么，就需要将大部分的工作自动化。现在，可以通过Docker等工具来中和这些微服务架构带来的弊端。 例如:持续集成、蓝绿发布、健康检查、性能健康等等。严重点，以我们两年的实践经验，可以这么说，如果没有合适的支撑平台或工具，就不要使用微服务架构。</li>
</ul>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/07/04/harbor/">企业级 Docker Registry--harbor安装和简单使用</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/07/04/harbor/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-07-03T16:00:00.000Z" itemprop="datePublished">2017-07-04</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/docker/">docker</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <blockquote>
<p>简单的说，Harbor 是一个企业级的 Docker Registry，可以实现 images 的私有存储和日志统计权限控制等功能，并支持创建多项目(Harbor 提出的概念)，基于官方 Registry V2 实现。</p>
</blockquote>
<h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><p>参考官方文档</p>
<h2 id="安装docker-compose"><a href="#安装docker-compose" class="headerlink" title="安装docker-compose"></a>安装docker-compose</h2><p>参考官方文档</p>
<h2 id="搭建Harbor"><a href="#搭建Harbor" class="headerlink" title="搭建Harbor"></a>搭建Harbor</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><pre><code>wget https://github.com/vmware/harbor/releases/download/v1.1.2/harbor-online-installer-v1.1.2.tgz
</code></pre><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><pre><code>tar zvxf harbor-online-installer-v1.1.2.tgz
</code></pre><h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><pre><code>cd harbor
vim harbor.cfg
</code></pre><p>配置样例如下：</p>
<pre><code>## Configuration file of Harbor

#The IP address or hostname to access admin UI and registry service.
#DO NOT use localhost or 127.0.0.1, because Harbor needs to be accessed by external clients.
# 指定 hostname，一般为IP，或者域名，用于登录 Web UI 界面
hostname = 120.12.34.45

#The protocol for accessing the UI and token/notification service, by default it is http.
#It can be set to https if ssl is enabled on nginx.
# URL 访问方式，SSL 需要配置 nginx
ui_url_protocol = http

#Email account settings for sending out password resetting emails.
# 邮件相关信息配置，如忘记密码发送邮件
email_server = smtp.xxxxxx.com
email_server_port = 465
email_username = reg@mritd.me
email_password = xxxxxx
email_from = docker &lt;reg@mritd.me&gt;
email_ssl = true

##The password of Harbor admin, change this before any production use.
# 默认的 Harbor 的管理员密码，管理员用户名默认 admin
harbor_admin_password = Harbor12345

##By default the auth mode is db_auth, i.e. the credentials are stored in a local database.
#Set it to ldap_auth if you want to verify a user&apos;s credentials against an LDAP server.
# 指定 Harbor 的权限验证方式，Harbor 支持本地的 mysql 数据存储密码，同时也支持 LDAP
auth_mode = db_auth

#The url for an ldap endpoint.
# 如果采用了 LDAP，此处填写 LDAP 地址
ldap_url = ldaps://ldap.mydomain.com

#The basedn template to look up a user in LDAP and verify the user&apos;s password.
# LADP 验证密码的方式(我特么没用过这么高级的玩意)
ldap_basedn = uid=%s,ou=people,dc=mydomain,dc=com

#The password for the root user of mysql db, change this before any production use.
# mysql 数据库 root 账户密码
db_password = root123

#Turn on or off the self-registration feature
# 是否允许开放注册
self_registration = on

#Turn on or off the customize your certicate
# 允许自签名证书
customize_crt = on

#fill in your certicate message
# 自签名证书信息
crt_country = CN
crt_state = State
crt_location = CN
crt_organization = mritd
crt_organizationalunit = mritd
crt_commonname = mritd.me
crt_email = reg.mritd.me
#####
</code></pre><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><pre><code>sudo ./install
</code></pre><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><pre><code>Harbor 默认管理员用户为 admin ，密码在 harbor.cfg 中设置过，默认的是 Harbor12345 ，可直接登陆
</code></pre>
        
    </section>
</article>




<nav class="page-nav">
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
</nav>


</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
        });
    </script>

</body>
</html>
