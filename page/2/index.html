<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />

    

    

    <title>Donjote 博客</title>
    <meta name="author" content="Donjote" />
    <meta name="version" content="1.0.0" />
    <meta name="keywords" content="undefined" />
    <meta name="description" content="null" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
    <meta name="baidu-site-verification" content="F0CXvmUgA9" />

    
    
    <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <div class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <button id="open-panel" class="open-panel"><i class="icon-library"></i></button>

    <nav class="nav-inner">

        
        
        <li class="nav-item active">
            <a class="nav-link" href="/">首页</a>
        </li>
        
        
        
        <li class="nav-item nav-item-tag">
            <a id="nav-tag" class="nav-link" href="#">标签</a>
            <div id="nav-tags" class="nav-tag-wrap">
                <i class="nav-tag-arrow"></i>
                
  <div class="widget-wrap">
    <h3 class="widget-title">
        <i class="icon-tag vm"></i>
        <span class="vm">Tags</span>
    </h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Electron/">Electron</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang/">Golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NoSQL/">NoSQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nodejs/">Nodejs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RPC/">RPC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React-Native/">React Native</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Restful/">Restful</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TensorFlow/">TensorFlow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Weex/">Weex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Yarn/">Yarn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/etcd/">etcd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gRPC/">gRPC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm镜像/">npm镜像</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-boot/">spring boot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/事务/">事务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式架构/">分布式架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/区块链/">区块链</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微服务/">微服务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/敏捷开发/">敏捷开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务发现/">服务发现</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/深度学习/">深度学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/神经网络/">神经网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/跨平台/">跨平台</a></li></ul>
    </div>
  </div>


            </div>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/archives">归档</a>
        </li>
        
        
        
        <li class="nav-item">
            <a class="nav-link" href="/about">关于</a>
        </li>
        
        
        

    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://donjote.github.io"></form>

        
        

        
        <div class="author-meta">
            
            <div class="author-avatar">
                <a href="/">
                    <img src="/images/avatar.jpg" title="Sanonz">
                </a>
            </div>
            
            <div class="author-name">Donjote</div>
            <div class="author-work"></div>
            <div class="author-location">
                <i class="icon-location vm"></i>
                <span class="vm">Shenzhen, China</span>
            </div>
            
            <div class="author-thread-wrap">
                <div class="author-threads clearfix">
                    
                    <a class="thread-item" href="https://github.com/donjote" target="_blank" rel="noopener"><i class="icon-github"></i></a>
                    
                    
                    
                </div>
            </div>
            
        </div>
        
    </div>
</aside>

</header>

        <div id="content" class="content">
    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/08/23/grpc_introdution/">gRPC入门简介</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/08/23/grpc_introdution/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-08-22T16:00:00.000Z" itemprop="datePublished">2017-08-23</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/RPC/">RPC</a>, <a class="article-tag-link" href="/tags/gRPC/">gRPC</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p><a href="https://grpc.io/" target="_blank" rel="external">gRPC</a>是Go实现的：一个高性能，开源，将移动和HTTP/2放在首位通用的RPC框架， 有关详细信息，请参阅<a href="https://grpc.io/docs/" target="_blank" rel="external">gRPC快速入门指南</a>。</p>
<h3 id="gRPC概念图"><a href="#gRPC概念图" class="headerlink" title="gRPC概念图"></a>gRPC概念图</h3><p><img src="/donjote-blog/2017/08/23/grpc_introdution/1.png" alt="gRPC概念图"></p>
</blockquote>
<h2 id="gRPC特性"><a href="#gRPC特性" class="headerlink" title="gRPC特性"></a>gRPC特性</h2><h3 id="基于HTTP-2协议标准"><a href="#基于HTTP-2协议标准" class="headerlink" title="基于HTTP/2协议标准"></a>基于HTTP/2协议标准</h3><blockquote>
<h4 id="什么是HTTP-2协议"><a href="#什么是HTTP-2协议" class="headerlink" title="什么是HTTP/2协议"></a>什么是HTTP/2协议</h4><p>HTTP 2.0即超文本传输协议 2.0，是下一代HTTP协议（基于二进制的传输协议）。是由互联网工程任务组（IETF）的Bis (httpbis)工作小组进行开发。</p>
<h4 id="HTTP-2的优点"><a href="#HTTP-2的优点" class="headerlink" title="HTTP/2的优点"></a>HTTP/2的优点</h4><ul>
<li>http2减少了网络往返传输的数量，并且用多路复用和快速丢弃不需要的流的办法来完全避免head of line blocking(线头阻塞)的困扰，降低延迟并提高安全性。</li>
<li>支持大量并行流，所以即使网站的数据分发在各处也不是问题。</li>
<li>合理利用流的优先级，可以让客户端尽可能优先收到更重要的数据。</li>
</ul>
</blockquote>
<h3 id="gRPC基于强大的IDL-Interface-description-language"><a href="#gRPC基于强大的IDL-Interface-description-language" class="headerlink" title="gRPC基于强大的IDL(Interface description language)"></a>gRPC基于强大的IDL(Interface description language)</h3><blockquote>
<p>gRPC基于ProtoBuf(Protocol Buffers)定义接口规范。</p>
<h4 id="ProtoBuf是什么？"><a href="#ProtoBuf是什么？" class="headerlink" title="ProtoBuf是什么？"></a>ProtoBuf是什么？</h4><p>Protocol Buffers 是google提供的一种轻便、高效、简单的数据存储语言，可以用于结构化、序列化数据。</p>
<h4 id="为什么要使用ProtoBuf？"><a href="#为什么要使用ProtoBuf？" class="headerlink" title="为什么要使用ProtoBuf？"></a>为什么要使用ProtoBuf？</h4><ul>
<li>适合应用场景：它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化数据结构。</li>
<li>支持语言众多（提供了完善的API）:Proto2提供了 C++、Java、Python 三种语言的 API。目前语言版本Proto3提供了更多的语言支持,包括 C++ 、C# 、GO 、JAVA、PYTHON。</li>
<li>易学易懂：protoBuf语法非常简单，掌握非常容易，便于读写。</li>
</ul>
</blockquote>
<h3 id="gRPC支持众多开发语言"><a href="#gRPC支持众多开发语言" class="headerlink" title="gRPC支持众多开发语言"></a>gRPC支持众多开发语言</h3><blockquote>
<p>GRPC目前支持的开发语言已达到了10种：C, C++, Java, Go, Node.js, Python, Ruby, Objective-C, PHP and C#。并且GRPC框架已在GitHub上开源。<br> GitHub地址：<a href="https://github.com/grpc" target="_blank" rel="external">https://github.com/grpc</a><br> JAVA GitHub地址：<a href="https://github.com/grpc/grpc-java" target="_blank" rel="external">https://github.com/grpc/grpc-java</a></p>
</blockquote>
<h2 id="为什么使用gRPC"><a href="#为什么使用gRPC" class="headerlink" title="为什么使用gRPC"></a>为什么使用gRPC</h2><blockquote>
<ul>
<li>它使用HTTP2协议，可复用链接，更充分的利用底层TCP传输协议，并以数据流的方式传输，比其他基于HTTP1的传输速率更高。</li>
<li>它基于Proto Buffer语言,对传输数据进行压缩、系列化和结构化，易于客户端与服务端数据的读写操作，并使数据量传输变得更小、传输效率更高。</li>
<li>基于以上及其他特性，使得基于GRPC的客户端和服务端更高效的利用流和链接，从而有助于节省宽带流量、降低链接次数、提高CUP使用效率和电池的使用寿命。</li>
</ul>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/07/14/tensorflow_1/">TensorFlow入门：简介</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/07/14/tensorflow_1/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-07-13T16:00:00.000Z" itemprop="datePublished">2017-07-14</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/TensorFlow/">TensorFlow</a>, <a class="article-tag-link" href="/tags/深度学习/">深度学习</a>, <a class="article-tag-link" href="/tags/神经网络/">神经网络</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <blockquote>
<p>TensorFlow 是一个用于人工智能的开源神器</p>
</blockquote>
<h2 id="TensorFlow是什么？"><a href="#TensorFlow是什么？" class="headerlink" title="TensorFlow是什么？"></a>TensorFlow是什么？</h2><blockquote>
<p>TensorFlow™ 是一个采用数据流图（data flow graphs），用于数值计算的开源软件库。节点（Nodes）在图中表示数学操作，图中的线（edges）则表示在节点间相互联系的多维数据数组，即张量（tensor）。它灵活的架构让你可以在多种平台上展开计算，例如台式计算机中的一个或多个CPU（或GPU），服务器，移动设备等等。TensorFlow 最初由Google大脑小组（隶属于Google机器智能研究机构）的研究员和工程师们开发出来，用于机器学习和深度神经网络方面的研究，但这个系统的通用性使其也可广泛用于其他计算领域。<br><img src="/donjote-blog/2017/07/14/tensorflow_1/1.gif" alt="TensorFlow"></p>
</blockquote>
<h2 id="什么是数据流图（Data-Flow-Graph）"><a href="#什么是数据流图（Data-Flow-Graph）" class="headerlink" title="什么是数据流图（Data Flow Graph）?"></a>什么是数据流图（Data Flow Graph）?</h2><blockquote>
<p>数据流图用“结点”（nodes）和“线”(edges)的有向图来描述数学计算。“节点” 一般用来表示施加的数学操作，但也可以表示数据输入（feed in）的起点/输出（push out）的终点，或者是读取/写入持久变量（persistent variable）的终点。“线”表示“节点”之间的输入/输出关系。这些数据“线”可以输运“size可动态调整”的多维数据数组，即“张量”（tensor）。张量从图中流过的直观图像是这个工具取名为“Tensorflow”的原因。一旦输入端的所有张量准备好，节点将被分配到各种计算设备完成异步并行地执行运算。</p>
</blockquote>
<h2 id="TensorFlow的特征"><a href="#TensorFlow的特征" class="headerlink" title="TensorFlow的特征"></a>TensorFlow的特征</h2><blockquote>
<ul>
<li>高度的灵活性</li>
<li>真正的可移植性（Portability）</li>
<li>将科研和产品联系在一起</li>
<li>自动求微分</li>
<li>多语言支持</li>
<li>性能最优化</li>
</ul>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/07/14/tensorflow_2/">TensorFlow入门：安装</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/07/14/tensorflow_2/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-07-13T16:00:00.000Z" itemprop="datePublished">2017-07-14</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/TensorFlow/">TensorFlow</a>, <a class="article-tag-link" href="/tags/深度学习/">深度学习</a>, <a class="article-tag-link" href="/tags/神经网络/">神经网络</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="基于-Docker-的安装"><a href="#基于-Docker-的安装" class="headerlink" title="基于 Docker 的安装"></a>基于 Docker 的安装</h2><blockquote>
<p>首先, <a href="https://docs.docker.com/engine/installation/" target="_blank" rel="external">安装 Docker</a>. 一旦 Docker 已经启动运行, 可以通过命令启动一个容器:</p>
<pre><code>$ docker run -it --name tensorflow -p 8888:8888 tensorflow/tensorflow
</code></pre></blockquote>
<p>##才云TensorFlow镜像</p>
<blockquote>
<p>在官方镜像的基础上，才云科技提供的镜像进一步整合了其他机器学习工具包以及TensorFlow可视化工具TensorBoard，使用起来可以更加方便。</p>
<pre><code>$ docker run -it  --name tensorflow -p 8888:8888 -p 6006:6006 \
cargo.caicloud.io/caicloud/tensorflow
</code></pre><p>在这个命令中，-p 8888:8888 将容器内运行的Jupyter服务映射到本地机器，这样在浏览器中打开localhost:8888就能看到Jupyter界面。在此镜像中运行的Jupyter是一个网页版的代码编辑器，它支持创建、上传、修改和运行Python程序。</p>
<hr>
<p>-p 6006:6006将容器内运行的TensorFlow可视化工具TensorBoard映射到本地机器，通过在浏览器中打开localhost:6006就可以将TensorFlow在训练时的状态、图片数据以及神经网络结构等信息全部展示出来。此镜像会将所有输出到/log目录底下的日志全部可视化。</p>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/07/13/golang_vendor/">Golang包管理</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/07/13/golang_vendor/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-07-12T16:00:00.000Z" itemprop="datePublished">2017-07-13</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Golang/">Golang</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote>
<p>Golang并没有官方最佳管理方案，在Go的世界里存在大量的自制解决方案。go语言的包是没有中央库统一管理的，通过使用go get命令从远程代码库(github.com,goolge code 等)拉取，直接跳过中央版本库的约束，让代码的拉取直接基于源代码版本控制库，开发者间的协同直接依赖于源代码的版本控制。直接去除了库版本的概念。没有明显的包版本标识，感觉还是有点不适应，官方的建议是把外部依赖的代码全部复制到自己可控的源代码库中，进行同意管理。从而做到对依赖包的可控管理。</p>
<hr>
<p>对于国内开发者来说，最好是能一个一个包来管理。遇到网络问题，可以通过国内镜像下载。在这样的情况之下gvt 就是一个不错的选择。它可以帮助我们把一个包以及依赖都彻底的拉到本地的代码库中，统一了团队协作过程中编译环境不一致的问题。</p>
</blockquote>
<h2 id="gvt安装方法"><a href="#gvt安装方法" class="headerlink" title="gvt安装方法"></a>gvt安装方法</h2><blockquote>
<pre><code>$ go get -u github.com/FiloSottile/gvt
</code></pre></blockquote>
<h2 id="gvt使用"><a href="#gvt使用" class="headerlink" title="gvt使用"></a>gvt使用</h2><blockquote>
<h3 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h3><pre><code>$ gvt fetch [package]
</code></pre><h3 id="下载包"><a href="#下载包" class="headerlink" title="下载包"></a>下载包</h3><pre><code>$ gvt restore
</code></pre><h3 id="包列表"><a href="#包列表" class="headerlink" title="包列表"></a>包列表</h3><pre><code>$ gvt list
</code></pre><h3 id="更新指定包"><a href="#更新指定包" class="headerlink" title="更新指定包"></a>更新指定包</h3><pre><code>$ gvt update [package]
</code></pre><h3 id="删除指定包"><a href="#删除指定包" class="headerlink" title="删除指定包"></a>删除指定包</h3><pre><code>$ gvt delete [package]
</code></pre></blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/07/13/golang_install/">Golang简介与环境搭建</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/07/13/golang_install/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-07-12T16:00:00.000Z" itemprop="datePublished">2017-07-13</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Golang/">Golang</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="Golang简介"><a href="#Golang简介" class="headerlink" title="Golang简介"></a>Golang简介</h2><blockquote>
<p>Go 是 2009 年发布的一种简单的并行开发，且跨平台的类 C 语言。由于其强大的并行性，很适合用于网络开发中</p>
<h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><ul>
<li>Less can be more</li>
<li>大道至简,小而蕴真</li>
<li>让事情变得复杂很容易，让事情变得简单才难</li>
<li>深刻的工程文化<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3></li>
</ul>
<ol>
<li>自带gc。</li>
<li>静态编译，编译好后，扔服务器直接运行。</li>
<li>简单的思想，没有继承，多态，类等。</li>
<li>丰富的库和详细的开发文档。</li>
<li>语法层支持并发，和拥有同步并发的channel类型，使并发开发变得非常方便。</li>
<li>简洁的语法，提高开发效率，同时提高代码的阅读性和可维护性。</li>
<li>超级简单的交叉编译，仅需更改环境变量。（花了我两天时间编译一个imagemagick到arm平台）</li>
<li>内含完善、全面的软件工程工具。Go语言自带的命令和工具相当地强大。通过它们，我们可以很轻松地完成Go语言程序的获取、编译、测试、安装、运行、运行分析等一系列工作，这几乎涉及了开发和维护一个软件的所有环节。<h3 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h3></li>
</ol>
<ul>
<li>自动垃圾回收</li>
<li>更丰富的内置类型</li>
<li>函数多返回值</li>
<li>错误处理</li>
<li>匿名函数和闭包</li>
<li>类型和接口</li>
<li>并发编程</li>
<li>反射</li>
<li>语言交互性</li>
<li>高性能/高效开发</li>
</ul>
</blockquote>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><blockquote>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>$ wget https://storage.googleapis.com/golang/go1.8.3.linux-amd64.tar.gz
$ tar -C /usr/local -xzf go1.8.3.linux-amd64.tar.gz  
</code></pre><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><pre><code>$ vim /etc/profile
</code></pre><p>添加对应的GOROOT和GOROOT的配置环境</p>
<pre><code>export GOROOT=/usr/local/go
export GOPATH=$HOME/Projects/golang
export PATH=$PATH:$GOROOT/bin:$GOPATH/bin
</code></pre><p>之后，source /etc/profile 使得其配置文件有效.</p>
</blockquote>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><blockquote>
<pre><code>$ go env
GOARCH=&quot;amd64&quot;
GOBIN=&quot;&quot;
GOEXE=&quot;&quot;
GOHOSTARCH=&quot;amd64&quot;
GOHOSTOS=&quot;linux&quot;
GOOS=&quot;linux&quot;
GOPATH=&quot;/home/donjote/Projects/golang&quot;
GORACE=&quot;&quot;
GOROOT=&quot;/usr/local/go&quot;
GOTOOLDIR=&quot;/usr/local/go/pkg/tool/linux_amd64&quot;
GCCGO=&quot;gccgo&quot;
CC=&quot;gcc&quot;
GOGCCFLAGS=&quot;-fPIC -m64 -pthread -fmessage-length=0 -fdebug-prefix-map=/tmp/go-build061263866=/tmp/go-build -gno-record-gcc-switches&quot;
CXX=&quot;g++&quot;
CGO_ENABLED=&quot;1&quot;
PKG_CONFIG=&quot;pkg-config&quot;
CGO_CFLAGS=&quot;-g -O2&quot;
CGO_CPPFLAGS=&quot;&quot;
CGO_CXXFLAGS=&quot;-g -O2&quot;
CGO_FFLAGS=&quot;-g -O2&quot;
CGO_LDFLAGS=&quot;-g -O2&quot;
</code></pre></blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/07/12/deep_learning_phylogeny/">深度学习：神经网络发展史</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/07/12/deep_learning_phylogeny/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-07-11T16:00:00.000Z" itemprop="datePublished">2017-07-12</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/深度学习/">深度学习</a>, <a class="article-tag-link" href="/tags/神经网络/">神经网络</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><blockquote>
<p>机器学习(Machine Learning,ML)一门多领域交叉学科，涉及概率论、统计学、逼近学、凸分析、算法复杂度理论等多门学科。专门研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构使之不断改善自身的性能。</p>
<hr>
<p>它是人工智能的核心，是使计算机具有智能的根本途径，其应用遍及人工智能的各个领域，它主要使用归纳、综合不是演绎。</p>
</blockquote>
<h2 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h2><blockquote>
<p>深度学习是机器学习中一种基于对数据进行表征学习的方法。观测值（例如一幅图像）可以使用多种方式来表示，如每个像素强度值的向量，或者更抽象地表示成一系列边、特定形状的区域等。而使用某些特定的表示方法更容易从实例中学习任务（例如，人脸识别或面部表情识别）。深度学习的好处是用非监督式或半监督式的特征学习和分层特征提取高效算法来替代手工获取特征。</p>
<hr>
<p>深度学习是机器学习研究中的一个新的领域，其动机在于建立、模拟人脑进行分析学习的神经网络，它模仿人脑的机制来解释数据，例如图像，声音和文本。</p>
<hr>
<p>同机器学习方法一样，深度机器学习方法也有监督学习与无监督学习之分．不同的学习框架下建立的学习模型很是不同．例如，卷积神经网络（Convolutional neural networks，简称CNNs）就是一种深度的监督学习下的机器学习模型，而深度置信网（Deep Belief Nets，简称DBNs）就是一种无监督学习下的机器学习模型。</p>
</blockquote>
<h2 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h2><blockquote>
<p><img src="/donjote-blog/2017/07/12/deep_learning_phylogeny/1.jpg" alt="发展历史"><br>由图可以明显看出DL在从06年崛起之前经历了两个低谷，这两个低谷也将神经网络的发展分为了三个不同的阶段。</p>
<h3 id="第一代神经网络"><a href="#第一代神经网络" class="headerlink" title="第一代神经网络"></a>第一代神经网络</h3><p><strong>感知器(~1960）</strong><br><img src="/donjote-blog/2017/07/12/deep_learning_phylogeny/2.png" alt="感知器"><br>感知器（Perceptrons）使用一层手编（Hand-coded）特征，通过学习如何给这些特征加权来识别对象。<br>感知器的优点：调整权值的学习算法很简洁。<br>感知器的缺点：感知器一些先天的缺陷，导致它们可以学习的东西大大地受限。<br>Vapnik和他的同事们发明了大名鼎鼎的支持向量机（SVM），改进了感知器的一些缺陷（例如创建灵活的特征而不是手编的非适应的特征），并得到了广泛的应用。但是归根到底，它还是一种感知器，所以无法避免感知器的先天限制。</p>
<h3 id="第二代神经网络"><a href="#第二代神经网络" class="headerlink" title="第二代神经网络"></a>第二代神经网络</h3><p><strong>BP（反向传播，Back-propagate）神经网络（~1985） </strong><br><img src="/donjote-blog/2017/07/12/deep_learning_phylogeny/3.png" alt="BP"><br>BP神经网络通常使用梯度法来修正权值。BP并不是一种很实用的方法。原因有三：</p>
<ul>
<li>它需要被标记的训练数据，但是几乎所有的数据都是未标记的。</li>
<li>学习时间不易衡量，在多层网络中，速度非常慢。</li>
<li>它陷入局部极小点而不收敛的情况极大。<h3 id="第三代神经网络"><a href="#第三代神经网络" class="headerlink" title="第三代神经网络"></a>第三代神经网络</h3>最近的神经科学研究表明，和人类的许多认知能力相关的大脑皮层，并不显式地预处理感知信号，而是让它们通过一个复杂的模块层次结构，久而久之，就可以根据观察结果呈现的规律来表达它们。<br>这一发现促进了深机器学习（DML, Deep Machine Learning）的发展。DML关注的恰恰正是是信息表达的计算模型，和大脑皮层类似。</li>
</ul>
<hr>
<p>目前DML领域有两种主流的方法：</p>
<ul>
<li>卷积神经网络<br><img src="/donjote-blog/2017/07/12/deep_learning_phylogeny/4.png" alt="卷积神经网络"></li>
<li>深度信念网络<br><img src="/donjote-blog/2017/07/12/deep_learning_phylogeny/5.png" alt="深度信念网络"></li>
</ul>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/07/11/etcd_1/">etcd概述和使用场景</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/07/11/etcd_1/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-07-10T16:00:00.000Z" itemprop="datePublished">2017-07-11</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/etcd/">etcd</a>, <a class="article-tag-link" href="/tags/微服务/">微服务</a>, <a class="article-tag-link" href="/tags/服务发现/">服务发现</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>etcd是一个高可用的键值存储系统，主要用于共享配置和服务发现。etcd是由CoreOS开发并维护的，灵感来自于 ZooKeeper 和 Doozer，它使用Go语言编写，并通过Raft一致性算法处理日志复制以保证强一致性。Raft是一个新的一致性算法，适用于分布式系统的日志复制，Raft通过选举的方式来实现一致性。Google的容器集群管理系统Kubernetes、开源PaaS平台Cloud Foundry和CoreOS的Fleet都广泛使用了etcd。在分布式系统中，如何管理节点间的状态一直是一个难题，etcd像是专门为集群环境的服务发现和注册而设计，它提供了数据TTL失效、数据改变监视、多值、目录监听、分布式锁原子操作等功能，可以方便的跟踪并管理集群节点的状态。</p>
<hr>
<p>etcd的特性如下：</p>
<ul>
<li>简单: 支持curl方式的用户API（HTTP+JSON）</li>
<li>安全: 可选的SSL客户端证书认证</li>
<li>快速: 单实例每秒 1000 次写操作</li>
<li>可靠: 使用Raft保证一致性</li>
</ul>
</blockquote>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h3 id="场景一：服务发现（Service-Discovery）"><a href="#场景一：服务发现（Service-Discovery）" class="headerlink" title="场景一：服务发现（Service Discovery）"></a>场景一：服务发现（Service Discovery）</h3><blockquote>
<p>服务发现要解决的也是分布式系统中最常见的问题之一，即在同一个分布式集群中的进程或服务，要如何才能找到对方并建立连接。本质上来说，服务发现就是想要了解集群中是否有进程在监听udp或tcp端口，并且通过名字就可以查找和连接。要解决服务发现的问题，需要有下面三大支柱，缺一不可。</p>
<hr>
<p>一个强一致性、高可用的服务存储目录。基于Raft算法的etcd天生就是这样一个强一致性高可用的服务存储目录。</p>
<hr>
<p>一种注册服务和监控服务健康状态的机制。用户可以在etcd中注册服务，并且对注册的服务设置key TTL，定时保持服务的心跳以达到监控健康状态的效果。</p>
<hr>
<p>一种查找和连接服务的机制。通过在etcd指定的主题下注册的服务也能在对应的主题下查找到。为了确保连接，我们可以在每个服务机器上都部署一个Proxy模式的etcd，这样就可以确保能访问etcd集群的服务都能互相连接。<br><img src="/donjote-blog/2017/07/11/etcd_1/1.jpg" alt="服务发现示意图"><br>图一 服务发现示意图</p>
<hr>
<p>下面我们来看服务发现对应的具体场景。</p>
<hr>
<p>微服务协同工作架构中，服务动态添加。随着Docker容器的流行，多种微服务共同协作，构成一个相对功能强大的架构的案例越来越多。透明化的动态添加这些服务的需求也日益强烈。通过服务发现机制，在etcd中注册某个服务名字的目录，在该目录下存储可用的服务节点的IP。在使用服务的过程中，只要从服务目录下查找可用的服务节点去使用即可。<br><img src="/donjote-blog/2017/07/11/etcd_1/2.jpg" alt="服务协同工作"><br>图二 微服务协同工作</p>
<hr>
<p>PaaS平台中应用多实例与实例故障重启透明化。PaaS平台中的应用一般都有多个实例，通过域名，不仅可以透明的对这多个实例进行访问，而且还可以做到负载均衡。但是应用的某个实例随时都有可能故障重启，这时就需要动态的配置域名解析（路由）中的信息。通过etcd的服务发现功能就可以轻松解决这个动态配置的问题。<br><img src="/donjote-blog/2017/07/11/etcd_1/3.jpg" alt="多平台多实例透明化"><br>图三 多平台多实例透明化</p>
</blockquote>
<h3 id="场景二：消息发布与订阅"><a href="#场景二：消息发布与订阅" class="headerlink" title="场景二：消息发布与订阅"></a>场景二：消息发布与订阅</h3><blockquote>
<p>在分布式系统中，最适用的一种组件间通信方式就是消息发布与订阅。即构建一个配置共享中心，数据提供者在这个配置中心发布消息，而消息使用者则订阅他们关心的主题，一旦主题有消息发布，就会实时通知订阅者。通过这种方式可以做到分布式系统配置的集中式管理与动态更新。</p>
<hr>
<p>应用中用到的一些配置信息放到etcd上进行集中管理。这类场景的使用方式通常是这样：应用在启动的时候主动从etcd获取一次配置信息，同时，在etcd节点上注册一个Watcher并等待，以后每次配置有更新的时候，etcd都会实时通知订阅者，以此达到获取最新配置信息的目的。</p>
<hr>
<p>分布式搜索服务中，索引的元信息和服务器集群机器的节点状态存放在etcd中，供各个客户端订阅使用。使用etcd的key TTL功能可以确保机器状态是实时更新的。</p>
<hr>
<p>分布式日志收集系统。这个系统的核心工作是收集分布在不同机器的日志。收集器通常是按照应用（或主题）来分配收集任务单元，因此可以在etcd上创建一个以应用（主题）命名的目录P，并将这个应用（主题相关）的所有机器ip，以子目录的形式存储到目录P上，然后设置一个etcd递归的Watcher，递归式的监控应用（主题）目录下所有信息的变动。这样就实现了机器IP（消息）变动的时候，能够实时通知到收集器调整任务分配。</p>
<hr>
<p>系统中信息需要动态自动获取与人工干预修改信息请求内容的情况。通常是暴露出接口，例如JMX接口，来获取一些运行时的信息。引入etcd之后，就不用自己实现一套方案了，只要将这些信息存放到指定的etcd目录中即可，etcd的这些目录就可以通过HTTP的接口在外部访问。<br><img src="/donjote-blog/2017/07/11/etcd_1/4.jpg" alt="消息发布和订阅"><br>图四 消息发布和订阅</p>
</blockquote>
<h3 id="场景三：负载均衡"><a href="#场景三：负载均衡" class="headerlink" title="场景三：负载均衡"></a>场景三：负载均衡</h3><blockquote>
<p>在场景一中也提到了负载均衡，本文所指的负载均衡均为软负载均衡。分布式系统中，为了保证服务的高可用以及数据的一致性，通常都会把数据和服务部署多份，以此达到对等服务，即使其中的某一个服务失效了，也不影响使用。由此带来的坏处是数据写入性能下降，而好处则是数据访问时的负载均衡。因为每个对等服务节点上都存有完整的数据，所以用户的访问流量就可以分流到不同的机器上。</p>
<hr>
<p>etcd本身分布式架构存储的信息访问支持负载均衡。etcd集群化以后，每个etcd的核心节点都可以处理用户的请求。所以，把数据量小但是访问频繁的消息数据直接存储到etcd中也是个不错的选择，如业务系统中常用的二级代码表（在表中存储代码，在etcd中存储代码所代表的具体含义，业务系统调用查表的过程，就需要查找表中代码的含义）。</p>
<hr>
<p>利用etcd维护一个负载均衡节点表。etcd可以监控一个集群中多个节点的状态，当有一个请求发过来后，可以轮询式的把请求转发给存活着的多个状态。类似KafkaMQ，通过ZooKeeper来维护生产者和消费者的负载均衡。同样也可以用etcd来做ZooKeeper的工作。<br><img src="/donjote-blog/2017/07/11/etcd_1/5.jpg" alt="负载均衡"><br>图五 负载均衡</p>
</blockquote>
<h3 id="场景四：分布式通知与协调"><a href="#场景四：分布式通知与协调" class="headerlink" title="场景四：分布式通知与协调"></a>场景四：分布式通知与协调</h3><blockquote>
<p>这里说到的分布式通知与协调，与消息发布和订阅有些相似。都用到了etcd中的Watcher机制，通过注册与异步通知机制，实现分布式环境下不同系统之间的通知与协调，从而对数据变更做到实时处理。实现方式通常是这样：不同系统都在etcd上对同一个目录进行注册，同时设置Watcher观测该目录的变化（如果对子目录的变化也有需要，可以设置递归模式），当某个系统更新了etcd的目录，那么设置了Watcher的系统就会收到通知，并作出相应处理。</p>
<hr>
<p>通过etcd进行低耦合的心跳检测。检测系统和被检测系统通过etcd上某个目录关联而非直接关联起来，这样可以大大减少系统的耦合性。</p>
<hr>
<p>通过etcd完成系统调度。某系统有控制台和推送系统两部分组成，控制台的职责是控制推送系统进行相应的推送工作。管理人员在控制台作的一些操作，实际上是修改了etcd上某些目录节点的状态，而etcd就把这些变化通知给注册了Watcher的推送系统客户端，推送系统再作出相应的推送任务。</p>
<hr>
<p>通过etcd完成工作汇报。大部分类似的任务分发系统，子任务启动后，到etcd来注册一个临时工作目录，并且定时将自己的进度进行汇报（将进度写入到这个临时目录），这样任务管理者就能够实时知道任务进度。<br><img src="/donjote-blog/2017/07/11/etcd_1/6.jpg" alt="分布式协同工作"><br>图六 分布式协同工作</p>
</blockquote>
<h3 id="场景五：分布式锁"><a href="#场景五：分布式锁" class="headerlink" title="场景五：分布式锁"></a>场景五：分布式锁</h3><blockquote>
<p>因为etcd使用Raft算法保持了数据的强一致性，某次操作存储到集群中的值必然是全局一致的，所以很容易实现分布式锁。锁服务有两种使用方式，一是保持独占，二是控制时序。</p>
<hr>
<p>保持独占即所有获取锁的用户最终只有一个可以得到。etcd为此提供了一套实现分布式锁原子操作CAS（CompareAndSwap）的API。通过设置prevExist值，可以保证在多个节点同时去创建某个目录时，只有一个成功。而创建成功的用户就可以认为是获得了锁。</p>
<hr>
<p>控制时序，即所有想要获得锁的用户都会被安排执行，但是获得锁的顺序也是全局唯一的，同时决定了执行顺序。etcd为此也提供了一套API（自动创建有序键），对一个目录建值时指定为POST动作，这样etcd会自动在目录下生成一个当前最大的值为键，存储这个新的值（客户端编号）。同时还可以使用API按顺序列出所有当前目录下的键值。此时这些键的值就是客户端的时序，而这些键中存储的值可以是代表客户端的编号。<br><img src="/donjote-blog/2017/07/11/etcd_1/7.jpg" alt="分布式锁"><br>图七 分布式锁</p>
</blockquote>
<h3 id="场景六：分布式队列"><a href="#场景六：分布式队列" class="headerlink" title="场景六：分布式队列"></a>场景六：分布式队列</h3><blockquote>
<p>分布式队列的常规用法与场景五中所描述的分布式锁的控制时序用法类似，即创建一个先进先出的队列，保证顺序。</p>
<hr>
<p>另一种比较有意思的实现是在保证队列达到某个条件时再统一按顺序执行。这种方法的实现可以在/queue这个目录中另外建立一个/queue/condition节点。</p>
<hr>
<p>condition可以表示队列大小。比如一个大的任务需要很多小任务就绪的情况下才能执行，每次有一个小任务就绪，就给这个condition数字加1，直到达到大任务规定的数字，再开始执行队列里的一系列小任务，最终执行大任务。<br>condition可以表示某个任务在不在队列。这个任务可以是所有排序任务的首个执行程序，也可以是拓扑结构中没有依赖的点。通常，必须执行这些任务后才能执行队列中的其他任务。<br><img src="/donjote-blog/2017/07/11/etcd_1/8.jpg" alt="分布式队列"><br>图八 分布式队列</p>
</blockquote>
<h3 id="场景七：集群监控与Leader竞选"><a href="#场景七：集群监控与Leader竞选" class="headerlink" title="场景七：集群监控与Leader竞选"></a>场景七：集群监控与Leader竞选</h3><blockquote>
<p>通过etcd来进行监控实现起来非常简单并且实时性强。</p>
<hr>
<p>前面几个场景已经提到Watcher机制，当某个节点消失或有变动时，Watcher会第一时间发现并告知用户。<br>节点可以设置TTL key，比如每隔30s发送一次心跳使代表该机器存活的节点继续存在，否则节点消失。<br>这样就可以第一时间检测到各节点的健康状态，以完成集群的监控要求。</p>
<hr>
<p>另外，使用分布式锁，可以完成Leader竞选。这种场景通常是一些长时间CPU计算或者使用IO操作的机器，只需要竞选出的Leader计算或处理一次，就可以把结果复制给其他的Follower。从而避免重复劳动，节省计算资源。</p>
<hr>
<p>这个的经典场景是搜索系统中建立全量索引。如果每个机器都进行一遍索引的建立，不但耗时而且建立索引的一致性不能保证。通过在etcd的CAS机制同时创建一个节点，创建成功的机器作为Leader，进行索引计算，然后把计算结果分发到其它节点。<br><img src="/donjote-blog/2017/07/11/etcd_1/9.jpg" alt="Leader竞选"><br>图九 Leader竞选</p>
</blockquote>
<h2 id="为什么用etcd而不用ZooKeeper？"><a href="#为什么用etcd而不用ZooKeeper？" class="headerlink" title="为什么用etcd而不用ZooKeeper？"></a>为什么用etcd而不用ZooKeeper？</h2><blockquote>
<p>etcd实现的这些功能，ZooKeeper都能实现。那么为什么要用etcd而非直接使用ZooKeeper呢？</p>
<hr>
<p>相较之下，ZooKeeper有如下缺点：</p>
<ol>
<li>复杂。ZooKeeper的部署维护复杂，管理员需要掌握一系列的知识和技能；而Paxos强一致性算法也是素来以复杂难懂而闻名于世；另外，ZooKeeper的使用也比较复杂，需要安装客户端，官方只提供了Java和C两种语言的接口。</li>
<li>Java编写。这里不是对Java有偏见，而是Java本身就偏向于重型应用，它会引入大量的依赖。而运维人员则普遍希望保持强一致、高可用的机器集群尽可能简单，维护起来也不易出错。]</li>
<li>发展缓慢。Apache基金会项目特有的“Apache Way”在开源界饱受争议，其中一大原因就是由于基金会庞大的结构以及松散的管理导致项目发展缓慢。</li>
</ol>
<hr>
<p>而etcd作为一个后起之秀，其优点也很明显。</p>
<ol>
<li>简单。使用Go语言编写部署简单；使用HTTP作为接口使用简单；使用Raft算法保证强一致性让用户易于理解。</li>
<li>数据持久化。etcd默认数据一更新就进行持久化。</li>
<li>安全。etcd支持SSL客户端安全认证。</li>
</ol>
<hr>
<p>最后，etcd作为一个年轻的项目，真正告诉迭代和开发中，这既是一个优点，也是一个缺点。优点是它的未来具有无限的可能性，缺点是无法得到大项目长时间使用的检验。然而，目前CoreOS、Kubernetes和CloudFoundry等知名项目均在生产环境中使用了etcd，所以总的来说，etcd值得你去尝试。</p>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/07/11/etcd_2/">使用docker-machine搭建etcd集群</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/07/11/etcd_2/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-07-10T16:00:00.000Z" itemprop="datePublished">2017-07-11</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/etcd/">etcd</a>, <a class="article-tag-link" href="/tags/微服务/">微服务</a>, <a class="article-tag-link" href="/tags/服务发现/">服务发现</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="创建Etcd集群"><a href="#创建Etcd集群" class="headerlink" title="创建Etcd集群"></a>创建Etcd集群</h2><blockquote>
<p>  $ curl -sSL <a href="https://raw.githubusercontent.com/donjote/shell-etcd/master/etcd.sh" target="_blank" rel="external">https://raw.githubusercontent.com/donjote/shell-etcd/master/etcd.sh</a> | sh -</p>
</blockquote>
<h3 id="集群验证"><a href="#集群验证" class="headerlink" title="集群验证"></a>集群验证</h3><blockquote>
<ol>
<li>验证集群members。在集群中的每台机器上查看members，得出的结果应该是相同的   </li>
</ol>
<pre><code>$ curl -L http://$(docker-machine ip etcd-node-0):2379/v2/members
$ curl -L http://$(docker-machine ip etcd-node-1):2379/v2/members
$ curl -L http://$(docker-machine ip etcd-node-2):2379/v2/members
{&quot;members&quot;:[{&quot;id&quot;:&quot;305750b374006637&quot;,&quot;name&quot;:&quot;etcd-node-2&quot;,&quot;peerURLs&quot;:[&quot;http://192.168.99.102:2380&quot;],&quot;clientURLs&quot;:[&quot;http://192.168.99.102:2379&quot;]},{&quot;id&quot;:&quot;c7177c3c5ff3b1b4&quot;,&quot;name&quot;:&quot;etcd-node-0&quot;,&quot;peerURLs&quot;:[&quot;http://192.168.99.100:2380&quot;],&quot;clientURLs&quot;:[&quot;http://192.168.99.100:2379&quot;]},{&quot;id&quot;:&quot;d5673e1f00b32e05&quot;,&quot;name&quot;:&quot;etcd-node-1&quot;,&quot;peerURLs&quot;:[&quot;http://192.168.99.101:2380&quot;],&quot;clientURLs&quot;:[&quot;http://192.168.99.101:2379&quot;]}]}
</code></pre><p>2.某台机器上添加数据，其他机器上查看数据，得出的结果应该是相同的</p>
<pre><code>$ curl -L http://$(docker-machine ip etcd-node-0):2379/v2/keys/message -XPUT -d value=&quot;Hello World&quot;
{&quot;action&quot;:&quot;set&quot;,&quot;node&quot;:{&quot;key&quot;:&quot;/message&quot;,&quot;value&quot;:&quot;Hello World&quot;,&quot;modifiedIndex&quot;:9,&quot;createdIndex&quot;:9}}
$ curl -L http://$(docker-machine ip etcd-node-1):2379/v2/keys/message
{&quot;action&quot;:&quot;set&quot;,&quot;node&quot;:{&quot;key&quot;:&quot;/message&quot;,&quot;value&quot;:&quot;Hello World&quot;,&quot;modifiedIndex&quot;:9,&quot;createdIndex&quot;:9}}
$ curl -L http://$(docker-machine ip etcd-node-1):2379/v2/keys/message
{&quot;action&quot;:&quot;set&quot;,&quot;node&quot;:{&quot;key&quot;:&quot;/message&quot;,&quot;value&quot;:&quot;Hello World&quot;,&quot;modifiedIndex&quot;:9,&quot;createdIndex&quot;:9}}
</code></pre></blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/07/11/docker_machine_mirror/">在 Docker Machine 中使用 Mirror 服务</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/07/11/docker_machine_mirror/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-07-10T16:00:00.000Z" itemprop="datePublished">2017-07-11</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/docker/">docker</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <blockquote>
<pre><code>$ export REGISTRY_MIRROR=https://***.mirror.aliyuncs.com
$ docker-machine create -d virtualbox --engine-registry-mirror $REGISTRY_MIRROR dev
</code></pre></blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2017/07/10/yarn/">Yarn介绍</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="/2017/07/10/yarn/">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2017-07-09T16:00:00.000Z" itemprop="datePublished">2017-07-10</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Nodejs/">Nodejs</a>, <a class="article-tag-link" href="/tags/Yarn/">Yarn</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="Yarn介紹"><a href="#Yarn介紹" class="headerlink" title="Yarn介紹"></a>Yarn介紹</h2><blockquote>
<p>Facebook发布的新一代包管理工具，旨在解决以往使用npm作为包管理会遇到的一些问题。从其官方介绍可以看到其重点强调的3个点：快、可靠、安全。</p>
</blockquote>
<h2 id="Yarn特性"><a href="#Yarn特性" class="headerlink" title="Yarn特性"></a>Yarn特性</h2><blockquote>
<h3 id="离线模式"><a href="#离线模式" class="headerlink" title="离线模式"></a>离线模式</h3><p>以前安装过的包可以在没有任何互联网连接的情况下重新安装。</p>
<h3 id="确定性"><a href="#确定性" class="headerlink" title="确定性"></a>确定性</h3><p>不管安装顺序如何，相同的依赖关系将在每台机器上以相同的方式安装。</p>
<h3 id="网络性能"><a href="#网络性能" class="headerlink" title="网络性能"></a>网络性能</h3><p>Yarn 有效地对请求进行排队，并避免 request waterfalls， 以便最大限度地利用网络。</p>
<h3 id="多个-Registries"><a href="#多个-Registries" class="headerlink" title="多个 Registries"></a>多个 Registries</h3><p>支持从 npm 或 Bower 安装包，并保持安装包的工作流程相同。</p>
<h3 id="网络恢复"><a href="#网络恢复" class="headerlink" title="网络恢复"></a>网络恢复</h3><p>单个请求失败不会导致安装失败，而会重试请求。</p>
<h3 id="扁平模式"><a href="#扁平模式" class="headerlink" title="扁平模式"></a>扁平模式</h3><p>将不兼容版本的依赖项解析为单个版本，以避免重复下载。</p>
</blockquote>
<h2 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h2><blockquote>
<pre><code>$ sudo npm i -g yarn
</code></pre></blockquote>
<h2 id="设置淘宝镜像"><a href="#设置淘宝镜像" class="headerlink" title="设置淘宝镜像"></a>设置淘宝镜像</h2><blockquote>
<pre><code>$ yarn config set registry https://registry.npm.taobao.org --global
$ yarn config set disturl https://npm.taobao.org/dist --global
</code></pre></blockquote>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><blockquote>
<h3 id="初始化一个新的项目"><a href="#初始化一个新的项目" class="headerlink" title="初始化一个新的项目"></a>初始化一个新的项目</h3><pre><code>$ yarn init
</code></pre><h3 id="添加一个依赖包"><a href="#添加一个依赖包" class="headerlink" title="添加一个依赖包"></a>添加一个依赖包</h3><pre><code>$ yarn add [package]
$ yarn add [package]@[version]
$ yarn add [package]@[tag]
</code></pre><h3 id="更新一个依赖包"><a href="#更新一个依赖包" class="headerlink" title="更新一个依赖包"></a>更新一个依赖包</h3><pre><code>$ yarn upgrade [package]
$ yarn upgrade [package]@[version]
$ yarn upgrade [package]@[tag]
</code></pre><h3 id="移除一个依赖包"><a href="#移除一个依赖包" class="headerlink" title="移除一个依赖包"></a>移除一个依赖包</h3><pre><code>$ yarn remove [package]
</code></pre><h3 id="安装项目所有的依赖包"><a href="#安装项目所有的依赖包" class="headerlink" title="安装项目所有的依赖包"></a>安装项目所有的依赖包</h3><pre><code>$ yarn
或
$ yarn install
</code></pre><p> Yarn命令列表</p>
</blockquote>
<table>
<thead>
<tr>
<th>命令</th>
<th>操作</th>
<th>参数</th>
<th>标签</th>
</tr>
</thead>
<tbody>
<tr>
<td>yarn add</td>
<td>添加依赖包</td>
<td>包名</td>
<td>–dev/-D</td>
</tr>
<tr>
<td>yarn bin</td>
<td>显示yarn安装目录</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>yarn cache</td>
<td>显示缓存</td>
<td>列出缓存包：ls，打出缓存目录路径：dir，清除缓存：clean</td>
<td>无</td>
</tr>
<tr>
<td>yarn check</td>
<td>检查包</td>
<td></td>
<td></td>
</tr>
<tr>
<td>yarn config</td>
<td>配置</td>
<td>设置：set <key> <value>， 删除：delete， 列出：list</value></key></td>
<td>[-g或–global]</td>
</tr>
<tr>
<td>yarn generate-lock-entry</td>
<td>生成锁定文件</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>yarn global</td>
<td>全局安装依赖包</td>
<td>yarn global <add bin="" ls="" remove="" upgrade=""> [–prefix]</add></td>
<td>–prefix 包路径前缀</td>
</tr>
<tr>
<td>yarn info</td>
<td>显示依赖包的信息</td>
<td>包名</td>
<td>–json：json格式显示结果</td>
</tr>
<tr>
<td>yarn init</td>
<td>互动式创建/更新package.json文件</td>
<td>无</td>
<td>–yes/-y：以默认值生成package.json文件</td>
</tr>
<tr>
<td>yarn install</td>
<td>安装所有依赖包</td>
<td></td>
<td>–flat：只安装一个版本；–force：强制重新下载安装；–har：输出安装时网络性能日志；–no-lockfile：不生成yarn.lock文件；–production：生产模式安装（不安装devDependencies中的依赖）</td>
</tr>
<tr>
<td>yarn licenses</td>
<td>列出已安装依赖包的证书</td>
<td>ls：证书列表；generate-disclaimer：生成免责声明</td>
<td></td>
</tr>
<tr>
<td>yarn link</td>
<td>开发时链接依赖包，以便在其他项目中使用</td>
<td>包名</td>
<td></td>
</tr>
<tr>
<td>yarn login</td>
<td>保存你的用户名、邮箱</td>
<td></td>
<td></td>
</tr>
<tr>
<td>yarn logout</td>
<td>删除你的用户名、邮箱</td>
<td></td>
<td></td>
</tr>
<tr>
<td>yarn list</td>
<td>列出已安装依赖包</td>
<td></td>
<td>–depth=0：列表深度，从0开始</td>
</tr>
<tr>
<td>yarn outdated</td>
<td>检查过时的依赖包</td>
<td>包名</td>
<td></td>
</tr>
<tr>
<td>yarn owner</td>
<td>管理拥有者</td>
<td>ls/add/remove</td>
<td></td>
</tr>
<tr>
<td>yarn pack</td>
<td>给包的依赖打包</td>
<td>–filename</td>
<td></td>
</tr>
<tr>
<td>yarn publish</td>
<td>将包发布到npm</td>
<td></td>
<td>–tag：版本标签；–access：公开（public）还是限制的（restricted）</td>
</tr>
<tr>
<td>yarn remove</td>
<td>卸载包，更新package.json和yarn.lock</td>
<td>包名</td>
<td></td>
</tr>
<tr>
<td>yarn run</td>
<td>运行package.json中预定义的脚本</td>
<td></td>
<td></td>
</tr>
<tr>
<td>yarn self-update</td>
<td>yarn自身更新–未实现</td>
<td></td>
<td></td>
</tr>
<tr>
<td>yarn tag</td>
<td>显示包的标签</td>
<td>add/rm/ls</td>
<td></td>
</tr>
<tr>
<td>yarn team</td>
<td>管理团队</td>
<td>create/destroy/add/rm/ls</td>
<td></td>
</tr>
<tr>
<td>yarn test</td>
<td>测试 = yarn run test</td>
<td></td>
<td></td>
</tr>
<tr>
<td>yarn unlink</td>
<td>取消链接依赖包</td>
<td></td>
<td></td>
</tr>
<tr>
<td>yarn upgrade</td>
<td>升级依赖包</td>
<td></td>
<td></td>
</tr>
<tr>
<td>yarn version</td>
<td>管理当前项目的版本号</td>
<td>–new-version ：直接记录版本号；–no-git-tag-version：不生成git标签</td>
<td></td>
</tr>
<tr>
<td>yarn why</td>
<td>分析为什么需要安装依赖包</td>
<td>包名/包目录/包目录中的文件名</td>
<td></td>
</tr>
</tbody>
</table>

        
    </section>
</article>




<nav class="page-nav">
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
</nav>


</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>
</footer>


    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    
    <script type="text/javascript">
        $(function() {
            var nodes = {
                nav: $('#nav'),
                aside: $('#aside'),
                navTags: $('#nav-tags')
            };

            $('#open-panel, #aside-mask').on('click', function() {
                nodes.aside.toggleClass('panel-show');
            });
            $('#nav-tag').on('click', function(event) {
                event.preventDefault();console.log(nodes.navTags.attr('class'))
                nodes.navTags.toggleClass('tag-show');console.log(nodes.navTags.attr('class'))
            })/*.hover(function() {
                nodes.navTags.addClass('tag-show');
            }, function() {
                nodes.navTags.removeClass('tag-show');
            });*/

            
        });
    </script>

</body>
</html>
